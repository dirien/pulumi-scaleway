# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'BaremetalServerIp',
    'BaremetalServerIpv4',
    'BaremetalServerIpv6',
    'BaremetalServerOption',
    'BaremetalServerPrivateNetwork',
    'CockpitEndpoint',
    'CockpitTokenScopes',
    'ContainerTriggerNats',
    'ContainerTriggerSqs',
    'DocumentDBReadReplicaDirectAccess',
    'DocumentDBReadReplicaPrivateNetwork',
    'DomainRecordGeoIp',
    'DomainRecordGeoIpMatch',
    'DomainRecordHttpService',
    'DomainRecordView',
    'DomainRecordWeighted',
    'FunctionTriggerNats',
    'FunctionTriggerSqs',
    'IamPolicyRule',
    'InstanceImageAdditionalVolume',
    'InstanceSecurityGroupInboundRule',
    'InstanceSecurityGroupOutboundRule',
    'InstanceSecurityGroupRulesInboundRule',
    'InstanceSecurityGroupRulesOutboundRule',
    'InstanceServerPrivateNetwork',
    'InstanceServerPublicIp',
    'InstanceServerRootVolume',
    'InstanceSnapshotImport',
    'IotDeviceCertificate',
    'IotDeviceMessageFilters',
    'IotDeviceMessageFiltersPublish',
    'IotDeviceMessageFiltersSubscribe',
    'IotRouteDatabase',
    'IotRouteRest',
    'IotRouteS3',
    'K8sClusterAutoUpgrade',
    'K8sClusterAutoscalerConfig',
    'K8sClusterKubeconfig',
    'K8sClusterOpenIdConnectConfig',
    'K8sPoolNode',
    'K8sPoolUpgradePolicy',
    'LbAclAction',
    'LbAclActionRedirect',
    'LbAclMatch',
    'LbBackendHealthCheckHttp',
    'LbBackendHealthCheckHttps',
    'LbBackendHealthCheckTcp',
    'LbCertificateCustomCertificate',
    'LbCertificateLetsencrypt',
    'LbFrontendAcl',
    'LbFrontendAclAction',
    'LbFrontendAclActionRedirect',
    'LbFrontendAclMatch',
    'LbPrivateNetwork',
    'MnqCredentialNatsCredentials',
    'MnqCredentialSqsSnsCredentials',
    'MnqCredentialSqsSnsCredentialsPermissions',
    'MnqQueueNats',
    'MnqQueueSqs',
    'MnqSqsCredentialsPermissions',
    'ObjectBucketAclAccessControlPolicy',
    'ObjectBucketAclAccessControlPolicyGrant',
    'ObjectBucketAclAccessControlPolicyGrantGrantee',
    'ObjectBucketAclAccessControlPolicyOwner',
    'ObjectBucketCorsRule',
    'ObjectBucketLifecycleRule',
    'ObjectBucketLifecycleRuleExpiration',
    'ObjectBucketLifecycleRuleTransition',
    'ObjectBucketLockConfigurationRule',
    'ObjectBucketLockConfigurationRuleDefaultRetention',
    'ObjectBucketVersioning',
    'ObjectBucketWebsiteConfigurationErrorDocument',
    'ObjectBucketWebsiteConfigurationIndexDocument',
    'RdbAclAclRule',
    'RdbInstanceLoadBalancer',
    'RdbInstancePrivateNetwork',
    'RdbInstanceReadReplica',
    'RdbReadReplicaDirectAccess',
    'RdbReadReplicaPrivateNetwork',
    'RedisClusterAcl',
    'RedisClusterPrivateNetwork',
    'RedisClusterPublicNetwork',
    'VpcGatewayNetworkIpamConfig',
    'VpcPrivateNetworkIpv4Subnet',
    'VpcPrivateNetworkIpv6Subnet',
    'WebHostingCpanelUrl',
    'WebHostingOption',
    'GetBaremetalOfferCpusResult',
    'GetBaremetalOfferDiskResult',
    'GetBaremetalOfferMemoryResult',
    'GetBaremetalServerIpResult',
    'GetBaremetalServerIpv4Result',
    'GetBaremetalServerIpv6Result',
    'GetBaremetalServerOptionResult',
    'GetBaremetalServerPrivateNetworkResult',
    'GetBillingConsumptionsConsumptionResult',
    'GetBillingInvoicesInvoiceResult',
    'GetCockpitEndpointResult',
    'GetDomainRecordGeoIpResult',
    'GetDomainRecordGeoIpMatchResult',
    'GetDomainRecordHttpServiceResult',
    'GetDomainRecordViewResult',
    'GetDomainRecordWeightedResult',
    'GetFlexibleIpsIpResult',
    'GetFlexibleIpsIpMacAddressResult',
    'GetInstanceSecurityGroupInboundRuleResult',
    'GetInstanceSecurityGroupOutboundRuleResult',
    'GetInstanceServerPrivateNetworkResult',
    'GetInstanceServerPublicIpResult',
    'GetInstanceServerRootVolumeResult',
    'GetInstanceServersServerResult',
    'GetInstanceServersServerPublicIpResult',
    'GetInstanceSnapshotImportResult',
    'GetIotDeviceCertificateResult',
    'GetIotDeviceMessageFilterResult',
    'GetIotDeviceMessageFilterPublishResult',
    'GetIotDeviceMessageFilterSubscribeResult',
    'GetIpamIpResourceResult',
    'GetK8sClusterAutoUpgradeResult',
    'GetK8sClusterAutoscalerConfigResult',
    'GetK8sClusterKubeconfigResult',
    'GetK8sClusterOpenIdConnectConfigResult',
    'GetK8sPoolNodeResult',
    'GetK8sPoolUpgradePolicyResult',
    'GetLbAclsAclResult',
    'GetLbAclsAclActionResult',
    'GetLbAclsAclActionRedirectResult',
    'GetLbAclsAclMatchResult',
    'GetLbBackendHealthCheckHttpResult',
    'GetLbBackendHealthCheckTcpResult',
    'GetLbBackendsBackendResult',
    'GetLbBackendsBackendHealthCheckHttpResult',
    'GetLbBackendsBackendHealthCheckTcpResult',
    'GetLbCertificateCustomCertificateResult',
    'GetLbCertificateLetsencryptResult',
    'GetLbFrontendAclResult',
    'GetLbFrontendAclActionResult',
    'GetLbFrontendAclActionRedirectResult',
    'GetLbFrontendAclMatchResult',
    'GetLbFrontendsFrontendResult',
    'GetLbIpsIpResult',
    'GetLbPrivateNetworkResult',
    'GetLbRoutesRouteResult',
    'GetLbsLbResult',
    'GetLbsLbInstanceResult',
    'GetLbsLbIpResult',
    'GetObjectBucketCorsRuleResult',
    'GetObjectBucketLifecycleRuleResult',
    'GetObjectBucketLifecycleRuleExpirationResult',
    'GetObjectBucketLifecycleRuleTransitionResult',
    'GetObjectBucketVersioningResult',
    'GetRdbAclAclRuleResult',
    'GetRdbInstanceLoadBalancerResult',
    'GetRdbInstancePrivateNetworkResult',
    'GetRdbInstanceReadReplicaResult',
    'GetRedisClusterAclResult',
    'GetRedisClusterPrivateNetworkResult',
    'GetRedisClusterPublicNetworkResult',
    'GetVpcGatewayNetworkIpamConfigResult',
    'GetVpcPrivateNetworkIpv4SubnetResult',
    'GetVpcPrivateNetworkIpv6SubnetResult',
    'GetVpcsVpcResult',
    'GetWebHostOfferProductResult',
    'GetWebhostingCpanelUrlResult',
    'GetWebhostingOptionResult',
]

@pulumi.output_type
class BaremetalServerIp(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None,
                 reverse: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str address: The address of the IPv6.
        :param str id: The id of the private network to attach.
        :param str reverse: The reverse of the IPv6.
        :param str version: The type of the IPv6.
        """
        BaremetalServerIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             id: Optional[str] = None,
             reverse: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)
        if reverse is not None:
            _setter("reverse", reverse)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> Optional[str]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BaremetalServerIpv4(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None,
                 reverse: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str address: The address of the IPv6.
        :param str id: The id of the private network to attach.
        :param str reverse: The reverse of the IPv6.
        :param str version: The type of the IPv6.
        """
        BaremetalServerIpv4._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             id: Optional[str] = None,
             reverse: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)
        if reverse is not None:
            _setter("reverse", reverse)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> Optional[str]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BaremetalServerIpv6(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None,
                 reverse: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param str address: The address of the IPv6.
        :param str id: The id of the private network to attach.
        :param str reverse: The reverse of the IPv6.
        :param str version: The type of the IPv6.
        """
        BaremetalServerIpv6._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             id: Optional[str] = None,
             reverse: Optional[str] = None,
             version: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)
        if reverse is not None:
            _setter("reverse", reverse)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> Optional[str]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class BaremetalServerOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiresAt":
            suggest = "expires_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BaremetalServerOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BaremetalServerOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BaremetalServerOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 expires_at: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The id of the private network to attach.
        :param str expires_at: The auto expiration date for compatible options
        :param str name: The name of the server.
        """
        BaremetalServerOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            expires_at=expires_at,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             expires_at: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'expiresAt' in kwargs:
            expires_at = kwargs['expiresAt']

        _setter("id", id)
        if expires_at is not None:
            _setter("expires_at", expires_at)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[str]:
        """
        The auto expiration date for compatible options
        """
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BaremetalServerPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BaremetalServerPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BaremetalServerPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BaremetalServerPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 created_at: Optional[str] = None,
                 status: Optional[str] = None,
                 updated_at: Optional[str] = None,
                 vlan: Optional[int] = None):
        """
        :param str id: The id of the private network to attach.
        :param str created_at: The date and time of the creation of the private network.
        :param str status: The private network status.
        :param str updated_at: The date and time of the last update of the private network.
        :param int vlan: The VLAN ID associated to the private network.
        """
        BaremetalServerPrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            created_at=created_at,
            status=status,
            updated_at=updated_at,
            vlan=vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             created_at: Optional[str] = None,
             status: Optional[str] = None,
             updated_at: Optional[str] = None,
             vlan: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("id", id)
        if created_at is not None:
            _setter("created_at", created_at)
        if status is not None:
            _setter("status", status)
        if updated_at is not None:
            _setter("updated_at", updated_at)
        if vlan is not None:
            _setter("vlan", vlan)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The date and time of the creation of the private network.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The private network status.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The date and time of the last update of the private network.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def vlan(self) -> Optional[int]:
        """
        The VLAN ID associated to the private network.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class CockpitEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertmanagerUrl":
            suggest = "alertmanager_url"
        elif key == "grafanaUrl":
            suggest = "grafana_url"
        elif key == "logsUrl":
            suggest = "logs_url"
        elif key == "metricsUrl":
            suggest = "metrics_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CockpitEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CockpitEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CockpitEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alertmanager_url: Optional[str] = None,
                 grafana_url: Optional[str] = None,
                 logs_url: Optional[str] = None,
                 metrics_url: Optional[str] = None):
        """
        :param str alertmanager_url: The alertmanager URL
        :param str grafana_url: The grafana URL
        :param str logs_url: The logs URL
        :param str metrics_url: The metrics URL
        """
        CockpitEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alertmanager_url=alertmanager_url,
            grafana_url=grafana_url,
            logs_url=logs_url,
            metrics_url=metrics_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alertmanager_url: Optional[str] = None,
             grafana_url: Optional[str] = None,
             logs_url: Optional[str] = None,
             metrics_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'alertmanagerUrl' in kwargs:
            alertmanager_url = kwargs['alertmanagerUrl']
        if 'grafanaUrl' in kwargs:
            grafana_url = kwargs['grafanaUrl']
        if 'logsUrl' in kwargs:
            logs_url = kwargs['logsUrl']
        if 'metricsUrl' in kwargs:
            metrics_url = kwargs['metricsUrl']

        if alertmanager_url is not None:
            _setter("alertmanager_url", alertmanager_url)
        if grafana_url is not None:
            _setter("grafana_url", grafana_url)
        if logs_url is not None:
            _setter("logs_url", logs_url)
        if metrics_url is not None:
            _setter("metrics_url", metrics_url)

    @property
    @pulumi.getter(name="alertmanagerUrl")
    def alertmanager_url(self) -> Optional[str]:
        """
        The alertmanager URL
        """
        return pulumi.get(self, "alertmanager_url")

    @property
    @pulumi.getter(name="grafanaUrl")
    def grafana_url(self) -> Optional[str]:
        """
        The grafana URL
        """
        return pulumi.get(self, "grafana_url")

    @property
    @pulumi.getter(name="logsUrl")
    def logs_url(self) -> Optional[str]:
        """
        The logs URL
        """
        return pulumi.get(self, "logs_url")

    @property
    @pulumi.getter(name="metricsUrl")
    def metrics_url(self) -> Optional[str]:
        """
        The metrics URL
        """
        return pulumi.get(self, "metrics_url")


@pulumi.output_type
class CockpitTokenScopes(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryLogs":
            suggest = "query_logs"
        elif key == "queryMetrics":
            suggest = "query_metrics"
        elif key == "setupAlerts":
            suggest = "setup_alerts"
        elif key == "setupLogsRules":
            suggest = "setup_logs_rules"
        elif key == "setupMetricsRules":
            suggest = "setup_metrics_rules"
        elif key == "writeLogs":
            suggest = "write_logs"
        elif key == "writeMetrics":
            suggest = "write_metrics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CockpitTokenScopes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CockpitTokenScopes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CockpitTokenScopes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_logs: Optional[bool] = None,
                 query_metrics: Optional[bool] = None,
                 setup_alerts: Optional[bool] = None,
                 setup_logs_rules: Optional[bool] = None,
                 setup_metrics_rules: Optional[bool] = None,
                 write_logs: Optional[bool] = None,
                 write_metrics: Optional[bool] = None):
        """
        :param bool query_logs: Query logs
        :param bool query_metrics: Query metrics
        :param bool setup_alerts: Setup alerts
        :param bool setup_logs_rules: Setup logs rules
        :param bool setup_metrics_rules: Setup metrics rules
        :param bool write_logs: Write logs
        :param bool write_metrics: Write metrics
        """
        CockpitTokenScopes._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_logs=query_logs,
            query_metrics=query_metrics,
            setup_alerts=setup_alerts,
            setup_logs_rules=setup_logs_rules,
            setup_metrics_rules=setup_metrics_rules,
            write_logs=write_logs,
            write_metrics=write_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_logs: Optional[bool] = None,
             query_metrics: Optional[bool] = None,
             setup_alerts: Optional[bool] = None,
             setup_logs_rules: Optional[bool] = None,
             setup_metrics_rules: Optional[bool] = None,
             write_logs: Optional[bool] = None,
             write_metrics: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryLogs' in kwargs:
            query_logs = kwargs['queryLogs']
        if 'queryMetrics' in kwargs:
            query_metrics = kwargs['queryMetrics']
        if 'setupAlerts' in kwargs:
            setup_alerts = kwargs['setupAlerts']
        if 'setupLogsRules' in kwargs:
            setup_logs_rules = kwargs['setupLogsRules']
        if 'setupMetricsRules' in kwargs:
            setup_metrics_rules = kwargs['setupMetricsRules']
        if 'writeLogs' in kwargs:
            write_logs = kwargs['writeLogs']
        if 'writeMetrics' in kwargs:
            write_metrics = kwargs['writeMetrics']

        if query_logs is not None:
            _setter("query_logs", query_logs)
        if query_metrics is not None:
            _setter("query_metrics", query_metrics)
        if setup_alerts is not None:
            _setter("setup_alerts", setup_alerts)
        if setup_logs_rules is not None:
            _setter("setup_logs_rules", setup_logs_rules)
        if setup_metrics_rules is not None:
            _setter("setup_metrics_rules", setup_metrics_rules)
        if write_logs is not None:
            _setter("write_logs", write_logs)
        if write_metrics is not None:
            _setter("write_metrics", write_metrics)

    @property
    @pulumi.getter(name="queryLogs")
    def query_logs(self) -> Optional[bool]:
        """
        Query logs
        """
        return pulumi.get(self, "query_logs")

    @property
    @pulumi.getter(name="queryMetrics")
    def query_metrics(self) -> Optional[bool]:
        """
        Query metrics
        """
        return pulumi.get(self, "query_metrics")

    @property
    @pulumi.getter(name="setupAlerts")
    def setup_alerts(self) -> Optional[bool]:
        """
        Setup alerts
        """
        return pulumi.get(self, "setup_alerts")

    @property
    @pulumi.getter(name="setupLogsRules")
    def setup_logs_rules(self) -> Optional[bool]:
        """
        Setup logs rules
        """
        return pulumi.get(self, "setup_logs_rules")

    @property
    @pulumi.getter(name="setupMetricsRules")
    def setup_metrics_rules(self) -> Optional[bool]:
        """
        Setup metrics rules
        """
        return pulumi.get(self, "setup_metrics_rules")

    @property
    @pulumi.getter(name="writeLogs")
    def write_logs(self) -> Optional[bool]:
        """
        Write logs
        """
        return pulumi.get(self, "write_logs")

    @property
    @pulumi.getter(name="writeMetrics")
    def write_metrics(self) -> Optional[bool]:
        """
        Write metrics
        """
        return pulumi.get(self, "write_metrics")


@pulumi.output_type
class ContainerTriggerNats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerTriggerNats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerTriggerNats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerTriggerNats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: str,
                 account_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str subject: The subject to listen to
        :param str account_id: ID of the mnq nats account.
        :param str project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param str region: `region`). The region in which the namespace should be created.
        """
        ContainerTriggerNats._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject=subject,
            account_id=account_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject: str,
             account_id: Optional[str] = None,
             project_id: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("subject", subject)
        if account_id is not None:
            _setter("account_id", account_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject to listen to
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        ID of the mnq nats account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class ContainerTriggerSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContainerTriggerSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContainerTriggerSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContainerTriggerSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue: str,
                 namespace_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str queue: Name of the queue
        :param str namespace_id: ID of the mnq namespace. Deprecated.
        :param str project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param str region: `region`). The region in which the namespace should be created.
        """
        ContainerTriggerSqs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue=queue,
            namespace_id=namespace_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue: str,
             namespace_id: Optional[str] = None,
             project_id: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("queue", queue)
        if namespace_id is not None:
            _setter("namespace_id", namespace_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the mnq namespace. Deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class DocumentDBReadReplicaDirectAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DocumentDBReadReplicaDirectAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DocumentDBReadReplicaDirectAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DocumentDBReadReplicaDirectAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str endpoint_id: The ID of the endpoint of the read replica.
        :param str hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param str ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param str name: Name of the endpoint.
        :param int port: TCP port of the endpoint.
        """
        DocumentDBReadReplicaDirectAccess._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class DocumentDBReadReplicaPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "endpointId":
            suggest = "endpoint_id"
        elif key == "serviceIp":
            suggest = "service_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DocumentDBReadReplicaPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DocumentDBReadReplicaPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DocumentDBReadReplicaPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: str,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 service_ip: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str private_network_id: UUID of the private network to be connected to the read replica.
        :param str endpoint_id: The ID of the endpoint of the read replica.
        :param str hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param str ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param str name: Name of the endpoint.
        :param int port: TCP port of the endpoint.
        :param str service_ip: The IP network address within the private subnet. This must be an IPv4 address with a
               CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
               service if not set.
        """
        DocumentDBReadReplicaPrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_network_id=private_network_id,
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
            service_ip=service_ip,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_network_id: str,
             endpoint_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             service_ip: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIp' in kwargs:
            service_ip = kwargs['serviceIp']

        _setter("private_network_id", private_network_id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)
        if service_ip is not None:
            _setter("service_ip", service_ip)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        UUID of the private network to be connected to the read replica.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> Optional[str]:
        """
        The IP network address within the private subnet. This must be an IPv4 address with a
        CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
        service if not set.
        """
        return pulumi.get(self, "service_ip")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class DomainRecordGeoIp(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.DomainRecordGeoIpMatch']):
        """
        :param Sequence['DomainRecordGeoIpMatchArgs'] matches: The list of matches. *(Can be more than 1)*
        """
        DomainRecordGeoIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Sequence['outputs.DomainRecordGeoIpMatch'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.DomainRecordGeoIpMatch']:
        """
        The list of matches. *(Can be more than 1)*
        """
        return pulumi.get(self, "matches")


@pulumi.output_type
class DomainRecordGeoIpMatch(dict):
    def __init__(__self__, *,
                 data: str,
                 continents: Optional[Sequence[str]] = None,
                 countries: Optional[Sequence[str]] = None):
        """
        :param str data: The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        :param Sequence[str] continents: List of continents (eg: `EU` for Europe, `NA` for North America, `AS` for Asia...). [List of all continents code](https://api.scaleway.com/domain-private/v2beta1/continents)
        :param Sequence[str] countries: List of countries (eg: `FR` for France, `US` for the United States, `GB` for Great Britain...). [List of all countries code](https://api.scaleway.com/domain-private/v2beta1/countries)
        """
        DomainRecordGeoIpMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            continents=continents,
            countries=countries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: str,
             continents: Optional[Sequence[str]] = None,
             countries: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("data", data)
        if continents is not None:
            _setter("continents", continents)
        if countries is not None:
            _setter("countries", countries)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def continents(self) -> Optional[Sequence[str]]:
        """
        List of continents (eg: `EU` for Europe, `NA` for North America, `AS` for Asia...). [List of all continents code](https://api.scaleway.com/domain-private/v2beta1/continents)
        """
        return pulumi.get(self, "continents")

    @property
    @pulumi.getter
    def countries(self) -> Optional[Sequence[str]]:
        """
        List of countries (eg: `FR` for France, `US` for the United States, `GB` for Great Britain...). [List of all countries code](https://api.scaleway.com/domain-private/v2beta1/countries)
        """
        return pulumi.get(self, "countries")


@pulumi.output_type
class DomainRecordHttpService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mustContain":
            suggest = "must_contain"
        elif key == "userAgent":
            suggest = "user_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainRecordHttpService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainRecordHttpService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainRecordHttpService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ips: Sequence[str],
                 must_contain: str,
                 strategy: str,
                 url: str,
                 user_agent: Optional[str] = None):
        """
        :param Sequence[str] ips: List of IPs to check
        :param str must_contain: Text to search
        :param str strategy: Strategy to return an IP from the IPs list. Can be `random`, `hashed` or `all`
        :param str url: URL to match the `must_contain` text to validate an IP
        :param str user_agent: User-agent used when checking the URL
        """
        DomainRecordHttpService._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ips=ips,
            must_contain=must_contain,
            strategy=strategy,
            url=url,
            user_agent=user_agent,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ips: Sequence[str],
             must_contain: str,
             strategy: str,
             url: str,
             user_agent: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mustContain' in kwargs:
            must_contain = kwargs['mustContain']
        if 'userAgent' in kwargs:
            user_agent = kwargs['userAgent']

        _setter("ips", ips)
        _setter("must_contain", must_contain)
        _setter("strategy", strategy)
        _setter("url", url)
        if user_agent is not None:
            _setter("user_agent", user_agent)

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        """
        List of IPs to check
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="mustContain")
    def must_contain(self) -> str:
        """
        Text to search
        """
        return pulumi.get(self, "must_contain")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        """
        Strategy to return an IP from the IPs list. Can be `random`, `hashed` or `all`
        """
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL to match the `must_contain` text to validate an IP
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[str]:
        """
        User-agent used when checking the URL
        """
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class DomainRecordView(dict):
    def __init__(__self__, *,
                 data: str,
                 subnet: str):
        """
        :param str data: The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        :param str subnet: The subnet of the view
        """
        DomainRecordView._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: str,
             subnet: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("data", data)
        _setter("subnet", subnet)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        """
        The subnet of the view
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class DomainRecordWeighted(dict):
    def __init__(__self__, *,
                 ip: str,
                 weight: int):
        """
        :param str ip: The weighted IP
        :param int weight: The weight of the IP as an integer UInt32.
        """
        DomainRecordWeighted._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             weight: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The weighted IP
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def weight(self) -> int:
        """
        The weight of the IP as an integer UInt32.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class FunctionTriggerNats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerNats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerNats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerNats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subject: str,
                 account_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str subject: The subject to listen to
        :param str account_id: ID of the mnq nats account.
        :param str project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param str region: `region`). The region in which the namespace should be created.
        """
        FunctionTriggerNats._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject=subject,
            account_id=account_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject: str,
             account_id: Optional[str] = None,
             project_id: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("subject", subject)
        if account_id is not None:
            _setter("account_id", account_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def subject(self) -> str:
        """
        The subject to listen to
        """
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        ID of the mnq nats account.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class FunctionTriggerSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "namespaceId":
            suggest = "namespace_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FunctionTriggerSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FunctionTriggerSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FunctionTriggerSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queue: str,
                 namespace_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None):
        """
        :param str queue: Name of the queue
        :param str namespace_id: ID of the mnq namespace. Deprecated.
        :param str project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param str region: `region`). The region in which the namespace should be created.
        """
        FunctionTriggerSqs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue=queue,
            namespace_id=namespace_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue: str,
             namespace_id: Optional[str] = None,
             project_id: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("queue", queue)
        if namespace_id is not None:
            _setter("namespace_id", namespace_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def queue(self) -> str:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue")

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[str]:
        """
        ID of the mnq namespace. Deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class IamPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionSetNames":
            suggest = "permission_set_names"
        elif key == "organizationId":
            suggest = "organization_id"
        elif key == "projectIds":
            suggest = "project_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IamPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IamPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IamPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_set_names: Sequence[str],
                 organization_id: Optional[str] = None,
                 project_ids: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] permission_set_names: Names of permission sets bound to the rule.
               
               **_TIP:_**  You can use the Scaleway CLI to list the permissions details. e.g:
        :param str organization_id: ID of organization scoped to the rule.
        :param Sequence[str] project_ids: List of project IDs scoped to the rule.
               
               > **Important** One of `organization_id` or `project_ids`  must be set per rule.
        """
        IamPolicyRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permission_set_names=permission_set_names,
            organization_id=organization_id,
            project_ids=project_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permission_set_names: Sequence[str],
             organization_id: Optional[str] = None,
             project_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'permissionSetNames' in kwargs:
            permission_set_names = kwargs['permissionSetNames']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'projectIds' in kwargs:
            project_ids = kwargs['projectIds']

        _setter("permission_set_names", permission_set_names)
        if organization_id is not None:
            _setter("organization_id", organization_id)
        if project_ids is not None:
            _setter("project_ids", project_ids)

    @property
    @pulumi.getter(name="permissionSetNames")
    def permission_set_names(self) -> Sequence[str]:
        """
        Names of permission sets bound to the rule.

        **_TIP:_**  You can use the Scaleway CLI to list the permissions details. e.g:
        """
        return pulumi.get(self, "permission_set_names")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[str]:
        """
        ID of organization scoped to the rule.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[Sequence[str]]:
        """
        List of project IDs scoped to the rule.

        > **Important** One of `organization_id` or `project_ids`  must be set per rule.
        """
        return pulumi.get(self, "project_ids")


@pulumi.output_type
class InstanceImageAdditionalVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "creationDate":
            suggest = "creation_date"
        elif key == "exportUri":
            suggest = "export_uri"
        elif key == "modificationDate":
            suggest = "modification_date"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceImageAdditionalVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceImageAdditionalVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceImageAdditionalVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 creation_date: Optional[str] = None,
                 export_uri: Optional[str] = None,
                 id: Optional[str] = None,
                 modification_date: Optional[str] = None,
                 name: Optional[str] = None,
                 organization: Optional[str] = None,
                 project: Optional[str] = None,
                 server: Optional[Mapping[str, str]] = None,
                 size: Optional[int] = None,
                 state: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 volume_type: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str creation_date: Date of the volume creation.
        :param str export_uri: The export URI of the volume.
        :param str id: ID of the server containing the volume.
        :param str modification_date: Date of volume latest update.
        :param str name: The name of the image. If not provided it will be randomly generated.
        :param str organization: The organization ID the volume is associated with.
        :param str project: ID of the project the volume is associated with
        :param Mapping[str, str] server: Description of the server containing the volume (in case the image is a backup from a server).
        :param int size: The size of the volume.
        :param str state: State of the volume.
        :param Sequence[str] tags: A list of tags to apply to the image.
        :param str volume_type: The type of volume, possible values are `l_ssd` and `b_ssd`.
        :param str zone: The zone in which the image should be created.
        """
        InstanceImageAdditionalVolume._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_date=creation_date,
            export_uri=export_uri,
            id=id,
            modification_date=modification_date,
            name=name,
            organization=organization,
            project=project,
            server=server,
            size=size,
            state=state,
            tags=tags,
            volume_type=volume_type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_date: Optional[str] = None,
             export_uri: Optional[str] = None,
             id: Optional[str] = None,
             modification_date: Optional[str] = None,
             name: Optional[str] = None,
             organization: Optional[str] = None,
             project: Optional[str] = None,
             server: Optional[Mapping[str, str]] = None,
             size: Optional[int] = None,
             state: Optional[str] = None,
             tags: Optional[Sequence[str]] = None,
             volume_type: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'creationDate' in kwargs:
            creation_date = kwargs['creationDate']
        if 'exportUri' in kwargs:
            export_uri = kwargs['exportUri']
        if 'modificationDate' in kwargs:
            modification_date = kwargs['modificationDate']
        if 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if creation_date is not None:
            _setter("creation_date", creation_date)
        if export_uri is not None:
            _setter("export_uri", export_uri)
        if id is not None:
            _setter("id", id)
        if modification_date is not None:
            _setter("modification_date", modification_date)
        if name is not None:
            _setter("name", name)
        if organization is not None:
            _setter("organization", organization)
        if project is not None:
            _setter("project", project)
        if server is not None:
            _setter("server", server)
        if size is not None:
            _setter("size", size)
        if state is not None:
            _setter("state", state)
        if tags is not None:
            _setter("tags", tags)
        if volume_type is not None:
            _setter("volume_type", volume_type)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[str]:
        """
        Date of the volume creation.
        """
        return pulumi.get(self, "creation_date")

    @property
    @pulumi.getter(name="exportUri")
    def export_uri(self) -> Optional[str]:
        """
        The export URI of the volume.
        """
        return pulumi.get(self, "export_uri")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the server containing the volume.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="modificationDate")
    def modification_date(self) -> Optional[str]:
        """
        Date of volume latest update.
        """
        return pulumi.get(self, "modification_date")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the image. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def organization(self) -> Optional[str]:
        """
        The organization ID the volume is associated with.
        """
        return pulumi.get(self, "organization")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        ID of the project the volume is associated with
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def server(self) -> Optional[Mapping[str, str]]:
        """
        Description of the server containing the volume (in case the image is a backup from a server).
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def size(self) -> Optional[int]:
        """
        The size of the volume.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the volume.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        A list of tags to apply to the image.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        The type of volume, possible values are `l_ssd` and `b_ssd`.
        """
        return pulumi.get(self, "volume_type")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        The zone in which the image should be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InstanceSecurityGroupInboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupInboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupInboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupInboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param int port: The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupInboundRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             ip: Optional[str] = None,
             ip_range: Optional[str] = None,
             port: Optional[int] = None,
             port_range: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceSecurityGroupOutboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupOutboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupOutboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupOutboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param int port: The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupOutboundRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             ip: Optional[str] = None,
             ip_range: Optional[str] = None,
             port: Optional[int] = None,
             port_range: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceSecurityGroupRulesInboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupRulesInboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupRulesInboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupRulesInboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupRulesInboundRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             ip: Optional[str] = None,
             ip_range: Optional[str] = None,
             port: Optional[int] = None,
             port_range: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceSecurityGroupRulesOutboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipRange":
            suggest = "ip_range"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceSecurityGroupRulesOutboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceSecurityGroupRulesOutboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceSecurityGroupRulesOutboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 ip: Optional[str] = None,
                 ip_range: Optional[str] = None,
                 port: Optional[int] = None,
                 port_range: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupRulesOutboundRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             ip: Optional[str] = None,
             ip_range: Optional[str] = None,
             port: Optional[int] = None,
             port_range: Optional[str] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[str]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InstanceServerPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pnId":
            suggest = "pn_id"
        elif key == "macAddress":
            suggest = "mac_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceServerPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceServerPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceServerPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pn_id: str,
                 mac_address: Optional[str] = None,
                 status: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str zone: `zone`) The zone in which the server should be created.
        """
        InstanceServerPrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pn_id=pn_id,
            mac_address=mac_address,
            status=status,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pn_id: str,
             mac_address: Optional[str] = None,
             status: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pnId' in kwargs:
            pn_id = kwargs['pnId']
        if 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']

        _setter("pn_id", pn_id)
        if mac_address is not None:
            _setter("mac_address", mac_address)
        if status is not None:
            _setter("status", status)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[str]:
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone in which the server should be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class InstanceServerPublicIp(dict):
    def __init__(__self__, *,
                 address: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str address: The address of the IP
        :param str id: The ID of the IP
        """
        InstanceServerPublicIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class InstanceServerRootVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteOnTermination":
            suggest = "delete_on_termination"
        elif key == "sizeInGb":
            suggest = "size_in_gb"
        elif key == "volumeId":
            suggest = "volume_id"
        elif key == "volumeType":
            suggest = "volume_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InstanceServerRootVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InstanceServerRootVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InstanceServerRootVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boot: Optional[bool] = None,
                 delete_on_termination: Optional[bool] = None,
                 name: Optional[str] = None,
                 size_in_gb: Optional[int] = None,
                 volume_id: Optional[str] = None,
                 volume_type: Optional[str] = None):
        """
        :param bool delete_on_termination: Forces deletion of the root volume on instance termination.
               
               > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
        :param str name: The name of the server.
        :param int size_in_gb: Size of the root volume in gigabytes.
               To find the right size use [this endpoint](https://api.scaleway.com/instance/v1/zones/fr-par-1/products/servers) and
               check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
               Updates to this field will recreate a new resource.
        :param str volume_id: The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        :param str volume_type: Volume type of root volume, can be `b_ssd` or `l_ssd`, default value depends on server type
        """
        InstanceServerRootVolume._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot=boot,
            delete_on_termination=delete_on_termination,
            name=name,
            size_in_gb=size_in_gb,
            volume_id=volume_id,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot: Optional[bool] = None,
             delete_on_termination: Optional[bool] = None,
             name: Optional[str] = None,
             size_in_gb: Optional[int] = None,
             volume_id: Optional[str] = None,
             volume_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if 'sizeInGb' in kwargs:
            size_in_gb = kwargs['sizeInGb']
        if 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if boot is not None:
            _setter("boot", boot)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if name is not None:
            _setter("name", name)
        if size_in_gb is not None:
            _setter("size_in_gb", size_in_gb)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter
    def boot(self) -> Optional[bool]:
        return pulumi.get(self, "boot")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[bool]:
        """
        Forces deletion of the root volume on instance termination.

        > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> Optional[int]:
        """
        Size of the root volume in gigabytes.
        To find the right size use [this endpoint](https://api.scaleway.com/instance/v1/zones/fr-par-1/products/servers) and
        check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
        Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[str]:
        """
        The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[str]:
        """
        Volume type of root volume, can be `b_ssd` or `l_ssd`, default value depends on server type
        """
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class InstanceSnapshotImport(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        """
        :param str bucket: Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        :param str key: Key of the object to import
               
               > **Note:** The type `unified` could be instantiated on both `l_ssd` and `b_ssd` volumes.
        """
        InstanceSnapshotImport._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: str,
             key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("bucket", bucket)
        _setter("key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key of the object to import

        > **Note:** The type `unified` could be instantiated on both `l_ssd` and `b_ssd` volumes.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IotDeviceCertificate(dict):
    def __init__(__self__, *,
                 crt: Optional[str] = None,
                 key: Optional[str] = None):
        """
        :param str key: The private key of the device, in case it is generated by Scaleway.
        """
        IotDeviceCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crt=crt,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crt: Optional[str] = None,
             key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if crt is not None:
            _setter("crt", crt)
        if key is not None:
            _setter("key", key)

    @property
    @pulumi.getter
    def crt(self) -> Optional[str]:
        return pulumi.get(self, "crt")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        The private key of the device, in case it is generated by Scaleway.
        """
        return pulumi.get(self, "key")


@pulumi.output_type
class IotDeviceMessageFilters(dict):
    def __init__(__self__, *,
                 publish: Optional['outputs.IotDeviceMessageFiltersPublish'] = None,
                 subscribe: Optional['outputs.IotDeviceMessageFiltersSubscribe'] = None):
        """
        :param 'IotDeviceMessageFiltersPublishArgs' publish: Rules used to restrict topics the device can publish to.
        :param 'IotDeviceMessageFiltersSubscribeArgs' subscribe: Rules used to restrict topics the device can subscribe to.
        """
        IotDeviceMessageFilters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish=publish,
            subscribe=subscribe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish: Optional['outputs.IotDeviceMessageFiltersPublish'] = None,
             subscribe: Optional['outputs.IotDeviceMessageFiltersSubscribe'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if publish is not None:
            _setter("publish", publish)
        if subscribe is not None:
            _setter("subscribe", subscribe)

    @property
    @pulumi.getter
    def publish(self) -> Optional['outputs.IotDeviceMessageFiltersPublish']:
        """
        Rules used to restrict topics the device can publish to.
        """
        return pulumi.get(self, "publish")

    @property
    @pulumi.getter
    def subscribe(self) -> Optional['outputs.IotDeviceMessageFiltersSubscribe']:
        """
        Rules used to restrict topics the device can subscribe to.
        """
        return pulumi.get(self, "subscribe")


@pulumi.output_type
class IotDeviceMessageFiltersPublish(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None,
                 topics: Optional[Sequence[str]] = None):
        """
        :param str policy: Same as publish rules.
        :param Sequence[str] topics: Same as publish rules.
               
               - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
               
               > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        IotDeviceMessageFiltersPublish._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            topics=topics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[str] = None,
             topics: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if policy is not None:
            _setter("policy", policy)
        if topics is not None:
            _setter("topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Same as publish rules.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[str]]:
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class IotDeviceMessageFiltersSubscribe(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None,
                 topics: Optional[Sequence[str]] = None):
        """
        :param str policy: Same as publish rules.
        :param Sequence[str] topics: Same as publish rules.
               
               - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
               
               > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        IotDeviceMessageFiltersSubscribe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            topics=topics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[str] = None,
             topics: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if policy is not None:
            _setter("policy", policy)
        if topics is not None:
            _setter("topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Same as publish rules.
        """
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Optional[Sequence[str]]:
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        return pulumi.get(self, "topics")


@pulumi.output_type
class IotRouteDatabase(dict):
    def __init__(__self__, *,
                 dbname: str,
                 host: str,
                 password: str,
                 port: int,
                 query: str,
                 username: str):
        IotRouteDatabase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbname=dbname,
            host=host,
            password=password,
            port=port,
            query=query,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbname: str,
             host: str,
             password: str,
             port: int,
             query: str,
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("dbname", dbname)
        _setter("host", host)
        _setter("password", password)
        _setter("port", port)
        _setter("query", query)
        _setter("username", username)

    @property
    @pulumi.getter
    def dbname(self) -> str:
        return pulumi.get(self, "dbname")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")


@pulumi.output_type
class IotRouteRest(dict):
    def __init__(__self__, *,
                 headers: Mapping[str, str],
                 uri: str,
                 verb: str):
        IotRouteRest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            uri=uri,
            verb=verb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: Mapping[str, str],
             uri: str,
             verb: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("headers", headers)
        _setter("uri", uri)
        _setter("verb", verb)

    @property
    @pulumi.getter
    def headers(self) -> Mapping[str, str]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def verb(self) -> str:
        return pulumi.get(self, "verb")


@pulumi.output_type
class IotRouteS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "bucketRegion":
            suggest = "bucket_region"
        elif key == "objectPrefix":
            suggest = "object_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IotRouteS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IotRouteS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IotRouteS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: str,
                 bucket_region: str,
                 strategy: str,
                 object_prefix: Optional[str] = None):
        IotRouteS3._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_region=bucket_region,
            strategy=strategy,
            object_prefix=object_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: str,
             bucket_region: str,
             strategy: str,
             object_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if 'bucketRegion' in kwargs:
            bucket_region = kwargs['bucketRegion']
        if 'objectPrefix' in kwargs:
            object_prefix = kwargs['objectPrefix']

        _setter("bucket_name", bucket_name)
        _setter("bucket_region", bucket_region)
        _setter("strategy", strategy)
        if object_prefix is not None:
            _setter("object_prefix", object_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> str:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> str:
        return pulumi.get(self, "bucket_region")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> Optional[str]:
        return pulumi.get(self, "object_prefix")


@pulumi.output_type
class K8sClusterAutoUpgrade(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceWindowDay":
            suggest = "maintenance_window_day"
        elif key == "maintenanceWindowStartHour":
            suggest = "maintenance_window_start_hour"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAutoUpgrade. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAutoUpgrade.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAutoUpgrade.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable: bool,
                 maintenance_window_day: str,
                 maintenance_window_start_hour: int):
        """
        :param bool enable: Set to `true` to enable Kubernetes patch version auto upgrades.
               > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        :param str maintenance_window_day: The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        :param int maintenance_window_start_hour: The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        K8sClusterAutoUpgrade._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            maintenance_window_day=maintenance_window_day,
            maintenance_window_start_hour=maintenance_window_start_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: bool,
             maintenance_window_day: str,
             maintenance_window_start_hour: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maintenanceWindowDay' in kwargs:
            maintenance_window_day = kwargs['maintenanceWindowDay']
        if 'maintenanceWindowStartHour' in kwargs:
            maintenance_window_start_hour = kwargs['maintenanceWindowStartHour']

        _setter("enable", enable)
        _setter("maintenance_window_day", maintenance_window_day)
        _setter("maintenance_window_start_hour", maintenance_window_start_hour)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        Set to `true` to enable Kubernetes patch version auto upgrades.
        > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="maintenanceWindowDay")
    def maintenance_window_day(self) -> str:
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        return pulumi.get(self, "maintenance_window_day")

    @property
    @pulumi.getter(name="maintenanceWindowStartHour")
    def maintenance_window_start_hour(self) -> int:
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        return pulumi.get(self, "maintenance_window_start_hour")


@pulumi.output_type
class K8sClusterAutoscalerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "balanceSimilarNodeGroups":
            suggest = "balance_similar_node_groups"
        elif key == "disableScaleDown":
            suggest = "disable_scale_down"
        elif key == "expendablePodsPriorityCutoff":
            suggest = "expendable_pods_priority_cutoff"
        elif key == "ignoreDaemonsetsUtilization":
            suggest = "ignore_daemonsets_utilization"
        elif key == "maxGracefulTerminationSec":
            suggest = "max_graceful_termination_sec"
        elif key == "scaleDownDelayAfterAdd":
            suggest = "scale_down_delay_after_add"
        elif key == "scaleDownUnneededTime":
            suggest = "scale_down_unneeded_time"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterAutoscalerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterAutoscalerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterAutoscalerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[bool] = None,
                 disable_scale_down: Optional[bool] = None,
                 estimator: Optional[str] = None,
                 expander: Optional[str] = None,
                 expendable_pods_priority_cutoff: Optional[int] = None,
                 ignore_daemonsets_utilization: Optional[bool] = None,
                 max_graceful_termination_sec: Optional[int] = None,
                 scale_down_delay_after_add: Optional[str] = None,
                 scale_down_unneeded_time: Optional[str] = None,
                 scale_down_utilization_threshold: Optional[float] = None):
        """
        :param bool balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them.
        :param bool disable_scale_down: Disables the scale down feature of the autoscaler.
        :param str estimator: Type of resource estimator to be used in scale up.
        :param str expander: Type of node group expander to be used in scale up.
        :param int expendable_pods_priority_cutoff: Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        :param bool ignore_daemonsets_utilization: Ignore DaemonSet pods when calculating resource utilization for scaling down.
        :param int max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        :param str scale_down_delay_after_add: How long after scale up that scale down evaluation resumes.
        :param str scale_down_unneeded_time: How long a node should be unneeded before it is eligible for scale down.
        :param float scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        K8sClusterAutoscalerConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            balance_similar_node_groups=balance_similar_node_groups,
            disable_scale_down=disable_scale_down,
            estimator=estimator,
            expander=expander,
            expendable_pods_priority_cutoff=expendable_pods_priority_cutoff,
            ignore_daemonsets_utilization=ignore_daemonsets_utilization,
            max_graceful_termination_sec=max_graceful_termination_sec,
            scale_down_delay_after_add=scale_down_delay_after_add,
            scale_down_unneeded_time=scale_down_unneeded_time,
            scale_down_utilization_threshold=scale_down_utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             balance_similar_node_groups: Optional[bool] = None,
             disable_scale_down: Optional[bool] = None,
             estimator: Optional[str] = None,
             expander: Optional[str] = None,
             expendable_pods_priority_cutoff: Optional[int] = None,
             ignore_daemonsets_utilization: Optional[bool] = None,
             max_graceful_termination_sec: Optional[int] = None,
             scale_down_delay_after_add: Optional[str] = None,
             scale_down_unneeded_time: Optional[str] = None,
             scale_down_utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'balanceSimilarNodeGroups' in kwargs:
            balance_similar_node_groups = kwargs['balanceSimilarNodeGroups']
        if 'disableScaleDown' in kwargs:
            disable_scale_down = kwargs['disableScaleDown']
        if 'expendablePodsPriorityCutoff' in kwargs:
            expendable_pods_priority_cutoff = kwargs['expendablePodsPriorityCutoff']
        if 'ignoreDaemonsetsUtilization' in kwargs:
            ignore_daemonsets_utilization = kwargs['ignoreDaemonsetsUtilization']
        if 'maxGracefulTerminationSec' in kwargs:
            max_graceful_termination_sec = kwargs['maxGracefulTerminationSec']
        if 'scaleDownDelayAfterAdd' in kwargs:
            scale_down_delay_after_add = kwargs['scaleDownDelayAfterAdd']
        if 'scaleDownUnneededTime' in kwargs:
            scale_down_unneeded_time = kwargs['scaleDownUnneededTime']
        if 'scaleDownUtilizationThreshold' in kwargs:
            scale_down_utilization_threshold = kwargs['scaleDownUtilizationThreshold']

        if balance_similar_node_groups is not None:
            _setter("balance_similar_node_groups", balance_similar_node_groups)
        if disable_scale_down is not None:
            _setter("disable_scale_down", disable_scale_down)
        if estimator is not None:
            _setter("estimator", estimator)
        if expander is not None:
            _setter("expander", expander)
        if expendable_pods_priority_cutoff is not None:
            _setter("expendable_pods_priority_cutoff", expendable_pods_priority_cutoff)
        if ignore_daemonsets_utilization is not None:
            _setter("ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        if max_graceful_termination_sec is not None:
            _setter("max_graceful_termination_sec", max_graceful_termination_sec)
        if scale_down_delay_after_add is not None:
            _setter("scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_unneeded_time is not None:
            _setter("scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            _setter("scale_down_utilization_threshold", scale_down_utilization_threshold)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[bool]:
        """
        Detect similar node groups and balance the number of nodes between them.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter(name="disableScaleDown")
    def disable_scale_down(self) -> Optional[bool]:
        """
        Disables the scale down feature of the autoscaler.
        """
        return pulumi.get(self, "disable_scale_down")

    @property
    @pulumi.getter
    def estimator(self) -> Optional[str]:
        """
        Type of resource estimator to be used in scale up.
        """
        return pulumi.get(self, "estimator")

    @property
    @pulumi.getter
    def expander(self) -> Optional[str]:
        """
        Type of node group expander to be used in scale up.
        """
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter(name="expendablePodsPriorityCutoff")
    def expendable_pods_priority_cutoff(self) -> Optional[int]:
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        return pulumi.get(self, "expendable_pods_priority_cutoff")

    @property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> Optional[bool]:
        """
        Ignore DaemonSet pods when calculating resource utilization for scaling down.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[int]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[str]:
        """
        How long after scale up that scale down evaluation resumes.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[str]:
        """
        How long a node should be unneeded before it is eligible for scale down.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[float]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class K8sClusterKubeconfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"
        elif key == "configFile":
            suggest = "config_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterKubeconfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterKubeconfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterKubeconfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[str] = None,
                 config_file: Optional[str] = None,
                 host: Optional[str] = None,
                 token: Optional[str] = None):
        """
        :param str cluster_ca_certificate: The CA certificate of the Kubernetes API server.
        :param str config_file: The raw kubeconfig file.
        :param str host: The URL of the Kubernetes API server.
        :param str token: The token to connect to the Kubernetes API server.
        """
        K8sClusterKubeconfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_ca_certificate=cluster_ca_certificate,
            config_file=config_file,
            host=host,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_ca_certificate: Optional[str] = None,
             config_file: Optional[str] = None,
             host: Optional[str] = None,
             token: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clusterCaCertificate' in kwargs:
            cluster_ca_certificate = kwargs['clusterCaCertificate']
        if 'configFile' in kwargs:
            config_file = kwargs['configFile']

        if cluster_ca_certificate is not None:
            _setter("cluster_ca_certificate", cluster_ca_certificate)
        if config_file is not None:
            _setter("config_file", config_file)
        if host is not None:
            _setter("host", host)
        if token is not None:
            _setter("token", token)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[str]:
        """
        The CA certificate of the Kubernetes API server.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[str]:
        """
        The raw kubeconfig file.
        """
        return pulumi.get(self, "config_file")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The URL of the Kubernetes API server.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def token(self) -> Optional[str]:
        """
        The token to connect to the Kubernetes API server.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class K8sClusterOpenIdConnectConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "groupsClaims":
            suggest = "groups_claims"
        elif key == "groupsPrefix":
            suggest = "groups_prefix"
        elif key == "requiredClaims":
            suggest = "required_claims"
        elif key == "usernameClaim":
            suggest = "username_claim"
        elif key == "usernamePrefix":
            suggest = "username_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sClusterOpenIdConnectConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sClusterOpenIdConnectConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sClusterOpenIdConnectConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 issuer_url: str,
                 groups_claims: Optional[Sequence[str]] = None,
                 groups_prefix: Optional[str] = None,
                 required_claims: Optional[Sequence[str]] = None,
                 username_claim: Optional[str] = None,
                 username_prefix: Optional[str] = None):
        """
        :param str client_id: A client id that all tokens must be issued for
        :param str issuer_url: URL of the provider which allows the API server to discover public signing keys
        :param Sequence[str] groups_claims: JWT claim to use as the user's group
        :param str groups_prefix: Prefix prepended to group claims
        :param Sequence[str] required_claims: Multiple key=value pairs that describes a required claim in the ID Token
        :param str username_claim: JWT claim to use as the user name
        :param str username_prefix: Prefix prepended to username
        """
        K8sClusterOpenIdConnectConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            issuer_url=issuer_url,
            groups_claims=groups_claims,
            groups_prefix=groups_prefix,
            required_claims=required_claims,
            username_claim=username_claim,
            username_prefix=username_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             issuer_url: str,
             groups_claims: Optional[Sequence[str]] = None,
             groups_prefix: Optional[str] = None,
             required_claims: Optional[Sequence[str]] = None,
             username_claim: Optional[str] = None,
             username_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'issuerUrl' in kwargs:
            issuer_url = kwargs['issuerUrl']
        if 'groupsClaims' in kwargs:
            groups_claims = kwargs['groupsClaims']
        if 'groupsPrefix' in kwargs:
            groups_prefix = kwargs['groupsPrefix']
        if 'requiredClaims' in kwargs:
            required_claims = kwargs['requiredClaims']
        if 'usernameClaim' in kwargs:
            username_claim = kwargs['usernameClaim']
        if 'usernamePrefix' in kwargs:
            username_prefix = kwargs['usernamePrefix']

        _setter("client_id", client_id)
        _setter("issuer_url", issuer_url)
        if groups_claims is not None:
            _setter("groups_claims", groups_claims)
        if groups_prefix is not None:
            _setter("groups_prefix", groups_prefix)
        if required_claims is not None:
            _setter("required_claims", required_claims)
        if username_claim is not None:
            _setter("username_claim", username_claim)
        if username_prefix is not None:
            _setter("username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        A client id that all tokens must be issued for
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        URL of the provider which allows the API server to discover public signing keys
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Optional[Sequence[str]]:
        """
        JWT claim to use as the user's group
        """
        return pulumi.get(self, "groups_claims")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[str]:
        """
        Prefix prepended to group claims
        """
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Optional[Sequence[str]]:
        """
        Multiple key=value pairs that describes a required claim in the ID Token
        """
        return pulumi.get(self, "required_claims")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[str]:
        """
        JWT claim to use as the user name
        """
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[str]:
        """
        Prefix prepended to username
        """
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class K8sPoolNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicIp":
            suggest = "public_ip"
        elif key == "publicIpV6":
            suggest = "public_ip_v6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sPoolNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sPoolNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sPoolNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 public_ip: Optional[str] = None,
                 public_ip_v6: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str name: The name for the pool.
               > **Important:** Updates to this field will recreate a new resource.
        :param str public_ip: The public IPv4.
        :param str public_ip_v6: The public IPv6.
        :param str status: The status of the node.
        """
        K8sPoolNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            public_ip=public_ip,
            public_ip_v6=public_ip_v6,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             public_ip: Optional[str] = None,
             public_ip_v6: Optional[str] = None,
             status: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if 'publicIpV6' in kwargs:
            public_ip_v6 = kwargs['publicIpV6']

        if name is not None:
            _setter("name", name)
        if public_ip is not None:
            _setter("public_ip", public_ip)
        if public_ip_v6 is not None:
            _setter("public_ip_v6", public_ip_v6)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name for the pool.
        > **Important:** Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[str]:
        """
        The public IPv4.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIpV6")
    def public_ip_v6(self) -> Optional[str]:
        """
        The public IPv6.
        """
        return pulumi.get(self, "public_ip_v6")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        The status of the node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class K8sPoolUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurge":
            suggest = "max_surge"
        elif key == "maxUnavailable":
            suggest = "max_unavailable"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in K8sPoolUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        K8sPoolUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        K8sPoolUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge: Optional[int] = None,
                 max_unavailable: Optional[int] = None):
        """
        :param int max_surge: The maximum number of nodes to be created during the upgrade
        :param int max_unavailable: The maximum number of nodes that can be not ready at the same time
        """
        K8sPoolUpgradePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_surge=max_surge,
            max_unavailable=max_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_surge: Optional[int] = None,
             max_unavailable: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSurge' in kwargs:
            max_surge = kwargs['maxSurge']
        if 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']

        if max_surge is not None:
            _setter("max_surge", max_surge)
        if max_unavailable is not None:
            _setter("max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[int]:
        """
        The maximum number of nodes to be created during the upgrade
        """
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[int]:
        """
        The maximum number of nodes that can be not ready at the same time
        """
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class LbAclAction(dict):
    def __init__(__self__, *,
                 type: str,
                 redirects: Optional[Sequence['outputs.LbAclActionRedirect']] = None):
        """
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        :param Sequence['LbAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        LbAclAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            redirects=redirects,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             redirects: Optional[Sequence['outputs.LbAclActionRedirect']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        if redirects is not None:
            _setter("redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.LbAclActionRedirect']]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class LbAclActionRedirect(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param str target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        """
        LbAclActionRedirect._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[int] = None,
             target: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if target is not None:
            _setter("target", target)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LbAclMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFilter":
            suggest = "http_filter"
        elif key == "httpFilterOption":
            suggest = "http_filter_option"
        elif key == "httpFilterValues":
            suggest = "http_filter_values"
        elif key == "ipSubnets":
            suggest = "ip_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbAclMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbAclMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbAclMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_filter: Optional[str] = None,
                 http_filter_option: Optional[str] = None,
                 http_filter_values: Optional[Sequence[str]] = None,
                 invert: Optional[bool] = None,
                 ip_subnets: Optional[Sequence[str]] = None):
        """
        :param str http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        :param bool invert: If set to `true`, the condition will be of type "unless".
        :param Sequence[str] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        LbAclMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_filter=http_filter,
            http_filter_option=http_filter_option,
            http_filter_values=http_filter_values,
            invert=invert,
            ip_subnets=ip_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_filter: Optional[str] = None,
             http_filter_option: Optional[str] = None,
             http_filter_values: Optional[Sequence[str]] = None,
             invert: Optional[bool] = None,
             ip_subnets: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpFilter' in kwargs:
            http_filter = kwargs['httpFilter']
        if 'httpFilterOption' in kwargs:
            http_filter_option = kwargs['httpFilterOption']
        if 'httpFilterValues' in kwargs:
            http_filter_values = kwargs['httpFilterValues']
        if 'ipSubnets' in kwargs:
            ip_subnets = kwargs['ipSubnets']

        if http_filter is not None:
            _setter("http_filter", http_filter)
        if http_filter_option is not None:
            _setter("http_filter_option", http_filter_option)
        if http_filter_values is not None:
            _setter("http_filter_values", http_filter_values)
        if invert is not None:
            _setter("invert", invert)
        if ip_subnets is not None:
            _setter("ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[str]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[str]:
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[Sequence[str]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[Sequence[str]]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class LbBackendHealthCheckHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbBackendHealthCheckHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbBackendHealthCheckHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbBackendHealthCheckHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 code: Optional[int] = None,
                 host_header: Optional[str] = None,
                 method: Optional[str] = None):
        """
        :param str uri: The HTTPS endpoint URL to call for HC requests.
        :param int code: The expected HTTP status code.
        :param str host_header: The HTTP host header to use for HC requests.
        :param str method: The HTTP method to use for HC requests.
        """
        LbBackendHealthCheckHttp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            code=code,
            host_header=host_header,
            method=method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: str,
             code: Optional[int] = None,
             host_header: Optional[str] = None,
             method: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostHeader' in kwargs:
            host_header = kwargs['hostHeader']

        _setter("uri", uri)
        if code is not None:
            _setter("code", code)
        if host_header is not None:
            _setter("host_header", host_header)
        if method is not None:
            _setter("method", method)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")


@pulumi.output_type
class LbBackendHealthCheckHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostHeader":
            suggest = "host_header"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbBackendHealthCheckHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbBackendHealthCheckHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbBackendHealthCheckHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 code: Optional[int] = None,
                 host_header: Optional[str] = None,
                 method: Optional[str] = None,
                 sni: Optional[str] = None):
        """
        :param str uri: The HTTPS endpoint URL to call for HC requests.
        :param int code: The expected HTTP status code.
        :param str host_header: The HTTP host header to use for HC requests.
        :param str method: The HTTP method to use for HC requests.
        :param str sni: The SNI to use for HC requests over SSL.
        """
        LbBackendHealthCheckHttps._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            code=code,
            host_header=host_header,
            method=method,
            sni=sni,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: str,
             code: Optional[int] = None,
             host_header: Optional[str] = None,
             method: Optional[str] = None,
             sni: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostHeader' in kwargs:
            host_header = kwargs['hostHeader']

        _setter("uri", uri)
        if code is not None:
            _setter("code", code)
        if host_header is not None:
            _setter("host_header", host_header)
        if method is not None:
            _setter("method", method)
        if sni is not None:
            _setter("sni", sni)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[str]:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        The SNI to use for HC requests over SSL.
        """
        return pulumi.get(self, "sni")


@pulumi.output_type
class LbBackendHealthCheckTcp(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        pass



@pulumi.output_type
class LbCertificateCustomCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateChain":
            suggest = "certificate_chain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbCertificateCustomCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbCertificateCustomCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbCertificateCustomCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_chain: str):
        """
        :param str certificate_chain: Full PEM-formatted certificate chain.
               
               > **Important:** Updates to `custom_certificate` will recreate the load-balancer certificate.
        """
        LbCertificateCustomCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        """
        Full PEM-formatted certificate chain.

        > **Important:** Updates to `custom_certificate` will recreate the load-balancer certificate.
        """
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class LbCertificateLetsencrypt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonName":
            suggest = "common_name"
        elif key == "subjectAlternativeNames":
            suggest = "subject_alternative_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbCertificateLetsencrypt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbCertificateLetsencrypt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbCertificateLetsencrypt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_name: str,
                 subject_alternative_names: Optional[Sequence[str]] = None):
        """
        :param str common_name: Main domain of the certificate. A new certificate will be created if this field is changed.
        :param Sequence[str] subject_alternative_names: Array of alternative domain names.  A new certificate will be created if this field is changed.
               
               > **Important:** Updates to `letsencrypt` will recreate the load-balancer certificate.
        """
        LbCertificateLetsencrypt._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            common_name=common_name,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             common_name: str,
             subject_alternative_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'commonName' in kwargs:
            common_name = kwargs['commonName']
        if 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("common_name", common_name)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        """
        Main domain of the certificate. A new certificate will be created if this field is changed.
        """
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[Sequence[str]]:
        """
        Array of alternative domain names.  A new certificate will be created if this field is changed.

        > **Important:** Updates to `letsencrypt` will recreate the load-balancer certificate.
        """
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class LbFrontendAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbFrontendAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbFrontendAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbFrontendAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: 'outputs.LbFrontendAclAction',
                 match: 'outputs.LbFrontendAclMatch',
                 created_at: Optional[str] = None,
                 description: Optional[str] = None,
                 name: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param 'LbFrontendAclActionArgs' action: Action to undertake when an ACL filter matches.
        :param 'LbFrontendAclMatchArgs' match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        :param str name: The ACL name. If not provided it will be randomly generated.
        """
        LbFrontendAcl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
            created_at=created_at,
            description=description,
            name=name,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: 'outputs.LbFrontendAclAction',
             match: 'outputs.LbFrontendAclMatch',
             created_at: Optional[str] = None,
             description: Optional[str] = None,
             name: Optional[str] = None,
             updated_at: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("action", action)
        _setter("match", match)
        if created_at is not None:
            _setter("created_at", created_at)
        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if updated_at is not None:
            _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def action(self) -> 'outputs.LbFrontendAclAction':
        """
        Action to undertake when an ACL filter matches.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def match(self) -> 'outputs.LbFrontendAclMatch':
        """
        The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The ACL name. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class LbFrontendAclAction(dict):
    def __init__(__self__, *,
                 type: str,
                 redirects: Optional[Sequence['outputs.LbFrontendAclActionRedirect']] = None):
        """
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        :param Sequence['LbFrontendAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        LbFrontendAclAction._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            redirects=redirects,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             redirects: Optional[Sequence['outputs.LbFrontendAclActionRedirect']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        if redirects is not None:
            _setter("redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def redirects(self) -> Optional[Sequence['outputs.LbFrontendAclActionRedirect']]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")


@pulumi.output_type
class LbFrontendAclActionRedirect(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 target: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param int code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param str target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param str type: The redirect type. Possible values are: `location` or `scheme`.
        """
        LbFrontendAclActionRedirect._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[int] = None,
             target: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if target is not None:
            _setter("target", target)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LbFrontendAclMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpFilter":
            suggest = "http_filter"
        elif key == "httpFilterOption":
            suggest = "http_filter_option"
        elif key == "httpFilterValues":
            suggest = "http_filter_values"
        elif key == "ipSubnets":
            suggest = "ip_subnets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbFrontendAclMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbFrontendAclMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbFrontendAclMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_filter: Optional[str] = None,
                 http_filter_option: Optional[str] = None,
                 http_filter_values: Optional[Sequence[str]] = None,
                 invert: Optional[bool] = None,
                 ip_subnets: Optional[Sequence[str]] = None):
        """
        :param str http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param Sequence[str] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        :param bool invert: If set to `true`, the condition will be of type "unless".
        :param Sequence[str] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        LbFrontendAclMatch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_filter=http_filter,
            http_filter_option=http_filter_option,
            http_filter_values=http_filter_values,
            invert=invert,
            ip_subnets=ip_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_filter: Optional[str] = None,
             http_filter_option: Optional[str] = None,
             http_filter_values: Optional[Sequence[str]] = None,
             invert: Optional[bool] = None,
             ip_subnets: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpFilter' in kwargs:
            http_filter = kwargs['httpFilter']
        if 'httpFilterOption' in kwargs:
            http_filter_option = kwargs['httpFilterOption']
        if 'httpFilterValues' in kwargs:
            http_filter_values = kwargs['httpFilterValues']
        if 'ipSubnets' in kwargs:
            ip_subnets = kwargs['ipSubnets']

        if http_filter is not None:
            _setter("http_filter", http_filter)
        if http_filter_option is not None:
            _setter("http_filter_option", http_filter_option)
        if http_filter_values is not None:
            _setter("http_filter_values", http_filter_values)
        if invert is not None:
            _setter("invert", invert)
        if ip_subnets is not None:
            _setter("ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[str]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[str]:
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[Sequence[str]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[Sequence[str]]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class LbPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "dhcpConfig":
            suggest = "dhcp_config"
        elif key == "staticConfig":
            suggest = "static_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LbPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LbPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LbPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: str,
                 dhcp_config: Optional[bool] = None,
                 static_config: Optional[str] = None,
                 status: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str private_network_id: (Required) The ID of the Private Network to associate.
        :param bool dhcp_config: (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
        :param str static_config: (Optional) Define a local ip address of your choice for the load balancer instance. See below.
        :param str zone: `zone`) The zone of the load-balancer.
        """
        LbPrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_network_id=private_network_id,
            dhcp_config=dhcp_config,
            static_config=static_config,
            status=status,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_network_id: str,
             dhcp_config: Optional[bool] = None,
             static_config: Optional[str] = None,
             status: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'dhcpConfig' in kwargs:
            dhcp_config = kwargs['dhcpConfig']
        if 'staticConfig' in kwargs:
            static_config = kwargs['staticConfig']

        _setter("private_network_id", private_network_id)
        if dhcp_config is not None:
            _setter("dhcp_config", dhcp_config)
        if static_config is not None:
            _setter("static_config", static_config)
        if status is not None:
            _setter("status", status)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        (Required) The ID of the Private Network to associate.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="dhcpConfig")
    def dhcp_config(self) -> Optional[bool]:
        """
        (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
        """
        return pulumi.get(self, "dhcp_config")

    @property
    @pulumi.getter(name="staticConfig")
    def static_config(self) -> Optional[str]:
        """
        (Optional) Define a local ip address of your choice for the load balancer instance. See below.
        """
        return pulumi.get(self, "static_config")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone of the load-balancer.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class MnqCredentialNatsCredentials(dict):
    def __init__(__self__, *,
                 content: Optional[str] = None):
        """
        :param str content: Raw content of the NATS credentials file.
        """
        MnqCredentialNatsCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if content is not None:
            _setter("content", content)

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Raw content of the NATS credentials file.
        """
        return pulumi.get(self, "content")


@pulumi.output_type
class MnqCredentialSqsSnsCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqCredentialSqsSnsCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqCredentialSqsSnsCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqCredentialSqsSnsCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 permissions: Optional['outputs.MnqCredentialSqsSnsCredentialsPermissions'] = None,
                 secret_key: Optional[str] = None):
        """
        :param str access_key: The ID of the key.
        :param 'MnqCredentialSqsSnsCredentialsPermissionsArgs' permissions: List of permissions associated to this Credential. Only one of permissions may be set.
        :param str secret_key: The Secret value of the key.
        """
        MnqCredentialSqsSnsCredentials._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            permissions=permissions,
            secret_key=secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[str] = None,
             permissions: Optional['outputs.MnqCredentialSqsSnsCredentialsPermissions'] = None,
             secret_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']

        if access_key is not None:
            _setter("access_key", access_key)
        if permissions is not None:
            _setter("permissions", permissions)
        if secret_key is not None:
            _setter("secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        The ID of the key.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def permissions(self) -> Optional['outputs.MnqCredentialSqsSnsCredentialsPermissions']:
        """
        List of permissions associated to this Credential. Only one of permissions may be set.
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        The Secret value of the key.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class MnqCredentialSqsSnsCredentialsPermissions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canManage":
            suggest = "can_manage"
        elif key == "canPublish":
            suggest = "can_publish"
        elif key == "canReceive":
            suggest = "can_receive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqCredentialSqsSnsCredentialsPermissions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqCredentialSqsSnsCredentialsPermissions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqCredentialSqsSnsCredentialsPermissions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_manage: Optional[bool] = None,
                 can_publish: Optional[bool] = None,
                 can_receive: Optional[bool] = None):
        """
        :param bool can_manage: . Defines if user can manage the associated resource(s).
        :param bool can_publish: . Defines if user can publish messages to the service.
        :param bool can_receive: . Defines if user can receive messages from the service.
        """
        MnqCredentialSqsSnsCredentialsPermissions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_manage=can_manage,
            can_publish=can_publish,
            can_receive=can_receive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_manage: Optional[bool] = None,
             can_publish: Optional[bool] = None,
             can_receive: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'canManage' in kwargs:
            can_manage = kwargs['canManage']
        if 'canPublish' in kwargs:
            can_publish = kwargs['canPublish']
        if 'canReceive' in kwargs:
            can_receive = kwargs['canReceive']

        if can_manage is not None:
            _setter("can_manage", can_manage)
        if can_publish is not None:
            _setter("can_publish", can_publish)
        if can_receive is not None:
            _setter("can_receive", can_receive)

    @property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[bool]:
        """
        . Defines if user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[bool]:
        """
        . Defines if user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[bool]:
        """
        . Defines if user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")


@pulumi.output_type
class MnqQueueNats(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqQueueNats. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqQueueNats.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqQueueNats.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 endpoint: Optional[str] = None,
                 retention_policy: Optional[str] = None):
        MnqQueueNats._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            endpoint=endpoint,
            retention_policy=retention_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             endpoint: Optional[str] = None,
             retention_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'retentionPolicy' in kwargs:
            retention_policy = kwargs['retentionPolicy']

        _setter("credentials", credentials)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if retention_policy is not None:
            _setter("retention_policy", retention_policy)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional[str]:
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class MnqQueueSqs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "contentBasedDeduplication":
            suggest = "content_based_deduplication"
        elif key == "fifoQueue":
            suggest = "fifo_queue"
        elif key == "receiveWaitTimeSeconds":
            suggest = "receive_wait_time_seconds"
        elif key == "visibilityTimeoutSeconds":
            suggest = "visibility_timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqQueueSqs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqQueueSqs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqQueueSqs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 secret_key: str,
                 content_based_deduplication: Optional[bool] = None,
                 endpoint: Optional[str] = None,
                 fifo_queue: Optional[bool] = None,
                 receive_wait_time_seconds: Optional[int] = None,
                 url: Optional[str] = None,
                 visibility_timeout_seconds: Optional[int] = None):
        MnqQueueSqs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            secret_key=secret_key,
            content_based_deduplication=content_based_deduplication,
            endpoint=endpoint,
            fifo_queue=fifo_queue,
            receive_wait_time_seconds=receive_wait_time_seconds,
            url=url,
            visibility_timeout_seconds=visibility_timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             secret_key: str,
             content_based_deduplication: Optional[bool] = None,
             endpoint: Optional[str] = None,
             fifo_queue: Optional[bool] = None,
             receive_wait_time_seconds: Optional[int] = None,
             url: Optional[str] = None,
             visibility_timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'contentBasedDeduplication' in kwargs:
            content_based_deduplication = kwargs['contentBasedDeduplication']
        if 'fifoQueue' in kwargs:
            fifo_queue = kwargs['fifoQueue']
        if 'receiveWaitTimeSeconds' in kwargs:
            receive_wait_time_seconds = kwargs['receiveWaitTimeSeconds']
        if 'visibilityTimeoutSeconds' in kwargs:
            visibility_timeout_seconds = kwargs['visibilityTimeoutSeconds']

        _setter("access_key", access_key)
        _setter("secret_key", secret_key)
        if content_based_deduplication is not None:
            _setter("content_based_deduplication", content_based_deduplication)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if fifo_queue is not None:
            _setter("fifo_queue", fifo_queue)
        if receive_wait_time_seconds is not None:
            _setter("receive_wait_time_seconds", receive_wait_time_seconds)
        if url is not None:
            _setter("url", url)
        if visibility_timeout_seconds is not None:
            _setter("visibility_timeout_seconds", visibility_timeout_seconds)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="contentBasedDeduplication")
    def content_based_deduplication(self) -> Optional[bool]:
        return pulumi.get(self, "content_based_deduplication")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="fifoQueue")
    def fifo_queue(self) -> Optional[bool]:
        return pulumi.get(self, "fifo_queue")

    @property
    @pulumi.getter(name="receiveWaitTimeSeconds")
    def receive_wait_time_seconds(self) -> Optional[int]:
        return pulumi.get(self, "receive_wait_time_seconds")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="visibilityTimeoutSeconds")
    def visibility_timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "visibility_timeout_seconds")


@pulumi.output_type
class MnqSqsCredentialsPermissions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canManage":
            suggest = "can_manage"
        elif key == "canPublish":
            suggest = "can_publish"
        elif key == "canReceive":
            suggest = "can_receive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MnqSqsCredentialsPermissions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MnqSqsCredentialsPermissions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MnqSqsCredentialsPermissions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 can_manage: Optional[bool] = None,
                 can_publish: Optional[bool] = None,
                 can_receive: Optional[bool] = None):
        """
        :param bool can_manage: . Defines if user can manage the associated resource(s).
        :param bool can_publish: . Defines if user can publish messages to the service.
        :param bool can_receive: . Defines if user can receive messages from the service.
        """
        MnqSqsCredentialsPermissions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_manage=can_manage,
            can_publish=can_publish,
            can_receive=can_receive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_manage: Optional[bool] = None,
             can_publish: Optional[bool] = None,
             can_receive: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'canManage' in kwargs:
            can_manage = kwargs['canManage']
        if 'canPublish' in kwargs:
            can_publish = kwargs['canPublish']
        if 'canReceive' in kwargs:
            can_receive = kwargs['canReceive']

        if can_manage is not None:
            _setter("can_manage", can_manage)
        if can_publish is not None:
            _setter("can_publish", can_publish)
        if can_receive is not None:
            _setter("can_receive", can_receive)

    @property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[bool]:
        """
        . Defines if user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[bool]:
        """
        . Defines if user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[bool]:
        """
        . Defines if user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicy(dict):
    def __init__(__self__, *,
                 owner: 'outputs.ObjectBucketAclAccessControlPolicyOwner',
                 grants: Optional[Sequence['outputs.ObjectBucketAclAccessControlPolicyGrant']] = None):
        ObjectBucketAclAccessControlPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            owner=owner,
            grants=grants,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             owner: 'outputs.ObjectBucketAclAccessControlPolicyOwner',
             grants: Optional[Sequence['outputs.ObjectBucketAclAccessControlPolicyGrant']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("owner", owner)
        if grants is not None:
            _setter("grants", grants)

    @property
    @pulumi.getter
    def owner(self) -> 'outputs.ObjectBucketAclAccessControlPolicyOwner':
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter
    def grants(self) -> Optional[Sequence['outputs.ObjectBucketAclAccessControlPolicyGrant']]:
        return pulumi.get(self, "grants")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicyGrant(dict):
    def __init__(__self__, *,
                 permission: str,
                 grantee: Optional['outputs.ObjectBucketAclAccessControlPolicyGrantGrantee'] = None):
        ObjectBucketAclAccessControlPolicyGrant._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permission=permission,
            grantee=grantee,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permission: str,
             grantee: Optional['outputs.ObjectBucketAclAccessControlPolicyGrantGrantee'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("permission", permission)
        if grantee is not None:
            _setter("grantee", grantee)

    @property
    @pulumi.getter
    def permission(self) -> str:
        return pulumi.get(self, "permission")

    @property
    @pulumi.getter
    def grantee(self) -> Optional['outputs.ObjectBucketAclAccessControlPolicyGrantGrantee']:
        return pulumi.get(self, "grantee")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicyGrantGrantee(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketAclAccessControlPolicyGrantGrantee. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketAclAccessControlPolicyGrantGrantee.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketAclAccessControlPolicyGrantGrantee.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 type: str,
                 display_name: Optional[str] = None):
        """
        :param str id: The `region`,`bucket` and `acl` separated by (`/`).
        """
        ObjectBucketAclAccessControlPolicyGrantGrantee._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             type: str,
             display_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']

        _setter("id", id)
        _setter("type", type)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The `region`,`bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ObjectBucketAclAccessControlPolicyOwner(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketAclAccessControlPolicyOwner. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketAclAccessControlPolicyOwner.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketAclAccessControlPolicyOwner.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 display_name: Optional[str] = None):
        """
        :param str id: The `region`,`bucket` and `acl` separated by (`/`).
        """
        ObjectBucketAclAccessControlPolicyOwner._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             display_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']

        _setter("id", id)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The `region`,`bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ObjectBucketCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 allowed_headers: Optional[Sequence[str]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age_seconds: Optional[int] = None):
        """
        :param Sequence[str] allowed_methods: Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param Sequence[str] allowed_origins: Specifies which origins are allowed.
        :param Sequence[str] allowed_headers: Specifies which headers are allowed.
        :param Sequence[str] expose_headers: Specifies expose header in the response.
        :param int max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        ObjectBucketCorsRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_methods=allowed_methods,
            allowed_origins=allowed_origins,
            allowed_headers=allowed_headers,
            expose_headers=expose_headers,
            max_age_seconds=max_age_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_methods: Sequence[str],
             allowed_origins: Sequence[str],
             allowed_headers: Optional[Sequence[str]] = None,
             expose_headers: Optional[Sequence[str]] = None,
             max_age_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedMethods' in kwargs:
            allowed_methods = kwargs['allowedMethods']
        if 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if 'allowedHeaders' in kwargs:
            allowed_headers = kwargs['allowedHeaders']
        if 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if 'maxAgeSeconds' in kwargs:
            max_age_seconds = kwargs['maxAgeSeconds']

        _setter("allowed_methods", allowed_methods)
        _setter("allowed_origins", allowed_origins)
        if allowed_headers is not None:
            _setter("allowed_headers", allowed_headers)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age_seconds is not None:
            _setter("max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        """
        Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        """
        Specifies expose header in the response.
        """
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[int]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class ObjectBucketLifecycleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUploadDays":
            suggest = "abort_incomplete_multipart_upload_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketLifecycleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketLifecycleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketLifecycleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 abort_incomplete_multipart_upload_days: Optional[int] = None,
                 expiration: Optional['outputs.ObjectBucketLifecycleRuleExpiration'] = None,
                 id: Optional[str] = None,
                 prefix: Optional[str] = None,
                 tags: Optional[Mapping[str, str]] = None,
                 transitions: Optional[Sequence['outputs.ObjectBucketLifecycleRuleTransition']] = None):
        """
        :param bool enabled: The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway S3 doesn't perform any of the actions defined in the rule.
        :param int abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
               
               * > **Important:** It's not recommended using `prefix` for `AbortIncompleteMultipartUpload` as any incomplete multipart upload will be billed
        :param 'ObjectBucketLifecycleRuleExpirationArgs' expiration: Specifies a period in the object's expire (documented below).
        :param str id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param str prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param Mapping[str, str] tags: Specifies object tags key and value.
        :param Sequence['ObjectBucketLifecycleRuleTransitionArgs'] transitions: Specifies a period in the object's transitions (documented below).
               
               At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition` must be specified.
        """
        ObjectBucketLifecycleRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            abort_incomplete_multipart_upload_days=abort_incomplete_multipart_upload_days,
            expiration=expiration,
            id=id,
            prefix=prefix,
            tags=tags,
            transitions=transitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             abort_incomplete_multipart_upload_days: Optional[int] = None,
             expiration: Optional['outputs.ObjectBucketLifecycleRuleExpiration'] = None,
             id: Optional[str] = None,
             prefix: Optional[str] = None,
             tags: Optional[Mapping[str, str]] = None,
             transitions: Optional[Sequence['outputs.ObjectBucketLifecycleRuleTransition']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'abortIncompleteMultipartUploadDays' in kwargs:
            abort_incomplete_multipart_upload_days = kwargs['abortIncompleteMultipartUploadDays']

        _setter("enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            _setter("abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            _setter("expiration", expiration)
        if id is not None:
            _setter("id", id)
        if prefix is not None:
            _setter("prefix", prefix)
        if tags is not None:
            _setter("tags", tags)
        if transitions is not None:
            _setter("transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway S3 doesn't perform any of the actions defined in the rule.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[int]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.

        * > **Important:** It's not recommended using `prefix` for `AbortIncompleteMultipartUpload` as any incomplete multipart upload will be billed
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.ObjectBucketLifecycleRuleExpiration']:
        """
        Specifies a period in the object's expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Mapping[str, str]]:
        """
        Specifies object tags key and value.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def transitions(self) -> Optional[Sequence['outputs.ObjectBucketLifecycleRuleTransition']]:
        """
        Specifies a period in the object's transitions (documented below).

        At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition` must be specified.
        """
        return pulumi.get(self, "transitions")


@pulumi.output_type
class ObjectBucketLifecycleRuleExpiration(dict):
    def __init__(__self__, *,
                 days: int):
        """
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect.
               
               > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        """
        ObjectBucketLifecycleRuleExpiration._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("days", days)

    @property
    @pulumi.getter
    def days(self) -> int:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.

        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class ObjectBucketLifecycleRuleTransition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketLifecycleRuleTransition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketLifecycleRuleTransition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketLifecycleRuleTransition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 storage_class: str,
                 days: Optional[int] = None):
        """
        :param str storage_class: Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
               
               > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        :param int days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        ObjectBucketLifecycleRuleTransition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_class=storage_class,
            days=days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_class: str,
             days: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'storageClass' in kwargs:
            storage_class = kwargs['storageClass']

        _setter("storage_class", storage_class)
        if days is not None:
            _setter("days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.

        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        """
        return pulumi.get(self, "storage_class")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class ObjectBucketLockConfigurationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultRetention":
            suggest = "default_retention"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ObjectBucketLockConfigurationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ObjectBucketLockConfigurationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ObjectBucketLockConfigurationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_retention: 'outputs.ObjectBucketLockConfigurationRuleDefaultRetention'):
        ObjectBucketLockConfigurationRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_retention=default_retention,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_retention: 'outputs.ObjectBucketLockConfigurationRuleDefaultRetention',
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'defaultRetention' in kwargs:
            default_retention = kwargs['defaultRetention']

        _setter("default_retention", default_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> 'outputs.ObjectBucketLockConfigurationRuleDefaultRetention':
        return pulumi.get(self, "default_retention")


@pulumi.output_type
class ObjectBucketLockConfigurationRuleDefaultRetention(dict):
    def __init__(__self__, *,
                 mode: str,
                 days: Optional[int] = None,
                 years: Optional[int] = None):
        ObjectBucketLockConfigurationRuleDefaultRetention._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            days=days,
            years=years,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: str,
             days: Optional[int] = None,
             years: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("mode", mode)
        if days is not None:
            _setter("days", days)
        if years is not None:
            _setter("years", years)

    @property
    @pulumi.getter
    def mode(self) -> str:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def days(self) -> Optional[int]:
        return pulumi.get(self, "days")

    @property
    @pulumi.getter
    def years(self) -> Optional[int]:
        return pulumi.get(self, "years")


@pulumi.output_type
class ObjectBucketVersioning(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        ObjectBucketVersioning._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ObjectBucketWebsiteConfigurationErrorDocument(dict):
    def __init__(__self__, *,
                 key: str):
        ObjectBucketWebsiteConfigurationErrorDocument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")


@pulumi.output_type
class ObjectBucketWebsiteConfigurationIndexDocument(dict):
    def __init__(__self__, *,
                 suffix: str):
        ObjectBucketWebsiteConfigurationIndexDocument._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             suffix: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def suffix(self) -> str:
        return pulumi.get(self, "suffix")


@pulumi.output_type
class RdbAclAclRule(dict):
    def __init__(__self__, *,
                 ip: str,
                 description: Optional[str] = None):
        """
        :param str ip: The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param str description: A text describing this rule. Default description: `IP allowed`
        """
        RdbAclAclRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A text describing this rule. Default description: `IP allowed`
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class RdbInstanceLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdbInstanceLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdbInstanceLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdbInstanceLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str endpoint_id: The ID of the endpoint.
        :param str hostname: Hostname of the endpoint.
        :param str ip: IPv4 address on the network.
        :param str name: The name of the Database Instance.
        :param int port: Port in the Private Network.
        """
        RdbInstanceLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RdbInstancePrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pnId":
            suggest = "pn_id"
        elif key == "endpointId":
            suggest = "endpoint_id"
        elif key == "ipNet":
            suggest = "ip_net"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdbInstancePrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdbInstancePrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdbInstancePrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pn_id: str,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 ip_net: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 zone: Optional[str] = None):
        """
        :param str endpoint_id: The ID of the endpoint.
        :param str hostname: Hostname of the endpoint.
        :param str ip: IPv4 address on the network.
        :param str name: The name of the Database Instance.
        :param int port: Port in the Private Network.
        """
        RdbInstancePrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pn_id=pn_id,
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            ip_net=ip_net,
            name=name,
            port=port,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pn_id: str,
             endpoint_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             ip_net: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pnId' in kwargs:
            pn_id = kwargs['pnId']
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'ipNet' in kwargs:
            ip_net = kwargs['ipNet']

        _setter("pn_id", pn_id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if ip_net is not None:
            _setter("ip_net", ip_net)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipNet")
    def ip_net(self) -> Optional[str]:
        return pulumi.get(self, "ip_net")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class RdbInstanceReadReplica(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str ip: IPv4 address on the network.
        :param str name: The name of the Database Instance.
        :param int port: Port in the Private Network.
        """
        RdbInstanceReadReplica._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RdbReadReplicaDirectAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdbReadReplicaDirectAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdbReadReplicaDirectAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdbReadReplicaDirectAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None):
        """
        :param str endpoint_id: The ID of the endpoint of the read replica.
        :param str hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param str ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param str name: Name of the endpoint.
        :param int port: TCP port of the endpoint.
        """
        RdbReadReplicaDirectAccess._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class RdbReadReplicaPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "endpointId":
            suggest = "endpoint_id"
        elif key == "serviceIp":
            suggest = "service_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RdbReadReplicaPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RdbReadReplicaPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RdbReadReplicaPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_network_id: str,
                 endpoint_id: Optional[str] = None,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 service_ip: Optional[str] = None,
                 zone: Optional[str] = None):
        """
        :param str private_network_id: UUID of the private network to be connected to the read replica.
        :param str endpoint_id: The ID of the endpoint of the read replica.
        :param str hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param str ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param str name: Name of the endpoint.
        :param int port: TCP port of the endpoint.
        :param str service_ip: The IP network address within the private subnet. This must be an IPv4 address with a
               CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
               service if not set.
        """
        RdbReadReplicaPrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_network_id=private_network_id,
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
            service_ip=service_ip,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_network_id: str,
             endpoint_id: Optional[str] = None,
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             name: Optional[str] = None,
             port: Optional[int] = None,
             service_ip: Optional[str] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIp' in kwargs:
            service_ip = kwargs['serviceIp']

        _setter("private_network_id", private_network_id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)
        if service_ip is not None:
            _setter("service_ip", service_ip)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        """
        UUID of the private network to be connected to the read replica.
        """
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> Optional[str]:
        """
        The IP network address within the private subnet. This must be an IPv4 address with a
        CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
        service if not set.
        """
        return pulumi.get(self, "service_ip")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        return pulumi.get(self, "zone")


@pulumi.output_type
class RedisClusterAcl(dict):
    def __init__(__self__, *,
                 ip: str,
                 description: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str ip: The ip range to whitelist
               in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param str description: A text describing this rule. Default description: `Allow IP`
               
               > The `acl` conflict with `private_network`. Only one should be specified.
        :param str id: The UUID of the private network resource.
        """
        RedisClusterAcl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            description=description,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             description: Optional[str] = None,
             id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        if description is not None:
            _setter("description", description)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip range to whitelist
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A text describing this rule. Default description: `Allow IP`

        > The `acl` conflict with `private_network`. Only one should be specified.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The UUID of the private network resource.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class RedisClusterPrivateNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointId":
            suggest = "endpoint_id"
        elif key == "serviceIps":
            suggest = "service_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RedisClusterPrivateNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RedisClusterPrivateNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RedisClusterPrivateNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 endpoint_id: Optional[str] = None,
                 service_ips: Optional[Sequence[str]] = None,
                 zone: Optional[str] = None):
        """
        :param str id: The UUID of the private network resource.
        :param str endpoint_id: The ID of the endpoint.
        :param Sequence[str] service_ips: Endpoint IPv4 addresses
               in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at
               least one IP per node or The IP network address within the private subnet is determined by the IP Address Management (IPAM)
               service if not set.
               
               > The `private_network` conflict with `acl`. Only one should be specified.
        :param str zone: `zone`) The zone in which the
               Redis Cluster should be created.
        """
        RedisClusterPrivateNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            endpoint_id=endpoint_id,
            service_ips=service_ips,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             endpoint_id: Optional[str] = None,
             service_ips: Optional[Sequence[str]] = None,
             zone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIps' in kwargs:
            service_ips = kwargs['serviceIps']

        _setter("id", id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if service_ips is not None:
            _setter("service_ips", service_ips)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The UUID of the private network resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[str]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Optional[Sequence[str]]:
        """
        Endpoint IPv4 addresses
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at
        least one IP per node or The IP network address within the private subnet is determined by the IP Address Management (IPAM)
        service if not set.

        > The `private_network` conflict with `acl`. Only one should be specified.
        """
        return pulumi.get(self, "service_ips")

    @property
    @pulumi.getter
    def zone(self) -> Optional[str]:
        """
        `zone`) The zone in which the
        Redis Cluster should be created.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class RedisClusterPublicNetwork(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 port: Optional[int] = None):
        """
        :param str id: The UUID of the private network resource.
        :param Sequence[str] ips: Lis of IPv4 address of the endpoint (IP address).
        :param int port: TCP port of the endpoint.
        """
        RedisClusterPublicNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ips=ips,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             ips: Optional[Sequence[str]] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if ips is not None:
            _setter("ips", ips)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The UUID of the private network resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        """
        Lis of IPv4 address of the endpoint (IP address).
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class VpcGatewayNetworkIpamConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pushDefaultRoute":
            suggest = "push_default_route"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcGatewayNetworkIpamConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcGatewayNetworkIpamConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcGatewayNetworkIpamConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 push_default_route: Optional[bool] = None):
        """
        :param bool push_default_route: Defines whether the default route is enabled on that Gateway Network. Only one of `dhcp_id`, `static_address` and `ipam_config` should be specified.
        """
        VpcGatewayNetworkIpamConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            push_default_route=push_default_route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             push_default_route: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pushDefaultRoute' in kwargs:
            push_default_route = kwargs['pushDefaultRoute']

        if push_default_route is not None:
            _setter("push_default_route", push_default_route)

    @property
    @pulumi.getter(name="pushDefaultRoute")
    def push_default_route(self) -> Optional[bool]:
        """
        Defines whether the default route is enabled on that Gateway Network. Only one of `dhcp_id`, `static_address` and `ipam_config` should be specified.
        """
        return pulumi.get(self, "push_default_route")


@pulumi.output_type
class VpcPrivateNetworkIpv4Subnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "prefixLength":
            suggest = "prefix_length"
        elif key == "subnetMask":
            suggest = "subnet_mask"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPrivateNetworkIpv4Subnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPrivateNetworkIpv4Subnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPrivateNetworkIpv4Subnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 created_at: Optional[str] = None,
                 id: Optional[str] = None,
                 prefix_length: Optional[int] = None,
                 subnet: Optional[str] = None,
                 subnet_mask: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param str address: The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        :param str created_at: The date and time of the creation of the subnet.
        :param str id: The subnet ID.
        :param int prefix_length: The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        :param str subnet: The subnet CIDR.
        :param str subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param str updated_at: The date and time of the last update of the subnet.
        """
        VpcPrivateNetworkIpv4Subnet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            created_at=created_at,
            id=id,
            prefix_length=prefix_length,
            subnet=subnet,
            subnet_mask=subnet_mask,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             created_at: Optional[str] = None,
             id: Optional[str] = None,
             prefix_length: Optional[int] = None,
             subnet: Optional[str] = None,
             subnet_mask: Optional[str] = None,
             updated_at: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'prefixLength' in kwargs:
            prefix_length = kwargs['prefixLength']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        if address is not None:
            _setter("address", address)
        if created_at is not None:
            _setter("created_at", created_at)
        if id is not None:
            _setter("id", id)
        if prefix_length is not None:
            _setter("prefix_length", prefix_length)
        if subnet is not None:
            _setter("subnet", subnet)
        if subnet_mask is not None:
            _setter("subnet_mask", subnet_mask)
        if updated_at is not None:
            _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[int]:
        """
        The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[str]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class VpcPrivateNetworkIpv6Subnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "prefixLength":
            suggest = "prefix_length"
        elif key == "subnetMask":
            suggest = "subnet_mask"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcPrivateNetworkIpv6Subnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcPrivateNetworkIpv6Subnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcPrivateNetworkIpv6Subnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 created_at: Optional[str] = None,
                 id: Optional[str] = None,
                 prefix_length: Optional[int] = None,
                 subnet: Optional[str] = None,
                 subnet_mask: Optional[str] = None,
                 updated_at: Optional[str] = None):
        """
        :param str address: The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        :param str created_at: The date and time of the creation of the subnet.
        :param str id: The subnet ID.
        :param int prefix_length: The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        :param str subnet: The subnet CIDR.
        :param str subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param str updated_at: The date and time of the last update of the subnet.
        """
        VpcPrivateNetworkIpv6Subnet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            created_at=created_at,
            id=id,
            prefix_length=prefix_length,
            subnet=subnet,
            subnet_mask=subnet_mask,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             created_at: Optional[str] = None,
             id: Optional[str] = None,
             prefix_length: Optional[int] = None,
             subnet: Optional[str] = None,
             subnet_mask: Optional[str] = None,
             updated_at: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'prefixLength' in kwargs:
            prefix_length = kwargs['prefixLength']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        if address is not None:
            _setter("address", address)
        if created_at is not None:
            _setter("created_at", created_at)
        if id is not None:
            _setter("id", id)
        if prefix_length is not None:
            _setter("prefix_length", prefix_length)
        if subnet is not None:
            _setter("subnet", subnet)
        if subnet_mask is not None:
            _setter("subnet_mask", subnet_mask)
        if updated_at is not None:
            _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[str]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[int]:
        """
        The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        """
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> Optional[str]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[str]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[str]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class WebHostingCpanelUrl(dict):
    def __init__(__self__, *,
                 dashboard: Optional[str] = None,
                 webmail: Optional[str] = None):
        """
        :param str dashboard: The URL of the Dashboard.
        :param str webmail: The URL of the Webmail interface.
        """
        WebHostingCpanelUrl._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard=dashboard,
            webmail=webmail,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard: Optional[str] = None,
             webmail: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dashboard is not None:
            _setter("dashboard", dashboard)
        if webmail is not None:
            _setter("webmail", webmail)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[str]:
        """
        The URL of the Dashboard.
        """
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter
    def webmail(self) -> Optional[str]:
        """
        The URL of the Webmail interface.
        """
        return pulumi.get(self, "webmail")


@pulumi.output_type
class WebHostingOption(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str id: The option ID.
        :param str name: The option name.
        """
        WebHostingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The option ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The option name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBaremetalOfferCpusResult(dict):
    def __init__(__self__, *,
                 core_count: int,
                 frequency: int,
                 name: str,
                 thread_count: int):
        """
        :param int core_count: Number of core on this CPU.
        :param int frequency: Frequency of the memory in MHz.
        :param str name: The offer name. Only one of `name` and `offer_id` should be specified.
        :param int thread_count: Number of thread on this CPU.
        """
        GetBaremetalOfferCpusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            core_count=core_count,
            frequency=frequency,
            name=name,
            thread_count=thread_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             core_count: int,
             frequency: int,
             name: str,
             thread_count: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'coreCount' in kwargs:
            core_count = kwargs['coreCount']
        if 'threadCount' in kwargs:
            thread_count = kwargs['threadCount']

        _setter("core_count", core_count)
        _setter("frequency", frequency)
        _setter("name", name)
        _setter("thread_count", thread_count)

    @property
    @pulumi.getter(name="coreCount")
    def core_count(self) -> int:
        """
        Number of core on this CPU.
        """
        return pulumi.get(self, "core_count")

    @property
    @pulumi.getter
    def frequency(self) -> int:
        """
        Frequency of the memory in MHz.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The offer name. Only one of `name` and `offer_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="threadCount")
    def thread_count(self) -> int:
        """
        Number of thread on this CPU.
        """
        return pulumi.get(self, "thread_count")


@pulumi.output_type
class GetBaremetalOfferDiskResult(dict):
    def __init__(__self__, *,
                 capacity: int,
                 type: str):
        """
        :param int capacity: Capacity of the memory in GB.
        :param str type: Type of memory.
        """
        GetBaremetalOfferDiskResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("capacity", capacity)
        _setter("type", type)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Capacity of the memory in GB.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of memory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBaremetalOfferMemoryResult(dict):
    def __init__(__self__, *,
                 capacity: int,
                 frequency: int,
                 is_ecc: bool,
                 type: str):
        """
        :param int capacity: Capacity of the memory in GB.
        :param int frequency: Frequency of the memory in MHz.
        :param bool is_ecc: True if error-correcting code is available on this memory.
        :param str type: Type of memory.
        """
        GetBaremetalOfferMemoryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            capacity=capacity,
            frequency=frequency,
            is_ecc=is_ecc,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             capacity: int,
             frequency: int,
             is_ecc: bool,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'isEcc' in kwargs:
            is_ecc = kwargs['isEcc']

        _setter("capacity", capacity)
        _setter("frequency", frequency)
        _setter("is_ecc", is_ecc)
        _setter("type", type)

    @property
    @pulumi.getter
    def capacity(self) -> int:
        """
        Capacity of the memory in GB.
        """
        return pulumi.get(self, "capacity")

    @property
    @pulumi.getter
    def frequency(self) -> int:
        """
        Frequency of the memory in MHz.
        """
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="isEcc")
    def is_ecc(self) -> bool:
        """
        True if error-correcting code is available on this memory.
        """
        return pulumi.get(self, "is_ecc")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of memory.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetBaremetalServerIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str,
                 reverse: str,
                 version: str):
        """
        :param str id: The ID of the server.
        """
        GetBaremetalServerIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             id: str,
             reverse: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("address", address)
        _setter("id", id)
        _setter("reverse", reverse)
        _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBaremetalServerIpv4Result(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str,
                 reverse: str,
                 version: str):
        """
        :param str id: The ID of the server.
        """
        GetBaremetalServerIpv4Result._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             id: str,
             reverse: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("address", address)
        _setter("id", id)
        _setter("reverse", reverse)
        _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBaremetalServerIpv6Result(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str,
                 reverse: str,
                 version: str):
        """
        :param str id: The ID of the server.
        """
        GetBaremetalServerIpv6Result._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             id: str,
             reverse: str,
             version: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("address", address)
        _setter("id", id)
        _setter("reverse", reverse)
        _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def version(self) -> str:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetBaremetalServerOptionResult(dict):
    def __init__(__self__, *,
                 expires_at: str,
                 id: str,
                 name: str):
        """
        :param str id: The ID of the server.
        :param str name: The server name. Only one of `name` and `server_id` should be specified.
        """
        GetBaremetalServerOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expires_at=expires_at,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expires_at: str,
             id: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'expiresAt' in kwargs:
            expires_at = kwargs['expiresAt']

        _setter("expires_at", expires_at)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> str:
        return pulumi.get(self, "expires_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The server name. Only one of `name` and `server_id` should be specified.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetBaremetalServerPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 status: str,
                 updated_at: str,
                 vlan: int):
        """
        :param str id: The ID of the server.
        """
        GetBaremetalServerPrivateNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            id=id,
            status=status,
            updated_at=updated_at,
            vlan=vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             id: str,
             status: str,
             updated_at: str,
             vlan: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("created_at", created_at)
        _setter("id", id)
        _setter("status", status)
        _setter("updated_at", updated_at)
        _setter("vlan", vlan)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the server.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def vlan(self) -> int:
        return pulumi.get(self, "vlan")


@pulumi.output_type
class GetBillingConsumptionsConsumptionResult(dict):
    def __init__(__self__, *,
                 category: str,
                 description: str,
                 operation_path: str,
                 project_id: str,
                 value: str):
        GetBillingConsumptionsConsumptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            description=description,
            operation_path=operation_path,
            project_id=project_id,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: str,
             description: str,
             operation_path: str,
             project_id: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'operationPath' in kwargs:
            operation_path = kwargs['operationPath']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("category", category)
        _setter("description", description)
        _setter("operation_path", operation_path)
        _setter("project_id", project_id)
        _setter("value", value)

    @property
    @pulumi.getter
    def category(self) -> str:
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="operationPath")
    def operation_path(self) -> str:
        return pulumi.get(self, "operation_path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetBillingInvoicesInvoiceResult(dict):
    def __init__(__self__, *,
                 due_date: str,
                 id: str,
                 invoice_type: str,
                 issued_date: str,
                 number: int,
                 start_date: str,
                 total_taxed: str,
                 total_untaxed: str):
        """
        :param str due_date: The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
        :param str id: The associated invoice ID.
        :param str invoice_type: Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
        :param str issued_date: The date when the invoice was sent to the customer (RFC 3339 format).
        :param int number: The invoice number.
        :param str start_date: The start date of the billing period (RFC 3339 format).
        :param str total_taxed: The total amount, taxed.
        :param str total_untaxed: The total amount, untaxed.
        """
        GetBillingInvoicesInvoiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            due_date=due_date,
            id=id,
            invoice_type=invoice_type,
            issued_date=issued_date,
            number=number,
            start_date=start_date,
            total_taxed=total_taxed,
            total_untaxed=total_untaxed,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             due_date: str,
             id: str,
             invoice_type: str,
             issued_date: str,
             number: int,
             start_date: str,
             total_taxed: str,
             total_untaxed: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dueDate' in kwargs:
            due_date = kwargs['dueDate']
        if 'invoiceType' in kwargs:
            invoice_type = kwargs['invoiceType']
        if 'issuedDate' in kwargs:
            issued_date = kwargs['issuedDate']
        if 'startDate' in kwargs:
            start_date = kwargs['startDate']
        if 'totalTaxed' in kwargs:
            total_taxed = kwargs['totalTaxed']
        if 'totalUntaxed' in kwargs:
            total_untaxed = kwargs['totalUntaxed']

        _setter("due_date", due_date)
        _setter("id", id)
        _setter("invoice_type", invoice_type)
        _setter("issued_date", issued_date)
        _setter("number", number)
        _setter("start_date", start_date)
        _setter("total_taxed", total_taxed)
        _setter("total_untaxed", total_untaxed)

    @property
    @pulumi.getter(name="dueDate")
    def due_date(self) -> str:
        """
        The payment time limit, set according to the Organization's payment conditions (RFC 3339 format).
        """
        return pulumi.get(self, "due_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated invoice ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="invoiceType")
    def invoice_type(self) -> str:
        """
        Invoices with the given type are listed. Valid values are `periodic` and `purchase`.
        """
        return pulumi.get(self, "invoice_type")

    @property
    @pulumi.getter(name="issuedDate")
    def issued_date(self) -> str:
        """
        The date when the invoice was sent to the customer (RFC 3339 format).
        """
        return pulumi.get(self, "issued_date")

    @property
    @pulumi.getter
    def number(self) -> int:
        """
        The invoice number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> str:
        """
        The start date of the billing period (RFC 3339 format).
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="totalTaxed")
    def total_taxed(self) -> str:
        """
        The total amount, taxed.
        """
        return pulumi.get(self, "total_taxed")

    @property
    @pulumi.getter(name="totalUntaxed")
    def total_untaxed(self) -> str:
        """
        The total amount, untaxed.
        """
        return pulumi.get(self, "total_untaxed")


@pulumi.output_type
class GetCockpitEndpointResult(dict):
    def __init__(__self__, *,
                 alertmanager_url: str,
                 grafana_url: str,
                 logs_url: str,
                 metrics_url: str):
        """
        :param str alertmanager_url: The alertmanager URL
        :param str grafana_url: The grafana URL
        :param str logs_url: The logs URL
        :param str metrics_url: The metrics URL
        """
        GetCockpitEndpointResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alertmanager_url=alertmanager_url,
            grafana_url=grafana_url,
            logs_url=logs_url,
            metrics_url=metrics_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alertmanager_url: str,
             grafana_url: str,
             logs_url: str,
             metrics_url: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'alertmanagerUrl' in kwargs:
            alertmanager_url = kwargs['alertmanagerUrl']
        if 'grafanaUrl' in kwargs:
            grafana_url = kwargs['grafanaUrl']
        if 'logsUrl' in kwargs:
            logs_url = kwargs['logsUrl']
        if 'metricsUrl' in kwargs:
            metrics_url = kwargs['metricsUrl']

        _setter("alertmanager_url", alertmanager_url)
        _setter("grafana_url", grafana_url)
        _setter("logs_url", logs_url)
        _setter("metrics_url", metrics_url)

    @property
    @pulumi.getter(name="alertmanagerUrl")
    def alertmanager_url(self) -> str:
        """
        The alertmanager URL
        """
        return pulumi.get(self, "alertmanager_url")

    @property
    @pulumi.getter(name="grafanaUrl")
    def grafana_url(self) -> str:
        """
        The grafana URL
        """
        return pulumi.get(self, "grafana_url")

    @property
    @pulumi.getter(name="logsUrl")
    def logs_url(self) -> str:
        """
        The logs URL
        """
        return pulumi.get(self, "logs_url")

    @property
    @pulumi.getter(name="metricsUrl")
    def metrics_url(self) -> str:
        """
        The metrics URL
        """
        return pulumi.get(self, "metrics_url")


@pulumi.output_type
class GetDomainRecordGeoIpResult(dict):
    def __init__(__self__, *,
                 matches: Sequence['outputs.GetDomainRecordGeoIpMatchResult']):
        GetDomainRecordGeoIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: Sequence['outputs.GetDomainRecordGeoIpMatchResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetDomainRecordGeoIpMatchResult']:
        return pulumi.get(self, "matches")


@pulumi.output_type
class GetDomainRecordGeoIpMatchResult(dict):
    def __init__(__self__, *,
                 continents: Sequence[str],
                 countries: Sequence[str],
                 data: str):
        """
        :param str data: The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
               Cannot be used with `record_id`.
        """
        GetDomainRecordGeoIpMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            continents=continents,
            countries=countries,
            data=data,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             continents: Sequence[str],
             countries: Sequence[str],
             data: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("continents", continents)
        _setter("countries", countries)
        _setter("data", data)

    @property
    @pulumi.getter
    def continents(self) -> Sequence[str]:
        return pulumi.get(self, "continents")

    @property
    @pulumi.getter
    def countries(self) -> Sequence[str]:
        return pulumi.get(self, "countries")

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        Cannot be used with `record_id`.
        """
        return pulumi.get(self, "data")


@pulumi.output_type
class GetDomainRecordHttpServiceResult(dict):
    def __init__(__self__, *,
                 ips: Sequence[str],
                 must_contain: str,
                 strategy: str,
                 url: str,
                 user_agent: str):
        GetDomainRecordHttpServiceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ips=ips,
            must_contain=must_contain,
            strategy=strategy,
            url=url,
            user_agent=user_agent,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ips: Sequence[str],
             must_contain: str,
             strategy: str,
             url: str,
             user_agent: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mustContain' in kwargs:
            must_contain = kwargs['mustContain']
        if 'userAgent' in kwargs:
            user_agent = kwargs['userAgent']

        _setter("ips", ips)
        _setter("must_contain", must_contain)
        _setter("strategy", strategy)
        _setter("url", url)
        _setter("user_agent", user_agent)

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="mustContain")
    def must_contain(self) -> str:
        return pulumi.get(self, "must_contain")

    @property
    @pulumi.getter
    def strategy(self) -> str:
        return pulumi.get(self, "strategy")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> str:
        return pulumi.get(self, "user_agent")


@pulumi.output_type
class GetDomainRecordViewResult(dict):
    def __init__(__self__, *,
                 data: str,
                 subnet: str):
        """
        :param str data: The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
               Cannot be used with `record_id`.
        """
        GetDomainRecordViewResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: str,
             subnet: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("data", data)
        _setter("subnet", subnet)

    @property
    @pulumi.getter
    def data(self) -> str:
        """
        The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        Cannot be used with `record_id`.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetDomainRecordWeightedResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 weight: int):
        GetDomainRecordWeightedResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             weight: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def weight(self) -> int:
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetFlexibleIpsIpResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 description: str,
                 id: str,
                 ip_address: str,
                 mac_addresses: Sequence['outputs.GetFlexibleIpsIpMacAddressResult'],
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 status: str,
                 tags: Sequence[str],
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: The date on which the flexible IP was created (RFC 3339 format).
        :param str description: The description of the flexible IP.
        :param str id: The MAC address ID.
        :param Sequence['GetFlexibleIpsIpMacAddressArgs'] mac_addresses: The MAC address of the Virtual MAC.
        :param str organization_id: (Defaults to provider `organization_id`) The ID of the organization the IP is in.
        :param str project_id: (Defaults to provider `project_id`) The ID of the project the IP is in.
        :param str reverse: The reverse domain associated with this IP.
        :param str status: The status of virtual MAC.
        :param Sequence[str] tags: List of tags used as filter. IPs with these exact tags are listed.
        :param str updated_at: The date on which the flexible IP was last updated (RFC 3339 format).
        :param str zone: `zone`) The zone in which IPs exist.
        """
        GetFlexibleIpsIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            description=description,
            id=id,
            ip_address=ip_address,
            mac_addresses=mac_addresses,
            organization_id=organization_id,
            project_id=project_id,
            reverse=reverse,
            status=status,
            tags=tags,
            updated_at=updated_at,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             description: str,
             id: str,
             ip_address: str,
             mac_addresses: Sequence['outputs.GetFlexibleIpsIpMacAddressResult'],
             organization_id: str,
             project_id: str,
             reverse: str,
             status: str,
             tags: Sequence[str],
             updated_at: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if 'macAddresses' in kwargs:
            mac_addresses = kwargs['macAddresses']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("created_at", created_at)
        _setter("description", description)
        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("mac_addresses", mac_addresses)
        _setter("organization_id", organization_id)
        _setter("project_id", project_id)
        _setter("reverse", reverse)
        _setter("status", status)
        _setter("tags", tags)
        _setter("updated_at", updated_at)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the flexible IP was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the flexible IP.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The MAC address ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="macAddresses")
    def mac_addresses(self) -> Sequence['outputs.GetFlexibleIpsIpMacAddressResult']:
        """
        The MAC address of the Virtual MAC.
        """
        return pulumi.get(self, "mac_addresses")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        (Defaults to provider `organization_id`) The ID of the organization the IP is in.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        (Defaults to provider `project_id`) The ID of the project the IP is in.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The reverse domain associated with this IP.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of virtual MAC.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. IPs with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date on which the flexible IP was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetFlexibleIpsIpMacAddressResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 mac_address: str,
                 mac_type: str,
                 status: str,
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: The date on which the flexible IP was created (RFC 3339 format).
        :param str id: The MAC address ID.
        :param str mac_address: The MAC address of the Virtual MAC.
        :param str mac_type: The type of virtual MAC.
        :param str status: The status of virtual MAC.
        :param str updated_at: The date on which the flexible IP was last updated (RFC 3339 format).
        :param str zone: `zone`) The zone in which IPs exist.
        """
        GetFlexibleIpsIpMacAddressResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            id=id,
            mac_address=mac_address,
            mac_type=mac_type,
            status=status,
            updated_at=updated_at,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             id: str,
             mac_address: str,
             mac_type: str,
             status: str,
             updated_at: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']
        if 'macType' in kwargs:
            mac_type = kwargs['macType']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("created_at", created_at)
        _setter("id", id)
        _setter("mac_address", mac_address)
        _setter("mac_type", mac_type)
        _setter("status", status)
        _setter("updated_at", updated_at)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date on which the flexible IP was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The MAC address ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        """
        The MAC address of the Virtual MAC.
        """
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="macType")
    def mac_type(self) -> str:
        """
        The type of virtual MAC.
        """
        return pulumi.get(self, "mac_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of virtual MAC.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        The date on which the flexible IP was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInstanceSecurityGroupInboundRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 ip: str,
                 ip_range: str,
                 port: int,
                 port_range: str,
                 protocol: str):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule apply to.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        GetInstanceSecurityGroupInboundRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             ip: str,
             ip_range: str,
             port: int,
             port_range: str,
             protocol: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        _setter("ip", ip)
        _setter("ip_range", ip_range)
        _setter("port", port)
        _setter("port_range", port_range)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip this rule apply to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        The ip range (e.g `192.168.1.0/24`) this rule apply to.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInstanceSecurityGroupOutboundRuleResult(dict):
    def __init__(__self__, *,
                 action: str,
                 ip: str,
                 ip_range: str,
                 port: int,
                 port_range: str,
                 protocol: str):
        """
        :param str action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param str ip: The ip this rule apply to.
        :param str ip_range: The ip range (e.g `192.168.1.0/24`) this rule apply to.
        :param int port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param str protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        GetInstanceSecurityGroupOutboundRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             ip: str,
             ip_range: str,
             port: int,
             port_range: str,
             protocol: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        _setter("ip", ip)
        _setter("ip_range", ip_range)
        _setter("port", port)
        _setter("port_range", port_range)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip this rule apply to.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> str:
        """
        The ip range (e.g `192.168.1.0/24`) this rule apply to.
        """
        return pulumi.get(self, "ip_range")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> str:
        return pulumi.get(self, "port_range")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInstanceServerPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 mac_address: str,
                 pn_id: str,
                 status: str,
                 zone: str):
        """
        :param str zone: `zone`) The zone in which the server exists.
        """
        GetInstanceServerPrivateNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mac_address=mac_address,
            pn_id=pn_id,
            status=status,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mac_address: str,
             pn_id: str,
             status: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']
        if 'pnId' in kwargs:
            pn_id = kwargs['pnId']

        _setter("mac_address", mac_address)
        _setter("pn_id", pn_id)
        _setter("status", status)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> str:
        return pulumi.get(self, "mac_address")

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which the server exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInstanceServerPublicIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str):
        """
        :param str address: The address of the IP
        :param str id: The ID of the IP
        """
        GetInstanceServerPublicIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("address", address)
        _setter("id", id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInstanceServerRootVolumeResult(dict):
    def __init__(__self__, *,
                 boot: bool,
                 delete_on_termination: bool,
                 name: str,
                 size_in_gb: int,
                 volume_id: str,
                 volume_type: str):
        """
        :param bool delete_on_termination: Forces deletion of the root volume on instance termination.
        :param str name: The server name. Only one of `name` and `server_id` should be specified.
        :param int size_in_gb: Size of the root volume in gigabytes.
        :param str volume_id: The volume ID of the root volume of the server.
        """
        GetInstanceServerRootVolumeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot=boot,
            delete_on_termination=delete_on_termination,
            name=name,
            size_in_gb=size_in_gb,
            volume_id=volume_id,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot: bool,
             delete_on_termination: bool,
             name: str,
             size_in_gb: int,
             volume_id: str,
             volume_type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if 'sizeInGb' in kwargs:
            size_in_gb = kwargs['sizeInGb']
        if 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        _setter("boot", boot)
        _setter("delete_on_termination", delete_on_termination)
        _setter("name", name)
        _setter("size_in_gb", size_in_gb)
        _setter("volume_id", volume_id)
        _setter("volume_type", volume_type)

    @property
    @pulumi.getter
    def boot(self) -> bool:
        return pulumi.get(self, "boot")

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> bool:
        """
        Forces deletion of the root volume on instance termination.
        """
        return pulumi.get(self, "delete_on_termination")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The server name. Only one of `name` and `server_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> int:
        """
        Size of the root volume in gigabytes.
        """
        return pulumi.get(self, "size_in_gb")

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> str:
        """
        The volume ID of the root volume of the server.
        """
        return pulumi.get(self, "volume_id")

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> str:
        return pulumi.get(self, "volume_type")


@pulumi.output_type
class GetInstanceServersServerResult(dict):
    def __init__(__self__, *,
                 boot_type: str,
                 bootscript_id: str,
                 enable_dynamic_ip: bool,
                 enable_ipv6: bool,
                 id: str,
                 image: str,
                 ipv6_address: str,
                 ipv6_gateway: str,
                 ipv6_prefix_length: int,
                 name: str,
                 organization_id: str,
                 placement_group_id: str,
                 placement_group_policy_respected: bool,
                 private_ip: str,
                 project_id: str,
                 public_ip: str,
                 public_ips: Sequence['outputs.GetInstanceServersServerPublicIpResult'],
                 routed_ip_enabled: bool,
                 security_group_id: str,
                 state: str,
                 tags: Sequence[str],
                 type: str,
                 zone: str):
        """
        :param str boot_type: The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
        :param str bootscript_id: The ID of the bootscript.
        :param bool enable_dynamic_ip: If true a dynamic IP will be attached to the server.
        :param bool enable_ipv6: Determines if IPv6 is enabled for the server.
        :param str id: The ID of the IP
        :param str image: The UUID or the label of the base image used by the server.
        :param str ipv6_address: The default ipv6 address routed to the server. ( Only set when enable_ipv6 is set to true )
        :param str ipv6_gateway: The ipv6 gateway address. ( Only set when enable_ipv6 is set to true )
        :param int ipv6_prefix_length: The prefix length of the ipv6 subnet routed to the server. ( Only set when enable_ipv6 is set to true )
        :param str name: The server name used as filter. Servers with a name like it are listed.
        :param str organization_id: The organization ID the server is associated with.
        :param str placement_group_id: The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
        :param str private_ip: The Scaleway internal IP address of the server.
        :param str project_id: The ID of the project the server is associated with.
        :param str public_ip: The public IP address of the server.
        :param Sequence['GetInstanceServersServerPublicIpArgs'] public_ips: The list of public IPs of the server
        :param bool routed_ip_enabled: True if the server support routed ip only.
        :param str security_group_id: The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
        :param str state: The state of the server. Possible values are: `started`, `stopped` or `standby`.
        :param Sequence[str] tags: List of tags used as filter. Servers with these exact tags are listed.
        :param str type: The commercial type of the server.
        :param str zone: `zone`) The zone in which servers exist.
        """
        GetInstanceServersServerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot_type=boot_type,
            bootscript_id=bootscript_id,
            enable_dynamic_ip=enable_dynamic_ip,
            enable_ipv6=enable_ipv6,
            id=id,
            image=image,
            ipv6_address=ipv6_address,
            ipv6_gateway=ipv6_gateway,
            ipv6_prefix_length=ipv6_prefix_length,
            name=name,
            organization_id=organization_id,
            placement_group_id=placement_group_id,
            placement_group_policy_respected=placement_group_policy_respected,
            private_ip=private_ip,
            project_id=project_id,
            public_ip=public_ip,
            public_ips=public_ips,
            routed_ip_enabled=routed_ip_enabled,
            security_group_id=security_group_id,
            state=state,
            tags=tags,
            type=type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot_type: str,
             bootscript_id: str,
             enable_dynamic_ip: bool,
             enable_ipv6: bool,
             id: str,
             image: str,
             ipv6_address: str,
             ipv6_gateway: str,
             ipv6_prefix_length: int,
             name: str,
             organization_id: str,
             placement_group_id: str,
             placement_group_policy_respected: bool,
             private_ip: str,
             project_id: str,
             public_ip: str,
             public_ips: Sequence['outputs.GetInstanceServersServerPublicIpResult'],
             routed_ip_enabled: bool,
             security_group_id: str,
             state: str,
             tags: Sequence[str],
             type: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bootType' in kwargs:
            boot_type = kwargs['bootType']
        if 'bootscriptId' in kwargs:
            bootscript_id = kwargs['bootscriptId']
        if 'enableDynamicIp' in kwargs:
            enable_dynamic_ip = kwargs['enableDynamicIp']
        if 'enableIpv6' in kwargs:
            enable_ipv6 = kwargs['enableIpv6']
        if 'ipv6Address' in kwargs:
            ipv6_address = kwargs['ipv6Address']
        if 'ipv6Gateway' in kwargs:
            ipv6_gateway = kwargs['ipv6Gateway']
        if 'ipv6PrefixLength' in kwargs:
            ipv6_prefix_length = kwargs['ipv6PrefixLength']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'placementGroupId' in kwargs:
            placement_group_id = kwargs['placementGroupId']
        if 'placementGroupPolicyRespected' in kwargs:
            placement_group_policy_respected = kwargs['placementGroupPolicyRespected']
        if 'privateIp' in kwargs:
            private_ip = kwargs['privateIp']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if 'publicIps' in kwargs:
            public_ips = kwargs['publicIps']
        if 'routedIpEnabled' in kwargs:
            routed_ip_enabled = kwargs['routedIpEnabled']
        if 'securityGroupId' in kwargs:
            security_group_id = kwargs['securityGroupId']

        _setter("boot_type", boot_type)
        _setter("bootscript_id", bootscript_id)
        _setter("enable_dynamic_ip", enable_dynamic_ip)
        _setter("enable_ipv6", enable_ipv6)
        _setter("id", id)
        _setter("image", image)
        _setter("ipv6_address", ipv6_address)
        _setter("ipv6_gateway", ipv6_gateway)
        _setter("ipv6_prefix_length", ipv6_prefix_length)
        _setter("name", name)
        _setter("organization_id", organization_id)
        _setter("placement_group_id", placement_group_id)
        _setter("placement_group_policy_respected", placement_group_policy_respected)
        _setter("private_ip", private_ip)
        _setter("project_id", project_id)
        _setter("public_ip", public_ip)
        _setter("public_ips", public_ips)
        _setter("routed_ip_enabled", routed_ip_enabled)
        _setter("security_group_id", security_group_id)
        _setter("state", state)
        _setter("tags", tags)
        _setter("type", type)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="bootType")
    def boot_type(self) -> str:
        """
        The boot Type of the server. Possible values are: `local`, `bootscript` or `rescue`.
        """
        return pulumi.get(self, "boot_type")

    @property
    @pulumi.getter(name="bootscriptId")
    def bootscript_id(self) -> str:
        """
        The ID of the bootscript.
        """
        return pulumi.get(self, "bootscript_id")

    @property
    @pulumi.getter(name="enableDynamicIp")
    def enable_dynamic_ip(self) -> bool:
        """
        If true a dynamic IP will be attached to the server.
        """
        return pulumi.get(self, "enable_dynamic_ip")

    @property
    @pulumi.getter(name="enableIpv6")
    def enable_ipv6(self) -> bool:
        """
        Determines if IPv6 is enabled for the server.
        """
        return pulumi.get(self, "enable_ipv6")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def image(self) -> str:
        """
        The UUID or the label of the base image used by the server.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> str:
        """
        The default ipv6 address routed to the server. ( Only set when enable_ipv6 is set to true )
        """
        return pulumi.get(self, "ipv6_address")

    @property
    @pulumi.getter(name="ipv6Gateway")
    def ipv6_gateway(self) -> str:
        """
        The ipv6 gateway address. ( Only set when enable_ipv6 is set to true )
        """
        return pulumi.get(self, "ipv6_gateway")

    @property
    @pulumi.getter(name="ipv6PrefixLength")
    def ipv6_prefix_length(self) -> int:
        """
        The prefix length of the ipv6 subnet routed to the server. ( Only set when enable_ipv6 is set to true )
        """
        return pulumi.get(self, "ipv6_prefix_length")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The server name used as filter. Servers with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID the server is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="placementGroupId")
    def placement_group_id(self) -> str:
        """
        The [placement group](https://developers.scaleway.com/en/products/instance/api/#placement-groups-d8f653) the server is attached to.
        """
        return pulumi.get(self, "placement_group_id")

    @property
    @pulumi.getter(name="placementGroupPolicyRespected")
    def placement_group_policy_respected(self) -> bool:
        return pulumi.get(self, "placement_group_policy_respected")

    @property
    @pulumi.getter(name="privateIp")
    def private_ip(self) -> str:
        """
        The Scaleway internal IP address of the server.
        """
        return pulumi.get(self, "private_ip")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the project the server is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IP address of the server.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIps")
    def public_ips(self) -> Sequence['outputs.GetInstanceServersServerPublicIpResult']:
        """
        The list of public IPs of the server
        """
        return pulumi.get(self, "public_ips")

    @property
    @pulumi.getter(name="routedIpEnabled")
    def routed_ip_enabled(self) -> bool:
        """
        True if the server support routed ip only.
        """
        return pulumi.get(self, "routed_ip_enabled")

    @property
    @pulumi.getter(name="securityGroupId")
    def security_group_id(self) -> str:
        """
        The [security group](https://developers.scaleway.com/en/products/instance/api/#security-groups-8d7f89) the server is attached to.
        """
        return pulumi.get(self, "security_group_id")

    @property
    @pulumi.getter
    def state(self) -> str:
        """
        The state of the server. Possible values are: `started`, `stopped` or `standby`.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. Servers with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The commercial type of the server.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which servers exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetInstanceServersServerPublicIpResult(dict):
    def __init__(__self__, *,
                 address: str,
                 id: str):
        """
        :param str address: The address of the IP
        :param str id: The ID of the IP
        """
        GetInstanceServersServerPublicIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("address", address)
        _setter("id", id)

    @property
    @pulumi.getter
    def address(self) -> str:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetInstanceSnapshotImportResult(dict):
    def __init__(__self__, *,
                 bucket: str,
                 key: str):
        GetInstanceSnapshotImportResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: str,
             key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("bucket", bucket)
        _setter("key", key)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")


@pulumi.output_type
class GetIotDeviceCertificateResult(dict):
    def __init__(__self__, *,
                 crt: str,
                 key: str):
        GetIotDeviceCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crt=crt,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crt: str,
             key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("crt", crt)
        _setter("key", key)

    @property
    @pulumi.getter
    def crt(self) -> str:
        return pulumi.get(self, "crt")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")


@pulumi.output_type
class GetIotDeviceMessageFilterResult(dict):
    def __init__(__self__, *,
                 publishes: Sequence['outputs.GetIotDeviceMessageFilterPublishResult'],
                 subscribes: Sequence['outputs.GetIotDeviceMessageFilterSubscribeResult']):
        GetIotDeviceMessageFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publishes=publishes,
            subscribes=subscribes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publishes: Sequence['outputs.GetIotDeviceMessageFilterPublishResult'],
             subscribes: Sequence['outputs.GetIotDeviceMessageFilterSubscribeResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("publishes", publishes)
        _setter("subscribes", subscribes)

    @property
    @pulumi.getter
    def publishes(self) -> Sequence['outputs.GetIotDeviceMessageFilterPublishResult']:
        return pulumi.get(self, "publishes")

    @property
    @pulumi.getter
    def subscribes(self) -> Sequence['outputs.GetIotDeviceMessageFilterSubscribeResult']:
        return pulumi.get(self, "subscribes")


@pulumi.output_type
class GetIotDeviceMessageFilterPublishResult(dict):
    def __init__(__self__, *,
                 policy: str,
                 topics: Sequence[str]):
        GetIotDeviceMessageFilterPublishResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            topics=topics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: str,
             topics: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("policy", policy)
        _setter("topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> str:
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[str]:
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetIotDeviceMessageFilterSubscribeResult(dict):
    def __init__(__self__, *,
                 policy: str,
                 topics: Sequence[str]):
        GetIotDeviceMessageFilterSubscribeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            topics=topics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: str,
             topics: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("policy", policy)
        _setter("topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> str:
        return pulumi.get(self, "policy")

    @property
    @pulumi.getter
    def topics(self) -> Sequence[str]:
        return pulumi.get(self, "topics")


@pulumi.output_type
class GetIpamIpResourceResult(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the resource that the IP is bound to.
        :param str type: The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1alpha1#pkg-constants) with type list.
        """
        GetIpamIpResourceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the resource that the IP is bound to.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1alpha1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetK8sClusterAutoUpgradeResult(dict):
    def __init__(__self__, *,
                 enable: bool,
                 maintenance_window_day: str,
                 maintenance_window_start_hour: int):
        """
        :param bool enable: True if Kubernetes patch version auto upgrades is enabled.
        :param str maintenance_window_day: The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        :param int maintenance_window_start_hour: The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        GetK8sClusterAutoUpgradeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            maintenance_window_day=maintenance_window_day,
            maintenance_window_start_hour=maintenance_window_start_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: bool,
             maintenance_window_day: str,
             maintenance_window_start_hour: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maintenanceWindowDay' in kwargs:
            maintenance_window_day = kwargs['maintenanceWindowDay']
        if 'maintenanceWindowStartHour' in kwargs:
            maintenance_window_start_hour = kwargs['maintenanceWindowStartHour']

        _setter("enable", enable)
        _setter("maintenance_window_day", maintenance_window_day)
        _setter("maintenance_window_start_hour", maintenance_window_start_hour)

    @property
    @pulumi.getter
    def enable(self) -> bool:
        """
        True if Kubernetes patch version auto upgrades is enabled.
        """
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="maintenanceWindowDay")
    def maintenance_window_day(self) -> str:
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        return pulumi.get(self, "maintenance_window_day")

    @property
    @pulumi.getter(name="maintenanceWindowStartHour")
    def maintenance_window_start_hour(self) -> int:
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        return pulumi.get(self, "maintenance_window_start_hour")


@pulumi.output_type
class GetK8sClusterAutoscalerConfigResult(dict):
    def __init__(__self__, *,
                 balance_similar_node_groups: bool,
                 disable_scale_down: bool,
                 estimator: str,
                 expander: str,
                 expendable_pods_priority_cutoff: int,
                 ignore_daemonsets_utilization: bool,
                 max_graceful_termination_sec: int,
                 scale_down_delay_after_add: str,
                 scale_down_unneeded_time: str,
                 scale_down_utilization_threshold: float):
        """
        :param bool balance_similar_node_groups: True if detecting similar node groups and balance the number of nodes between them is enabled.
        :param bool disable_scale_down: True if the scale down feature of the autoscaler is disabled.
        :param str estimator: The type of resource estimator used in scale up.
        :param str expander: The type of node group expander be used in scale up.
        :param int expendable_pods_priority_cutoff: Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        :param bool ignore_daemonsets_utilization: True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
        :param str scale_down_delay_after_add: The duration after scale up that scale down evaluation resumes.
        :param str scale_down_unneeded_time: The duration a node should be unneeded before it is eligible for scale down.
        """
        GetK8sClusterAutoscalerConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            balance_similar_node_groups=balance_similar_node_groups,
            disable_scale_down=disable_scale_down,
            estimator=estimator,
            expander=expander,
            expendable_pods_priority_cutoff=expendable_pods_priority_cutoff,
            ignore_daemonsets_utilization=ignore_daemonsets_utilization,
            max_graceful_termination_sec=max_graceful_termination_sec,
            scale_down_delay_after_add=scale_down_delay_after_add,
            scale_down_unneeded_time=scale_down_unneeded_time,
            scale_down_utilization_threshold=scale_down_utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             balance_similar_node_groups: bool,
             disable_scale_down: bool,
             estimator: str,
             expander: str,
             expendable_pods_priority_cutoff: int,
             ignore_daemonsets_utilization: bool,
             max_graceful_termination_sec: int,
             scale_down_delay_after_add: str,
             scale_down_unneeded_time: str,
             scale_down_utilization_threshold: float,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'balanceSimilarNodeGroups' in kwargs:
            balance_similar_node_groups = kwargs['balanceSimilarNodeGroups']
        if 'disableScaleDown' in kwargs:
            disable_scale_down = kwargs['disableScaleDown']
        if 'expendablePodsPriorityCutoff' in kwargs:
            expendable_pods_priority_cutoff = kwargs['expendablePodsPriorityCutoff']
        if 'ignoreDaemonsetsUtilization' in kwargs:
            ignore_daemonsets_utilization = kwargs['ignoreDaemonsetsUtilization']
        if 'maxGracefulTerminationSec' in kwargs:
            max_graceful_termination_sec = kwargs['maxGracefulTerminationSec']
        if 'scaleDownDelayAfterAdd' in kwargs:
            scale_down_delay_after_add = kwargs['scaleDownDelayAfterAdd']
        if 'scaleDownUnneededTime' in kwargs:
            scale_down_unneeded_time = kwargs['scaleDownUnneededTime']
        if 'scaleDownUtilizationThreshold' in kwargs:
            scale_down_utilization_threshold = kwargs['scaleDownUtilizationThreshold']

        _setter("balance_similar_node_groups", balance_similar_node_groups)
        _setter("disable_scale_down", disable_scale_down)
        _setter("estimator", estimator)
        _setter("expander", expander)
        _setter("expendable_pods_priority_cutoff", expendable_pods_priority_cutoff)
        _setter("ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        _setter("max_graceful_termination_sec", max_graceful_termination_sec)
        _setter("scale_down_delay_after_add", scale_down_delay_after_add)
        _setter("scale_down_unneeded_time", scale_down_unneeded_time)
        _setter("scale_down_utilization_threshold", scale_down_utilization_threshold)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> bool:
        """
        True if detecting similar node groups and balance the number of nodes between them is enabled.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @property
    @pulumi.getter(name="disableScaleDown")
    def disable_scale_down(self) -> bool:
        """
        True if the scale down feature of the autoscaler is disabled.
        """
        return pulumi.get(self, "disable_scale_down")

    @property
    @pulumi.getter
    def estimator(self) -> str:
        """
        The type of resource estimator used in scale up.
        """
        return pulumi.get(self, "estimator")

    @property
    @pulumi.getter
    def expander(self) -> str:
        """
        The type of node group expander be used in scale up.
        """
        return pulumi.get(self, "expander")

    @property
    @pulumi.getter(name="expendablePodsPriorityCutoff")
    def expendable_pods_priority_cutoff(self) -> int:
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        return pulumi.get(self, "expendable_pods_priority_cutoff")

    @property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> bool:
        """
        True if ignoring DaemonSet pods when calculating resource utilization for scaling down is enabled.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> int:
        return pulumi.get(self, "max_graceful_termination_sec")

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> str:
        """
        The duration after scale up that scale down evaluation resumes.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> str:
        """
        The duration a node should be unneeded before it is eligible for scale down.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> float:
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class GetK8sClusterKubeconfigResult(dict):
    def __init__(__self__, *,
                 cluster_ca_certificate: str,
                 config_file: str,
                 host: str,
                 token: str):
        """
        :param str cluster_ca_certificate: The CA certificate of the Kubernetes API server.
        :param str config_file: The raw kubeconfig file.
        :param str host: The URL of the Kubernetes API server.
        :param str token: The token to connect to the Kubernetes API server.
        """
        GetK8sClusterKubeconfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_ca_certificate=cluster_ca_certificate,
            config_file=config_file,
            host=host,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_ca_certificate: str,
             config_file: str,
             host: str,
             token: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clusterCaCertificate' in kwargs:
            cluster_ca_certificate = kwargs['clusterCaCertificate']
        if 'configFile' in kwargs:
            config_file = kwargs['configFile']

        _setter("cluster_ca_certificate", cluster_ca_certificate)
        _setter("config_file", config_file)
        _setter("host", host)
        _setter("token", token)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> str:
        """
        The CA certificate of the Kubernetes API server.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> str:
        """
        The raw kubeconfig file.
        """
        return pulumi.get(self, "config_file")

    @property
    @pulumi.getter
    def host(self) -> str:
        """
        The URL of the Kubernetes API server.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def token(self) -> str:
        """
        The token to connect to the Kubernetes API server.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetK8sClusterOpenIdConnectConfigResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 groups_claims: Sequence[str],
                 groups_prefix: str,
                 issuer_url: str,
                 required_claims: Sequence[str],
                 username_claim: str,
                 username_prefix: str):
        GetK8sClusterOpenIdConnectConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            groups_claims=groups_claims,
            groups_prefix=groups_prefix,
            issuer_url=issuer_url,
            required_claims=required_claims,
            username_claim=username_claim,
            username_prefix=username_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             groups_claims: Sequence[str],
             groups_prefix: str,
             issuer_url: str,
             required_claims: Sequence[str],
             username_claim: str,
             username_prefix: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'groupsClaims' in kwargs:
            groups_claims = kwargs['groupsClaims']
        if 'groupsPrefix' in kwargs:
            groups_prefix = kwargs['groupsPrefix']
        if 'issuerUrl' in kwargs:
            issuer_url = kwargs['issuerUrl']
        if 'requiredClaims' in kwargs:
            required_claims = kwargs['requiredClaims']
        if 'usernameClaim' in kwargs:
            username_claim = kwargs['usernameClaim']
        if 'usernamePrefix' in kwargs:
            username_prefix = kwargs['usernamePrefix']

        _setter("client_id", client_id)
        _setter("groups_claims", groups_claims)
        _setter("groups_prefix", groups_prefix)
        _setter("issuer_url", issuer_url)
        _setter("required_claims", required_claims)
        _setter("username_claim", username_claim)
        _setter("username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Sequence[str]:
        return pulumi.get(self, "groups_claims")

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> str:
        return pulumi.get(self, "groups_prefix")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Sequence[str]:
        return pulumi.get(self, "required_claims")

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> str:
        return pulumi.get(self, "username_claim")

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> str:
        return pulumi.get(self, "username_prefix")


@pulumi.output_type
class GetK8sPoolNodeResult(dict):
    def __init__(__self__, *,
                 name: str,
                 public_ip: str,
                 public_ip_v6: str,
                 status: str):
        """
        :param str name: The pool name. Only one of `name` and `pool_id` should be specified. `cluster_id` should be specified with `name`.
        :param str public_ip: The public IPv4.
        :param str public_ip_v6: The public IPv6.
        :param str status: The status of the node.
        """
        GetK8sPoolNodeResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            public_ip=public_ip,
            public_ip_v6=public_ip_v6,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             public_ip: str,
             public_ip_v6: str,
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if 'publicIpV6' in kwargs:
            public_ip_v6 = kwargs['publicIpV6']

        _setter("name", name)
        _setter("public_ip", public_ip)
        _setter("public_ip_v6", public_ip_v6)
        _setter("status", status)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The pool name. Only one of `name` and `pool_id` should be specified. `cluster_id` should be specified with `name`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> str:
        """
        The public IPv4.
        """
        return pulumi.get(self, "public_ip")

    @property
    @pulumi.getter(name="publicIpV6")
    def public_ip_v6(self) -> str:
        """
        The public IPv6.
        """
        return pulumi.get(self, "public_ip_v6")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the node.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetK8sPoolUpgradePolicyResult(dict):
    def __init__(__self__, *,
                 max_surge: int,
                 max_unavailable: int):
        GetK8sPoolUpgradePolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_surge=max_surge,
            max_unavailable=max_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_surge: int,
             max_unavailable: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSurge' in kwargs:
            max_surge = kwargs['maxSurge']
        if 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']

        _setter("max_surge", max_surge)
        _setter("max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> int:
        return pulumi.get(self, "max_surge")

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> int:
        return pulumi.get(self, "max_unavailable")


@pulumi.output_type
class GetLbAclsAclResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetLbAclsAclActionResult'],
                 created_at: str,
                 description: str,
                 frontend_id: str,
                 id: str,
                 index: int,
                 matches: Sequence['outputs.GetLbAclsAclMatchResult'],
                 name: str,
                 update_at: str):
        """
        :param Sequence['GetLbAclsAclActionArgs'] actions: The action that has been undertaken when an ACL filter had matched.
        :param str created_at: The date at which the ACL was created (RFC 3339 format).
        :param str description: The description of the ACL resource.
        :param str frontend_id: The frontend ID this ACL is attached to. ACLs with a frontend ID like it are listed.
               > **Important:** LB Frontends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param str id: The associated ACL ID.
               > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param int index: The order between the ACLs.
        :param Sequence['GetLbAclsAclMatchArgs'] matches: The ACL match rule.
        :param str name: The ACL name used as filter. ACLs with a name like it are listed.
        :param str update_at: The date at which the ACL was last updated (RFC 3339 format).
        """
        GetLbAclsAclResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            created_at=created_at,
            description=description,
            frontend_id=frontend_id,
            id=id,
            index=index,
            matches=matches,
            name=name,
            update_at=update_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence['outputs.GetLbAclsAclActionResult'],
             created_at: str,
             description: str,
             frontend_id: str,
             id: str,
             index: int,
             matches: Sequence['outputs.GetLbAclsAclMatchResult'],
             name: str,
             update_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'frontendId' in kwargs:
            frontend_id = kwargs['frontendId']
        if 'updateAt' in kwargs:
            update_at = kwargs['updateAt']

        _setter("actions", actions)
        _setter("created_at", created_at)
        _setter("description", description)
        _setter("frontend_id", frontend_id)
        _setter("id", id)
        _setter("index", index)
        _setter("matches", matches)
        _setter("name", name)
        _setter("update_at", update_at)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetLbAclsAclActionResult']:
        """
        The action that has been undertaken when an ACL filter had matched.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date at which the ACL was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the ACL resource.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> str:
        """
        The frontend ID this ACL is attached to. ACLs with a frontend ID like it are listed.
        > **Important:** LB Frontends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "frontend_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated ACL ID.
        > **Important:** LB ACLs' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def index(self) -> int:
        """
        The order between the ACLs.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetLbAclsAclMatchResult']:
        """
        The ACL match rule.
        """
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The ACL name used as filter. ACLs with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date at which the ACL was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbAclsAclActionResult(dict):
    def __init__(__self__, *,
                 redirects: Sequence['outputs.GetLbAclsAclActionRedirectResult'],
                 type: str):
        """
        :param Sequence['GetLbAclsAclActionRedirectArgs'] redirects: Redirect parameters when using an ACL with `redirect` action.
        :param str type: The redirect type.
        """
        GetLbAclsAclActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirects=redirects,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirects: Sequence['outputs.GetLbAclsAclActionRedirectResult'],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("redirects", redirects)
        _setter("type", type)

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetLbAclsAclActionRedirectResult']:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbAclsAclActionRedirectResult(dict):
    def __init__(__self__, *,
                 code: int,
                 target: str,
                 type: str):
        """
        :param int code: The HTTP redirect code used.
        :param str target: The URL used in case of a location redirect or the scheme name that replaces the request's original scheme.
        :param str type: The redirect type.
        """
        GetLbAclsAclActionRedirectResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: int,
             target: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("code", code)
        _setter("target", target)
        _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The HTTP redirect code used.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The URL used in case of a location redirect or the scheme name that replaces the request's original scheme.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The redirect type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbAclsAclMatchResult(dict):
    def __init__(__self__, *,
                 http_filter: str,
                 http_filter_option: str,
                 http_filter_values: Sequence[str],
                 invert: bool,
                 ip_subnets: Sequence[str]):
        """
        :param str http_filter: The matched HTTP filter.
        :param Sequence[str] http_filter_values: The possible values matched for a given HTTP filter.
        :param bool invert: The condition will be of type "unless" if invert is set to `true`
        :param Sequence[str] ip_subnets: A list of matched IPs or CIDR v4/v6 addresses of the client of the session.
        """
        GetLbAclsAclMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_filter=http_filter,
            http_filter_option=http_filter_option,
            http_filter_values=http_filter_values,
            invert=invert,
            ip_subnets=ip_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_filter: str,
             http_filter_option: str,
             http_filter_values: Sequence[str],
             invert: bool,
             ip_subnets: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpFilter' in kwargs:
            http_filter = kwargs['httpFilter']
        if 'httpFilterOption' in kwargs:
            http_filter_option = kwargs['httpFilterOption']
        if 'httpFilterValues' in kwargs:
            http_filter_values = kwargs['httpFilterValues']
        if 'ipSubnets' in kwargs:
            ip_subnets = kwargs['ipSubnets']

        _setter("http_filter", http_filter)
        _setter("http_filter_option", http_filter_option)
        _setter("http_filter_values", http_filter_values)
        _setter("invert", invert)
        _setter("ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> str:
        """
        The matched HTTP filter.
        """
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> str:
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Sequence[str]:
        """
        The possible values matched for a given HTTP filter.
        """
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> bool:
        """
        The condition will be of type "unless" if invert is set to `true`
        """
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Sequence[str]:
        """
        A list of matched IPs or CIDR v4/v6 addresses of the client of the session.
        """
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class GetLbBackendHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 code: int,
                 host_header: str,
                 method: str,
                 sni: str,
                 uri: str):
        GetLbBackendHealthCheckHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            host_header=host_header,
            method=method,
            sni=sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: int,
             host_header: str,
             method: str,
             sni: str,
             uri: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostHeader' in kwargs:
            host_header = kwargs['hostHeader']

        _setter("code", code)
        _setter("host_header", host_header)
        _setter("method", method)
        _setter("sni", sni)
        _setter("uri", uri)

    @property
    @pulumi.getter
    def code(self) -> int:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> str:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> str:
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetLbBackendHealthCheckTcpResult(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        pass



@pulumi.output_type
class GetLbBackendsBackendResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 failover_host: str,
                 forward_port: int,
                 forward_port_algorithm: str,
                 forward_protocol: str,
                 health_check_delay: str,
                 health_check_http: Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult'],
                 health_check_https: Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult'],
                 health_check_max_retries: int,
                 health_check_port: int,
                 health_check_tcps: Sequence['outputs.GetLbBackendsBackendHealthCheckTcpResult'],
                 health_check_timeout: str,
                 id: str,
                 ignore_ssl_server_verify: bool,
                 lb_id: str,
                 name: str,
                 on_marked_down_action: str,
                 proxy_protocol: str,
                 server_ips: Sequence[str],
                 ssl_bridging: bool,
                 sticky_sessions: str,
                 sticky_sessions_cookie_name: str,
                 timeout_connect: str,
                 timeout_server: str,
                 timeout_tunnel: str,
                 update_at: str):
        """
        :param str created_at: The date at which the backend was created (RFC 3339 format).
        :param str failover_host: Scaleway S3 bucket website to be served in case all backend servers are down.
        :param int forward_port: User sessions will be forwarded to this port of backend servers.
        :param str forward_port_algorithm: Load balancing algorithm.
        :param str forward_protocol: Backend protocol.
        :param str health_check_delay: Interval between two HC requests.
        :param Sequence['GetLbBackendsBackendHealthCheckHttpArgs'] health_check_http: This block enable HTTP health check.
        :param Sequence['GetLbBackendsBackendHealthCheckHttpArgs'] health_check_https: This block enable HTTPS health check.
        :param int health_check_max_retries: Number of allowed failed HC requests before the backend server is marked down.
        :param int health_check_port: Port the HC requests will be sent to.
        :param Sequence['GetLbBackendsBackendHealthCheckTcpArgs'] health_check_tcps: This block enable TCP health check.
        :param str health_check_timeout: Timeout before we consider a HC request failed.
        :param str id: The associated backend ID.
        :param bool ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
        :param str lb_id: The load-balancer ID this backend is attached to. backends with a LB ID like it are listed.
        :param str name: The backend name used as filter. Backends with a name like it are listed.
        :param str on_marked_down_action: Modify what occurs when a backend server is marked down.
        :param str proxy_protocol: The type of PROXY protocol.
        :param Sequence[str] server_ips: List of backend server IP addresses.
        :param bool ssl_bridging: Enables SSL between load balancer and backend servers.
        :param str sticky_sessions: Enables cookie-based session persistence.
        :param str sticky_sessions_cookie_name: Cookie name for sticky sessions.
        :param str timeout_connect: Maximum initial server connection establishment time.
        :param str timeout_server: Maximum server connection inactivity time.
        :param str timeout_tunnel: Maximum tunnel inactivity time.
        :param str update_at: The date at which the backend was last updated (RFC 3339 format).
        """
        GetLbBackendsBackendResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            failover_host=failover_host,
            forward_port=forward_port,
            forward_port_algorithm=forward_port_algorithm,
            forward_protocol=forward_protocol,
            health_check_delay=health_check_delay,
            health_check_http=health_check_http,
            health_check_https=health_check_https,
            health_check_max_retries=health_check_max_retries,
            health_check_port=health_check_port,
            health_check_tcps=health_check_tcps,
            health_check_timeout=health_check_timeout,
            id=id,
            ignore_ssl_server_verify=ignore_ssl_server_verify,
            lb_id=lb_id,
            name=name,
            on_marked_down_action=on_marked_down_action,
            proxy_protocol=proxy_protocol,
            server_ips=server_ips,
            ssl_bridging=ssl_bridging,
            sticky_sessions=sticky_sessions,
            sticky_sessions_cookie_name=sticky_sessions_cookie_name,
            timeout_connect=timeout_connect,
            timeout_server=timeout_server,
            timeout_tunnel=timeout_tunnel,
            update_at=update_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             failover_host: str,
             forward_port: int,
             forward_port_algorithm: str,
             forward_protocol: str,
             health_check_delay: str,
             health_check_http: Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult'],
             health_check_https: Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult'],
             health_check_max_retries: int,
             health_check_port: int,
             health_check_tcps: Sequence['outputs.GetLbBackendsBackendHealthCheckTcpResult'],
             health_check_timeout: str,
             id: str,
             ignore_ssl_server_verify: bool,
             lb_id: str,
             name: str,
             on_marked_down_action: str,
             proxy_protocol: str,
             server_ips: Sequence[str],
             ssl_bridging: bool,
             sticky_sessions: str,
             sticky_sessions_cookie_name: str,
             timeout_connect: str,
             timeout_server: str,
             timeout_tunnel: str,
             update_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'failoverHost' in kwargs:
            failover_host = kwargs['failoverHost']
        if 'forwardPort' in kwargs:
            forward_port = kwargs['forwardPort']
        if 'forwardPortAlgorithm' in kwargs:
            forward_port_algorithm = kwargs['forwardPortAlgorithm']
        if 'forwardProtocol' in kwargs:
            forward_protocol = kwargs['forwardProtocol']
        if 'healthCheckDelay' in kwargs:
            health_check_delay = kwargs['healthCheckDelay']
        if 'healthCheckHttp' in kwargs:
            health_check_http = kwargs['healthCheckHttp']
        if 'healthCheckHttps' in kwargs:
            health_check_https = kwargs['healthCheckHttps']
        if 'healthCheckMaxRetries' in kwargs:
            health_check_max_retries = kwargs['healthCheckMaxRetries']
        if 'healthCheckPort' in kwargs:
            health_check_port = kwargs['healthCheckPort']
        if 'healthCheckTcps' in kwargs:
            health_check_tcps = kwargs['healthCheckTcps']
        if 'healthCheckTimeout' in kwargs:
            health_check_timeout = kwargs['healthCheckTimeout']
        if 'ignoreSslServerVerify' in kwargs:
            ignore_ssl_server_verify = kwargs['ignoreSslServerVerify']
        if 'lbId' in kwargs:
            lb_id = kwargs['lbId']
        if 'onMarkedDownAction' in kwargs:
            on_marked_down_action = kwargs['onMarkedDownAction']
        if 'proxyProtocol' in kwargs:
            proxy_protocol = kwargs['proxyProtocol']
        if 'serverIps' in kwargs:
            server_ips = kwargs['serverIps']
        if 'sslBridging' in kwargs:
            ssl_bridging = kwargs['sslBridging']
        if 'stickySessions' in kwargs:
            sticky_sessions = kwargs['stickySessions']
        if 'stickySessionsCookieName' in kwargs:
            sticky_sessions_cookie_name = kwargs['stickySessionsCookieName']
        if 'timeoutConnect' in kwargs:
            timeout_connect = kwargs['timeoutConnect']
        if 'timeoutServer' in kwargs:
            timeout_server = kwargs['timeoutServer']
        if 'timeoutTunnel' in kwargs:
            timeout_tunnel = kwargs['timeoutTunnel']
        if 'updateAt' in kwargs:
            update_at = kwargs['updateAt']

        _setter("created_at", created_at)
        _setter("failover_host", failover_host)
        _setter("forward_port", forward_port)
        _setter("forward_port_algorithm", forward_port_algorithm)
        _setter("forward_protocol", forward_protocol)
        _setter("health_check_delay", health_check_delay)
        _setter("health_check_http", health_check_http)
        _setter("health_check_https", health_check_https)
        _setter("health_check_max_retries", health_check_max_retries)
        _setter("health_check_port", health_check_port)
        _setter("health_check_tcps", health_check_tcps)
        _setter("health_check_timeout", health_check_timeout)
        _setter("id", id)
        _setter("ignore_ssl_server_verify", ignore_ssl_server_verify)
        _setter("lb_id", lb_id)
        _setter("name", name)
        _setter("on_marked_down_action", on_marked_down_action)
        _setter("proxy_protocol", proxy_protocol)
        _setter("server_ips", server_ips)
        _setter("ssl_bridging", ssl_bridging)
        _setter("sticky_sessions", sticky_sessions)
        _setter("sticky_sessions_cookie_name", sticky_sessions_cookie_name)
        _setter("timeout_connect", timeout_connect)
        _setter("timeout_server", timeout_server)
        _setter("timeout_tunnel", timeout_tunnel)
        _setter("update_at", update_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date at which the backend was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="failoverHost")
    def failover_host(self) -> str:
        """
        Scaleway S3 bucket website to be served in case all backend servers are down.
        """
        return pulumi.get(self, "failover_host")

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> int:
        """
        User sessions will be forwarded to this port of backend servers.
        """
        return pulumi.get(self, "forward_port")

    @property
    @pulumi.getter(name="forwardPortAlgorithm")
    def forward_port_algorithm(self) -> str:
        """
        Load balancing algorithm.
        """
        return pulumi.get(self, "forward_port_algorithm")

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> str:
        """
        Backend protocol.
        """
        return pulumi.get(self, "forward_protocol")

    @property
    @pulumi.getter(name="healthCheckDelay")
    def health_check_delay(self) -> str:
        """
        Interval between two HC requests.
        """
        return pulumi.get(self, "health_check_delay")

    @property
    @pulumi.getter(name="healthCheckHttp")
    def health_check_http(self) -> Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult']:
        """
        This block enable HTTP health check.
        """
        return pulumi.get(self, "health_check_http")

    @property
    @pulumi.getter(name="healthCheckHttps")
    def health_check_https(self) -> Sequence['outputs.GetLbBackendsBackendHealthCheckHttpResult']:
        """
        This block enable HTTPS health check.
        """
        return pulumi.get(self, "health_check_https")

    @property
    @pulumi.getter(name="healthCheckMaxRetries")
    def health_check_max_retries(self) -> int:
        """
        Number of allowed failed HC requests before the backend server is marked down.
        """
        return pulumi.get(self, "health_check_max_retries")

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> int:
        """
        Port the HC requests will be sent to.
        """
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter(name="healthCheckTcps")
    def health_check_tcps(self) -> Sequence['outputs.GetLbBackendsBackendHealthCheckTcpResult']:
        """
        This block enable TCP health check.
        """
        return pulumi.get(self, "health_check_tcps")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> str:
        """
        Timeout before we consider a HC request failed.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated backend ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ignoreSslServerVerify")
    def ignore_ssl_server_verify(self) -> bool:
        """
        Specifies whether the Load Balancer should check the backend server’s certificate before initiating a connection.
        """
        return pulumi.get(self, "ignore_ssl_server_verify")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The load-balancer ID this backend is attached to. backends with a LB ID like it are listed.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The backend name used as filter. Backends with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="onMarkedDownAction")
    def on_marked_down_action(self) -> str:
        """
        Modify what occurs when a backend server is marked down.
        """
        return pulumi.get(self, "on_marked_down_action")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> str:
        """
        The type of PROXY protocol.
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter(name="serverIps")
    def server_ips(self) -> Sequence[str]:
        """
        List of backend server IP addresses.
        """
        return pulumi.get(self, "server_ips")

    @property
    @pulumi.getter(name="sslBridging")
    def ssl_bridging(self) -> bool:
        """
        Enables SSL between load balancer and backend servers.
        """
        return pulumi.get(self, "ssl_bridging")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> str:
        """
        Enables cookie-based session persistence.
        """
        return pulumi.get(self, "sticky_sessions")

    @property
    @pulumi.getter(name="stickySessionsCookieName")
    def sticky_sessions_cookie_name(self) -> str:
        """
        Cookie name for sticky sessions.
        """
        return pulumi.get(self, "sticky_sessions_cookie_name")

    @property
    @pulumi.getter(name="timeoutConnect")
    def timeout_connect(self) -> str:
        """
        Maximum initial server connection establishment time.
        """
        return pulumi.get(self, "timeout_connect")

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> str:
        """
        Maximum server connection inactivity time.
        """
        return pulumi.get(self, "timeout_server")

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> str:
        """
        Maximum tunnel inactivity time.
        """
        return pulumi.get(self, "timeout_tunnel")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date at which the backend was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbBackendsBackendHealthCheckHttpResult(dict):
    def __init__(__self__, *,
                 code: int,
                 host_header: str,
                 method: str,
                 sni: str,
                 uri: str):
        """
        :param int code: The expected HTTP status code.
        :param str host_header: The HTTP host header to use for HC requests.
        :param str method: The HTTP method to use for HC requests.
        :param str sni: The SNI to use for HC requests over SSL.
        :param str uri: The HTTPS endpoint URL to call for HC requests.
        """
        GetLbBackendsBackendHealthCheckHttpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            host_header=host_header,
            method=method,
            sni=sni,
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: int,
             host_header: str,
             method: str,
             sni: str,
             uri: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostHeader' in kwargs:
            host_header = kwargs['hostHeader']

        _setter("code", code)
        _setter("host_header", host_header)
        _setter("method", method)
        _setter("sni", sni)
        _setter("uri", uri)

    @property
    @pulumi.getter
    def code(self) -> int:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> str:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @property
    @pulumi.getter
    def method(self) -> str:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def sni(self) -> str:
        """
        The SNI to use for HC requests over SSL.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetLbBackendsBackendHealthCheckTcpResult(dict):
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        pass



@pulumi.output_type
class GetLbCertificateCustomCertificateResult(dict):
    def __init__(__self__, *,
                 certificate_chain: str):
        GetLbCertificateCustomCertificateResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> str:
        return pulumi.get(self, "certificate_chain")


@pulumi.output_type
class GetLbCertificateLetsencryptResult(dict):
    def __init__(__self__, *,
                 common_name: str,
                 subject_alternative_names: Sequence[str]):
        GetLbCertificateLetsencryptResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            common_name=common_name,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             common_name: str,
             subject_alternative_names: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'commonName' in kwargs:
            common_name = kwargs['commonName']
        if 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("common_name", common_name)
        _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> str:
        return pulumi.get(self, "common_name")

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Sequence[str]:
        return pulumi.get(self, "subject_alternative_names")


@pulumi.output_type
class GetLbFrontendAclResult(dict):
    def __init__(__self__, *,
                 actions: Sequence['outputs.GetLbFrontendAclActionResult'],
                 created_at: str,
                 description: str,
                 matches: Sequence['outputs.GetLbFrontendAclMatchResult'],
                 name: str,
                 updated_at: str):
        """
        :param str name: The name of the frontend.
               - When using the `name` you should specify the `lb-id`
        """
        GetLbFrontendAclResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            created_at=created_at,
            description=description,
            matches=matches,
            name=name,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: Sequence['outputs.GetLbFrontendAclActionResult'],
             created_at: str,
             description: str,
             matches: Sequence['outputs.GetLbFrontendAclMatchResult'],
             name: str,
             updated_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("actions", actions)
        _setter("created_at", created_at)
        _setter("description", description)
        _setter("matches", matches)
        _setter("name", name)
        _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def actions(self) -> Sequence['outputs.GetLbFrontendAclActionResult']:
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def matches(self) -> Sequence['outputs.GetLbFrontendAclMatchResult']:
        return pulumi.get(self, "matches")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the frontend.
        - When using the `name` you should specify the `lb-id`
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetLbFrontendAclActionResult(dict):
    def __init__(__self__, *,
                 redirects: Sequence['outputs.GetLbFrontendAclActionRedirectResult'],
                 type: str):
        GetLbFrontendAclActionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            redirects=redirects,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             redirects: Sequence['outputs.GetLbFrontendAclActionRedirectResult'],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("redirects", redirects)
        _setter("type", type)

    @property
    @pulumi.getter
    def redirects(self) -> Sequence['outputs.GetLbFrontendAclActionRedirectResult']:
        return pulumi.get(self, "redirects")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbFrontendAclActionRedirectResult(dict):
    def __init__(__self__, *,
                 code: int,
                 target: str,
                 type: str):
        GetLbFrontendAclActionRedirectResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: int,
             target: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("code", code)
        _setter("target", target)
        _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> int:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLbFrontendAclMatchResult(dict):
    def __init__(__self__, *,
                 http_filter: str,
                 http_filter_option: str,
                 http_filter_values: Sequence[str],
                 invert: bool,
                 ip_subnets: Sequence[str]):
        GetLbFrontendAclMatchResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_filter=http_filter,
            http_filter_option=http_filter_option,
            http_filter_values=http_filter_values,
            invert=invert,
            ip_subnets=ip_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_filter: str,
             http_filter_option: str,
             http_filter_values: Sequence[str],
             invert: bool,
             ip_subnets: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpFilter' in kwargs:
            http_filter = kwargs['httpFilter']
        if 'httpFilterOption' in kwargs:
            http_filter_option = kwargs['httpFilterOption']
        if 'httpFilterValues' in kwargs:
            http_filter_values = kwargs['httpFilterValues']
        if 'ipSubnets' in kwargs:
            ip_subnets = kwargs['ipSubnets']

        _setter("http_filter", http_filter)
        _setter("http_filter_option", http_filter_option)
        _setter("http_filter_values", http_filter_values)
        _setter("invert", invert)
        _setter("ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> str:
        return pulumi.get(self, "http_filter")

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> str:
        return pulumi.get(self, "http_filter_option")

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Sequence[str]:
        return pulumi.get(self, "http_filter_values")

    @property
    @pulumi.getter
    def invert(self) -> bool:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Sequence[str]:
        return pulumi.get(self, "ip_subnets")


@pulumi.output_type
class GetLbFrontendsFrontendResult(dict):
    def __init__(__self__, *,
                 backend_id: str,
                 certificate_ids: Sequence[str],
                 created_at: str,
                 enable_http3: bool,
                 id: str,
                 inbound_port: int,
                 lb_id: str,
                 name: str,
                 timeout_client: str,
                 update_at: str):
        """
        :param str backend_id: The load-balancer backend ID this frontend is attached to.
               > **Important:** LB backends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param Sequence[str] certificate_ids: List of Certificate IDs that are used by the frontend.
        :param str created_at: The date at which the frontend was created (RFC 3339 format).
        :param bool enable_http3: If HTTP/3 protocol is activated.
        :param str id: The associated frontend ID.
               > **Important:** LB frontends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        :param int inbound_port: TCP port the frontend listen to.
        :param str lb_id: The load-balancer ID this frontend is attached to. frontends with a LB ID like it are listed.
        :param str name: The frontend name used as filter. Frontends with a name like it are listed.
        :param str timeout_client: Maximum inactivity time on the client side.
        :param str update_at: The date at which the frontend was last updated (RFC 3339 format).
        """
        GetLbFrontendsFrontendResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_id=backend_id,
            certificate_ids=certificate_ids,
            created_at=created_at,
            enable_http3=enable_http3,
            id=id,
            inbound_port=inbound_port,
            lb_id=lb_id,
            name=name,
            timeout_client=timeout_client,
            update_at=update_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_id: str,
             certificate_ids: Sequence[str],
             created_at: str,
             enable_http3: bool,
             id: str,
             inbound_port: int,
             lb_id: str,
             name: str,
             timeout_client: str,
             update_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'backendId' in kwargs:
            backend_id = kwargs['backendId']
        if 'certificateIds' in kwargs:
            certificate_ids = kwargs['certificateIds']
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'enableHttp3' in kwargs:
            enable_http3 = kwargs['enableHttp3']
        if 'inboundPort' in kwargs:
            inbound_port = kwargs['inboundPort']
        if 'lbId' in kwargs:
            lb_id = kwargs['lbId']
        if 'timeoutClient' in kwargs:
            timeout_client = kwargs['timeoutClient']
        if 'updateAt' in kwargs:
            update_at = kwargs['updateAt']

        _setter("backend_id", backend_id)
        _setter("certificate_ids", certificate_ids)
        _setter("created_at", created_at)
        _setter("enable_http3", enable_http3)
        _setter("id", id)
        _setter("inbound_port", inbound_port)
        _setter("lb_id", lb_id)
        _setter("name", name)
        _setter("timeout_client", timeout_client)
        _setter("update_at", update_at)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> str:
        """
        The load-balancer backend ID this frontend is attached to.
        > **Important:** LB backends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "backend_id")

    @property
    @pulumi.getter(name="certificateIds")
    def certificate_ids(self) -> Sequence[str]:
        """
        List of Certificate IDs that are used by the frontend.
        """
        return pulumi.get(self, "certificate_ids")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date at which the frontend was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="enableHttp3")
    def enable_http3(self) -> bool:
        """
        If HTTP/3 protocol is activated.
        """
        return pulumi.get(self, "enable_http3")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated frontend ID.
        > **Important:** LB frontends' IDs are zoned, which means they are of the form `{zone}/{id}`, e.g. `fr-par-1/11111111-1111-1111-1111-111111111111`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="inboundPort")
    def inbound_port(self) -> int:
        """
        TCP port the frontend listen to.
        """
        return pulumi.get(self, "inbound_port")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The load-balancer ID this frontend is attached to. frontends with a LB ID like it are listed.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The frontend name used as filter. Frontends with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="timeoutClient")
    def timeout_client(self) -> str:
        """
        Maximum inactivity time on the client side.
        """
        return pulumi.get(self, "timeout_client")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date at which the frontend was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbIpsIpResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_address: str,
                 lb_id: str,
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 zone: str):
        """
        :param str id: The associated IP ID.
        :param str ip_address: The IP Address
        :param str lb_id: The associated load-balancer ID if any
        :param str organization_id: The organization ID the load-balancer is associated with.
        :param str project_id: The ID of the project the load-balancer is associated with.
        :param str reverse: The reverse domain associated with this IP.
        :param str zone: `zone`) The zone in which IPs exist.
        """
        GetLbIpsIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ip_address=ip_address,
            lb_id=lb_id,
            organization_id=organization_id,
            project_id=project_id,
            reverse=reverse,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             ip_address: str,
             lb_id: str,
             organization_id: str,
             project_id: str,
             reverse: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if 'lbId' in kwargs:
            lb_id = kwargs['lbId']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("lb_id", lb_id)
        _setter("organization_id", organization_id)
        _setter("project_id", project_id)
        _setter("reverse", reverse)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated IP ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP Address
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        """
        The associated load-balancer ID if any
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID the load-balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the project the load-balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        """
        The reverse domain associated with this IP.
        """
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which IPs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 dhcp_config: bool,
                 private_network_id: str,
                 static_configs: Sequence[str],
                 status: str,
                 zone: str):
        """
        :param str zone: (Defaults to provider `zone`) The zone in which the LB exists.
        """
        GetLbPrivateNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dhcp_config=dhcp_config,
            private_network_id=private_network_id,
            static_configs=static_configs,
            status=status,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dhcp_config: bool,
             private_network_id: str,
             static_configs: Sequence[str],
             status: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dhcpConfig' in kwargs:
            dhcp_config = kwargs['dhcpConfig']
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'staticConfigs' in kwargs:
            static_configs = kwargs['staticConfigs']

        _setter("dhcp_config", dhcp_config)
        _setter("private_network_id", private_network_id)
        _setter("static_configs", static_configs)
        _setter("status", status)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="dhcpConfig")
    def dhcp_config(self) -> bool:
        return pulumi.get(self, "dhcp_config")

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter(name="staticConfigs")
    def static_configs(self) -> Sequence[str]:
        return pulumi.get(self, "static_configs")

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        (Defaults to provider `zone`) The zone in which the LB exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbRoutesRouteResult(dict):
    def __init__(__self__, *,
                 backend_id: str,
                 created_at: str,
                 frontend_id: str,
                 id: str,
                 match_host_header: str,
                 match_sni: str,
                 update_at: str):
        """
        :param str backend_id: The backend ID destination of redirection
        :param str created_at: The date at which the route was created (RFC 3339 format).
        :param str frontend_id: The frontend ID origin of redirection used as a filter. routes with a frontend ID like it are listed.
        :param str id: The associated route ID.
        :param str match_host_header: Specifies the host of the server to which the request is being sent.
        :param str match_sni: Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
        :param str update_at: The date at which the route was last updated (RFC 3339 format).
        """
        GetLbRoutesRouteResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_id=backend_id,
            created_at=created_at,
            frontend_id=frontend_id,
            id=id,
            match_host_header=match_host_header,
            match_sni=match_sni,
            update_at=update_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_id: str,
             created_at: str,
             frontend_id: str,
             id: str,
             match_host_header: str,
             match_sni: str,
             update_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'backendId' in kwargs:
            backend_id = kwargs['backendId']
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'frontendId' in kwargs:
            frontend_id = kwargs['frontendId']
        if 'matchHostHeader' in kwargs:
            match_host_header = kwargs['matchHostHeader']
        if 'matchSni' in kwargs:
            match_sni = kwargs['matchSni']
        if 'updateAt' in kwargs:
            update_at = kwargs['updateAt']

        _setter("backend_id", backend_id)
        _setter("created_at", created_at)
        _setter("frontend_id", frontend_id)
        _setter("id", id)
        _setter("match_host_header", match_host_header)
        _setter("match_sni", match_sni)
        _setter("update_at", update_at)

    @property
    @pulumi.getter(name="backendId")
    def backend_id(self) -> str:
        """
        The backend ID destination of redirection
        """
        return pulumi.get(self, "backend_id")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        The date at which the route was created (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter(name="frontendId")
    def frontend_id(self) -> str:
        """
        The frontend ID origin of redirection used as a filter. routes with a frontend ID like it are listed.
        """
        return pulumi.get(self, "frontend_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated route ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="matchHostHeader")
    def match_host_header(self) -> str:
        """
        Specifies the host of the server to which the request is being sent.
        """
        return pulumi.get(self, "match_host_header")

    @property
    @pulumi.getter(name="matchSni")
    def match_sni(self) -> str:
        """
        Server Name Indication TLS extension field from an incoming connection made via an SSL/TLS transport layer.
        """
        return pulumi.get(self, "match_sni")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        """
        The date at which the route was last updated (RFC 3339 format).
        """
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetLbsLbResult(dict):
    def __init__(__self__, *,
                 backend_count: int,
                 created_at: str,
                 description: str,
                 frontend_count: int,
                 id: str,
                 instances: Sequence['outputs.GetLbsLbInstanceResult'],
                 ips: Sequence['outputs.GetLbsLbIpResult'],
                 name: str,
                 organization_id: str,
                 private_network_count: int,
                 project_id: str,
                 route_count: int,
                 ssl_compatibility_level: str,
                 status: str,
                 subscriber: str,
                 tags: Sequence[str],
                 type: str,
                 updated_at: str,
                 zone: str):
        """
        :param int backend_count: Number of backends the Load balancer has.
        :param str created_at: Date at which the Load balancer was created.
        :param str description: The description of the load-balancer.
        :param int frontend_count: Number of frontends the Load balancer has.
        :param str id: The ID of the load-balancer.
        :param Sequence['GetLbsLbInstanceArgs'] instances: List of underlying instances.
        :param Sequence['GetLbsLbIpArgs'] ips: List of IPs attached to the Load balancer.
        :param str name: The load balancer name used as a filter. LBs with a name like it are listed.
        :param str organization_id: The organization ID the load-balancer is associated with.
        :param int private_network_count: Number of private networks attached to the Load balancer.
        :param str project_id: The ID of the project the load-balancer is associated with.
        :param int route_count: Number of routes the Load balancer has.
        :param str ssl_compatibility_level: Determines the minimal SSL version which needs to be supported on client side.
        :param str status: The state of the LB's instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        :param str subscriber: The subscriber information.
        :param Sequence[str] tags: The tags associated with the load-balancer.
        :param str type: The offer type of the load-balancer.
        :param str updated_at: Date at which the Load balancer was updated.
        :param str zone: `zone`) The zone in which LBs exist.
        """
        GetLbsLbResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            backend_count=backend_count,
            created_at=created_at,
            description=description,
            frontend_count=frontend_count,
            id=id,
            instances=instances,
            ips=ips,
            name=name,
            organization_id=organization_id,
            private_network_count=private_network_count,
            project_id=project_id,
            route_count=route_count,
            ssl_compatibility_level=ssl_compatibility_level,
            status=status,
            subscriber=subscriber,
            tags=tags,
            type=type,
            updated_at=updated_at,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             backend_count: int,
             created_at: str,
             description: str,
             frontend_count: int,
             id: str,
             instances: Sequence['outputs.GetLbsLbInstanceResult'],
             ips: Sequence['outputs.GetLbsLbIpResult'],
             name: str,
             organization_id: str,
             private_network_count: int,
             project_id: str,
             route_count: int,
             ssl_compatibility_level: str,
             status: str,
             subscriber: str,
             tags: Sequence[str],
             type: str,
             updated_at: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'backendCount' in kwargs:
            backend_count = kwargs['backendCount']
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'frontendCount' in kwargs:
            frontend_count = kwargs['frontendCount']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'privateNetworkCount' in kwargs:
            private_network_count = kwargs['privateNetworkCount']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if 'routeCount' in kwargs:
            route_count = kwargs['routeCount']
        if 'sslCompatibilityLevel' in kwargs:
            ssl_compatibility_level = kwargs['sslCompatibilityLevel']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("backend_count", backend_count)
        _setter("created_at", created_at)
        _setter("description", description)
        _setter("frontend_count", frontend_count)
        _setter("id", id)
        _setter("instances", instances)
        _setter("ips", ips)
        _setter("name", name)
        _setter("organization_id", organization_id)
        _setter("private_network_count", private_network_count)
        _setter("project_id", project_id)
        _setter("route_count", route_count)
        _setter("ssl_compatibility_level", ssl_compatibility_level)
        _setter("status", status)
        _setter("subscriber", subscriber)
        _setter("tags", tags)
        _setter("type", type)
        _setter("updated_at", updated_at)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="backendCount")
    def backend_count(self) -> int:
        """
        Number of backends the Load balancer has.
        """
        return pulumi.get(self, "backend_count")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date at which the Load balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the load-balancer.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="frontendCount")
    def frontend_count(self) -> int:
        """
        Number of frontends the Load balancer has.
        """
        return pulumi.get(self, "frontend_count")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the load-balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.GetLbsLbInstanceResult']:
        """
        List of underlying instances.
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.GetLbsLbIpResult']:
        """
        List of IPs attached to the Load balancer.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The load balancer name used as a filter. LBs with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID the load-balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="privateNetworkCount")
    def private_network_count(self) -> int:
        """
        Number of private networks attached to the Load balancer.
        """
        return pulumi.get(self, "private_network_count")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the project the load-balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="routeCount")
    def route_count(self) -> int:
        """
        Number of routes the Load balancer has.
        """
        return pulumi.get(self, "route_count")

    @property
    @pulumi.getter(name="sslCompatibilityLevel")
    def ssl_compatibility_level(self) -> str:
        """
        Determines the minimal SSL version which needs to be supported on client side.
        """
        return pulumi.get(self, "ssl_compatibility_level")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the LB's instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def subscriber(self) -> str:
        """
        The subscriber information.
        """
        return pulumi.get(self, "subscriber")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        The tags associated with the load-balancer.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The offer type of the load-balancer.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Date at which the Load balancer was updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which LBs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbsLbInstanceResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 ip_address: str,
                 status: str,
                 updated_at: str,
                 zone: str):
        """
        :param str created_at: Date at which the Load balancer was created.
        :param str id: The ID of the load-balancer.
        :param str status: The state of the LB's instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        :param str updated_at: Date at which the Load balancer was updated.
        :param str zone: `zone`) The zone in which LBs exist.
        """
        GetLbsLbInstanceResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            id=id,
            ip_address=ip_address,
            status=status,
            updated_at=updated_at,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             id: str,
             ip_address: str,
             status: str,
             updated_at: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("created_at", created_at)
        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("status", status)
        _setter("updated_at", updated_at)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date at which the Load balancer was created.
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the load-balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The state of the LB's instance. Possible values are: `unknown`, `ready`, `pending`, `stopped`, `error`, `locked` and `migrating`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        """
        Date at which the Load balancer was updated.
        """
        return pulumi.get(self, "updated_at")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which LBs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetLbsLbIpResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ip_address: str,
                 lb_id: str,
                 organization_id: str,
                 project_id: str,
                 reverse: str,
                 zone: str):
        """
        :param str id: The ID of the load-balancer.
        :param str organization_id: The organization ID the load-balancer is associated with.
        :param str project_id: The ID of the project the load-balancer is associated with.
        :param str zone: `zone`) The zone in which LBs exist.
        """
        GetLbsLbIpResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ip_address=ip_address,
            lb_id=lb_id,
            organization_id=organization_id,
            project_id=project_id,
            reverse=reverse,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             ip_address: str,
             lb_id: str,
             organization_id: str,
             project_id: str,
             reverse: str,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipAddress' in kwargs:
            ip_address = kwargs['ipAddress']
        if 'lbId' in kwargs:
            lb_id = kwargs['lbId']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("id", id)
        _setter("ip_address", ip_address)
        _setter("lb_id", lb_id)
        _setter("organization_id", organization_id)
        _setter("project_id", project_id)
        _setter("reverse", reverse)
        _setter("zone", zone)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the load-balancer.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> str:
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID the load-balancer is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the project the load-balancer is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def reverse(self) -> str:
        return pulumi.get(self, "reverse")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `zone`) The zone in which LBs exist.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetObjectBucketCorsRuleResult(dict):
    def __init__(__self__, *,
                 allowed_headers: Sequence[str],
                 allowed_methods: Sequence[str],
                 allowed_origins: Sequence[str],
                 expose_headers: Sequence[str],
                 max_age_seconds: int):
        GetObjectBucketCorsRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_headers=allowed_headers,
            allowed_methods=allowed_methods,
            allowed_origins=allowed_origins,
            expose_headers=expose_headers,
            max_age_seconds=max_age_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_headers: Sequence[str],
             allowed_methods: Sequence[str],
             allowed_origins: Sequence[str],
             expose_headers: Sequence[str],
             max_age_seconds: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedHeaders' in kwargs:
            allowed_headers = kwargs['allowedHeaders']
        if 'allowedMethods' in kwargs:
            allowed_methods = kwargs['allowedMethods']
        if 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if 'maxAgeSeconds' in kwargs:
            max_age_seconds = kwargs['maxAgeSeconds']

        _setter("allowed_headers", allowed_headers)
        _setter("allowed_methods", allowed_methods)
        _setter("allowed_origins", allowed_origins)
        _setter("expose_headers", expose_headers)
        _setter("max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_headers")

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_methods")

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[str]:
        return pulumi.get(self, "allowed_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Sequence[str]:
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> int:
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class GetObjectBucketLifecycleRuleResult(dict):
    def __init__(__self__, *,
                 abort_incomplete_multipart_upload_days: int,
                 enabled: bool,
                 expirations: Sequence['outputs.GetObjectBucketLifecycleRuleExpirationResult'],
                 id: str,
                 prefix: str,
                 tags: Mapping[str, str],
                 transitions: Sequence['outputs.GetObjectBucketLifecycleRuleTransitionResult']):
        """
        :param str id: The unique name of the bucket.
        """
        GetObjectBucketLifecycleRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            abort_incomplete_multipart_upload_days=abort_incomplete_multipart_upload_days,
            enabled=enabled,
            expirations=expirations,
            id=id,
            prefix=prefix,
            tags=tags,
            transitions=transitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             abort_incomplete_multipart_upload_days: int,
             enabled: bool,
             expirations: Sequence['outputs.GetObjectBucketLifecycleRuleExpirationResult'],
             id: str,
             prefix: str,
             tags: Mapping[str, str],
             transitions: Sequence['outputs.GetObjectBucketLifecycleRuleTransitionResult'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'abortIncompleteMultipartUploadDays' in kwargs:
            abort_incomplete_multipart_upload_days = kwargs['abortIncompleteMultipartUploadDays']

        _setter("abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        _setter("enabled", enabled)
        _setter("expirations", expirations)
        _setter("id", id)
        _setter("prefix", prefix)
        _setter("tags", tags)
        _setter("transitions", transitions)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> int:
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expirations(self) -> Sequence['outputs.GetObjectBucketLifecycleRuleExpirationResult']:
        return pulumi.get(self, "expirations")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The unique name of the bucket.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def prefix(self) -> str:
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def transitions(self) -> Sequence['outputs.GetObjectBucketLifecycleRuleTransitionResult']:
        return pulumi.get(self, "transitions")


@pulumi.output_type
class GetObjectBucketLifecycleRuleExpirationResult(dict):
    def __init__(__self__, *,
                 days: int):
        GetObjectBucketLifecycleRuleExpirationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("days", days)

    @property
    @pulumi.getter
    def days(self) -> int:
        return pulumi.get(self, "days")


@pulumi.output_type
class GetObjectBucketLifecycleRuleTransitionResult(dict):
    def __init__(__self__, *,
                 days: int,
                 storage_class: str):
        GetObjectBucketLifecycleRuleTransitionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: int,
             storage_class: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'storageClass' in kwargs:
            storage_class = kwargs['storageClass']

        _setter("days", days)
        _setter("storage_class", storage_class)

    @property
    @pulumi.getter
    def days(self) -> int:
        return pulumi.get(self, "days")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class GetObjectBucketVersioningResult(dict):
    def __init__(__self__, *,
                 enabled: bool):
        GetObjectBucketVersioningResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetRdbAclAclRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 ip: str):
        """
        :param str description: A simple text describing this rule
        :param str ip: The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        GetRdbAclAclRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             ip: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("description", description)
        _setter("ip", ip)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        A simple text describing this rule
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetRdbInstanceLoadBalancerResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 hostname: str,
                 ip: str,
                 name: str,
                 port: int):
        """
        :param str name: The name of the RDB instance.
               Only one of `name` and `instance_id` should be specified.
        """
        GetRdbInstanceLoadBalancerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             hostname: str,
             ip: str,
             name: str,
             port: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        _setter("endpoint_id", endpoint_id)
        _setter("hostname", hostname)
        _setter("ip", ip)
        _setter("name", name)
        _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDB instance.
        Only one of `name` and `instance_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRdbInstancePrivateNetworkResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 hostname: str,
                 ip: str,
                 ip_net: str,
                 name: str,
                 pn_id: str,
                 port: int,
                 zone: str):
        """
        :param str name: The name of the RDB instance.
               Only one of `name` and `instance_id` should be specified.
        """
        GetRdbInstancePrivateNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            ip_net=ip_net,
            name=name,
            pn_id=pn_id,
            port=port,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             hostname: str,
             ip: str,
             ip_net: str,
             name: str,
             pn_id: str,
             port: int,
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'ipNet' in kwargs:
            ip_net = kwargs['ipNet']
        if 'pnId' in kwargs:
            pn_id = kwargs['pnId']

        _setter("endpoint_id", endpoint_id)
        _setter("hostname", hostname)
        _setter("ip", ip)
        _setter("ip_net", ip_net)
        _setter("name", name)
        _setter("pn_id", pn_id)
        _setter("port", port)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def hostname(self) -> str:
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="ipNet")
    def ip_net(self) -> str:
        return pulumi.get(self, "ip_net")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDB instance.
        Only one of `name` and `instance_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> str:
        return pulumi.get(self, "pn_id")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def zone(self) -> str:
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetRdbInstanceReadReplicaResult(dict):
    def __init__(__self__, *,
                 ip: str,
                 name: str,
                 port: int):
        """
        :param str name: The name of the RDB instance.
               Only one of `name` and `instance_id` should be specified.
        """
        GetRdbInstanceReadReplicaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             name: str,
             port: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        _setter("name", name)
        _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the RDB instance.
        Only one of `name` and `instance_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetRedisClusterAclResult(dict):
    def __init__(__self__, *,
                 description: str,
                 id: str,
                 ip: str):
        """
        :param str id: The ID of the Redis cluster.
        """
        GetRedisClusterAclResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            id=id,
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             id: str,
             ip: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("description", description)
        _setter("id", id)
        _setter("ip", ip)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Redis cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> str:
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetRedisClusterPrivateNetworkResult(dict):
    def __init__(__self__, *,
                 endpoint_id: str,
                 id: str,
                 service_ips: Sequence[str],
                 zone: str):
        """
        :param str id: The ID of the Redis cluster.
        :param str zone: `region`) The zone in which the server exists.
        """
        GetRedisClusterPrivateNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            id=id,
            service_ips=service_ips,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: str,
             id: str,
             service_ips: Sequence[str],
             zone: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIps' in kwargs:
            service_ips = kwargs['serviceIps']

        _setter("endpoint_id", endpoint_id)
        _setter("id", id)
        _setter("service_ips", service_ips)
        _setter("zone", zone)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> str:
        return pulumi.get(self, "endpoint_id")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Redis cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Sequence[str]:
        return pulumi.get(self, "service_ips")

    @property
    @pulumi.getter
    def zone(self) -> str:
        """
        `region`) The zone in which the server exists.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetRedisClusterPublicNetworkResult(dict):
    def __init__(__self__, *,
                 id: str,
                 ips: Sequence[str],
                 port: int):
        """
        :param str id: The ID of the Redis cluster.
        """
        GetRedisClusterPublicNetworkResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ips=ips,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             ips: Sequence[str],
             port: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("id", id)
        _setter("ips", ips)
        _setter("port", port)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the Redis cluster.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ips(self) -> Sequence[str]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class GetVpcGatewayNetworkIpamConfigResult(dict):
    def __init__(__self__, *,
                 push_default_route: bool):
        GetVpcGatewayNetworkIpamConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            push_default_route=push_default_route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             push_default_route: bool,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pushDefaultRoute' in kwargs:
            push_default_route = kwargs['pushDefaultRoute']

        _setter("push_default_route", push_default_route)

    @property
    @pulumi.getter(name="pushDefaultRoute")
    def push_default_route(self) -> bool:
        return pulumi.get(self, "push_default_route")


@pulumi.output_type
class GetVpcPrivateNetworkIpv4SubnetResult(dict):
    def __init__(__self__, *,
                 address: str,
                 created_at: str,
                 id: str,
                 prefix_length: int,
                 subnet: str,
                 subnet_mask: str,
                 updated_at: str):
        """
        :param str id: The ID of the private network.
        """
        GetVpcPrivateNetworkIpv4SubnetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            created_at=created_at,
            id=id,
            prefix_length=prefix_length,
            subnet=subnet,
            subnet_mask=subnet_mask,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             created_at: str,
             id: str,
             prefix_length: int,
             subnet: str,
             subnet_mask: str,
             updated_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'prefixLength' in kwargs:
            prefix_length = kwargs['prefixLength']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("address", address)
        _setter("created_at", created_at)
        _setter("id", id)
        _setter("prefix_length", prefix_length)
        _setter("subnet", subnet)
        _setter("subnet_mask", subnet_mask)
        _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the private network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> str:
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetVpcPrivateNetworkIpv6SubnetResult(dict):
    def __init__(__self__, *,
                 address: str,
                 created_at: str,
                 id: str,
                 prefix_length: int,
                 subnet: str,
                 subnet_mask: str,
                 updated_at: str):
        """
        :param str id: The ID of the private network.
        """
        GetVpcPrivateNetworkIpv6SubnetResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            created_at=created_at,
            id=id,
            prefix_length=prefix_length,
            subnet=subnet,
            subnet_mask=subnet_mask,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: str,
             created_at: str,
             id: str,
             prefix_length: int,
             subnet: str,
             subnet_mask: str,
             updated_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'prefixLength' in kwargs:
            prefix_length = kwargs['prefixLength']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("address", address)
        _setter("created_at", created_at)
        _setter("id", id)
        _setter("prefix_length", prefix_length)
        _setter("subnet", subnet)
        _setter("subnet_mask", subnet_mask)
        _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the private network.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> int:
        return pulumi.get(self, "prefix_length")

    @property
    @pulumi.getter
    def subnet(self) -> str:
        return pulumi.get(self, "subnet")

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> str:
        return pulumi.get(self, "subnet_mask")

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> str:
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetVpcsVpcResult(dict):
    def __init__(__self__, *,
                 created_at: str,
                 id: str,
                 is_default: bool,
                 name: str,
                 organization_id: str,
                 project_id: str,
                 region: str,
                 tags: Sequence[str],
                 update_at: str):
        """
        :param str created_at: Date and time of VPC's creation (RFC 3339 format).
        :param str id: The associated VPC ID.
               > **Important:** VPCs' IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
        :param bool is_default: Defines whether the VPC is the default one for its Project.
        :param str name: The VPC name used as filter. VPCs with a name like it are listed.
        :param str organization_id: The organization ID the VPC is associated with.
        :param str project_id: The ID of the project the VPC is associated with.
        :param str region: `region`). The region in which vpcs exist.
        :param Sequence[str] tags: List of tags used as filter. VPCs with these exact tags are listed.
        """
        GetVpcsVpcResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created_at=created_at,
            id=id,
            is_default=is_default,
            name=name,
            organization_id=organization_id,
            project_id=project_id,
            region=region,
            tags=tags,
            update_at=update_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created_at: str,
             id: str,
             is_default: bool,
             name: str,
             organization_id: str,
             project_id: str,
             region: str,
             tags: Sequence[str],
             update_at: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'isDefault' in kwargs:
            is_default = kwargs['isDefault']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']
        if 'updateAt' in kwargs:
            update_at = kwargs['updateAt']

        _setter("created_at", created_at)
        _setter("id", id)
        _setter("is_default", is_default)
        _setter("name", name)
        _setter("organization_id", organization_id)
        _setter("project_id", project_id)
        _setter("region", region)
        _setter("tags", tags)
        _setter("update_at", update_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> str:
        """
        Date and time of VPC's creation (RFC 3339 format).
        """
        return pulumi.get(self, "created_at")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The associated VPC ID.
        > **Important:** VPCs' IDs are regional, which means they are of the form `{region}/{id}`, e.g. `fr-par/11111111-1111-1111-1111-111111111111
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> bool:
        """
        Defines whether the VPC is the default one for its Project.
        """
        return pulumi.get(self, "is_default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The VPC name used as filter. VPCs with a name like it are listed.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> str:
        """
        The organization ID the VPC is associated with.
        """
        return pulumi.get(self, "organization_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        The ID of the project the VPC is associated with.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        """
        `region`). The region in which vpcs exist.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        List of tags used as filter. VPCs with these exact tags are listed.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updateAt")
    def update_at(self) -> str:
        return pulumi.get(self, "update_at")


@pulumi.output_type
class GetWebHostOfferProductResult(dict):
    def __init__(__self__, *,
                 databases_quota: int,
                 email_accounts_quota: int,
                 email_storage_quota: int,
                 hosting_storage_quota: int,
                 name: str,
                 option: bool,
                 ram: int,
                 support_included: bool,
                 v_cpu: int):
        """
        :param int databases_quota: The quota of databases.
        :param int email_accounts_quota: The quota of email accounts.
        :param int email_storage_quota: The quota of email storage.
        :param int hosting_storage_quota: The quota of hosting storage.
        :param str name: The offer name. Only one of `name` and `offer_id` should be specified.
        :param bool option: The product option.
        :param int ram: The capacity of the memory in GB.
        :param bool support_included: If support is included.
        :param int v_cpu: The number of cores.
        """
        GetWebHostOfferProductResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            databases_quota=databases_quota,
            email_accounts_quota=email_accounts_quota,
            email_storage_quota=email_storage_quota,
            hosting_storage_quota=hosting_storage_quota,
            name=name,
            option=option,
            ram=ram,
            support_included=support_included,
            v_cpu=v_cpu,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             databases_quota: int,
             email_accounts_quota: int,
             email_storage_quota: int,
             hosting_storage_quota: int,
             name: str,
             option: bool,
             ram: int,
             support_included: bool,
             v_cpu: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'databasesQuota' in kwargs:
            databases_quota = kwargs['databasesQuota']
        if 'emailAccountsQuota' in kwargs:
            email_accounts_quota = kwargs['emailAccountsQuota']
        if 'emailStorageQuota' in kwargs:
            email_storage_quota = kwargs['emailStorageQuota']
        if 'hostingStorageQuota' in kwargs:
            hosting_storage_quota = kwargs['hostingStorageQuota']
        if 'supportIncluded' in kwargs:
            support_included = kwargs['supportIncluded']
        if 'vCpu' in kwargs:
            v_cpu = kwargs['vCpu']

        _setter("databases_quota", databases_quota)
        _setter("email_accounts_quota", email_accounts_quota)
        _setter("email_storage_quota", email_storage_quota)
        _setter("hosting_storage_quota", hosting_storage_quota)
        _setter("name", name)
        _setter("option", option)
        _setter("ram", ram)
        _setter("support_included", support_included)
        _setter("v_cpu", v_cpu)

    @property
    @pulumi.getter(name="databasesQuota")
    def databases_quota(self) -> int:
        """
        The quota of databases.
        """
        return pulumi.get(self, "databases_quota")

    @property
    @pulumi.getter(name="emailAccountsQuota")
    def email_accounts_quota(self) -> int:
        """
        The quota of email accounts.
        """
        return pulumi.get(self, "email_accounts_quota")

    @property
    @pulumi.getter(name="emailStorageQuota")
    def email_storage_quota(self) -> int:
        """
        The quota of email storage.
        """
        return pulumi.get(self, "email_storage_quota")

    @property
    @pulumi.getter(name="hostingStorageQuota")
    def hosting_storage_quota(self) -> int:
        """
        The quota of hosting storage.
        """
        return pulumi.get(self, "hosting_storage_quota")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The offer name. Only one of `name` and `offer_id` should be specified.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def option(self) -> bool:
        """
        The product option.
        """
        return pulumi.get(self, "option")

    @property
    @pulumi.getter
    def ram(self) -> int:
        """
        The capacity of the memory in GB.
        """
        return pulumi.get(self, "ram")

    @property
    @pulumi.getter(name="supportIncluded")
    def support_included(self) -> bool:
        """
        If support is included.
        """
        return pulumi.get(self, "support_included")

    @property
    @pulumi.getter(name="vCpu")
    def v_cpu(self) -> int:
        """
        The number of cores.
        """
        return pulumi.get(self, "v_cpu")


@pulumi.output_type
class GetWebhostingCpanelUrlResult(dict):
    def __init__(__self__, *,
                 dashboard: str,
                 webmail: str):
        GetWebhostingCpanelUrlResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard=dashboard,
            webmail=webmail,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard: str,
             webmail: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("dashboard", dashboard)
        _setter("webmail", webmail)

    @property
    @pulumi.getter
    def dashboard(self) -> str:
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter
    def webmail(self) -> str:
        return pulumi.get(self, "webmail")


@pulumi.output_type
class GetWebhostingOptionResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str):
        GetWebhostingOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


