# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'BaremetalServerIpArgs',
    'BaremetalServerIpv4Args',
    'BaremetalServerIpv6Args',
    'BaremetalServerOptionArgs',
    'BaremetalServerPrivateNetworkArgs',
    'CockpitEndpointArgs',
    'CockpitTokenScopesArgs',
    'ContainerTriggerNatsArgs',
    'ContainerTriggerSqsArgs',
    'DocumentDBReadReplicaDirectAccessArgs',
    'DocumentDBReadReplicaPrivateNetworkArgs',
    'DomainRecordGeoIpArgs',
    'DomainRecordGeoIpMatchArgs',
    'DomainRecordHttpServiceArgs',
    'DomainRecordViewArgs',
    'DomainRecordWeightedArgs',
    'FunctionTriggerNatsArgs',
    'FunctionTriggerSqsArgs',
    'IamPolicyRuleArgs',
    'InstanceImageAdditionalVolumeArgs',
    'InstanceSecurityGroupInboundRuleArgs',
    'InstanceSecurityGroupOutboundRuleArgs',
    'InstanceSecurityGroupRulesInboundRuleArgs',
    'InstanceSecurityGroupRulesOutboundRuleArgs',
    'InstanceServerPrivateNetworkArgs',
    'InstanceServerPublicIpArgs',
    'InstanceServerRootVolumeArgs',
    'InstanceSnapshotImportArgs',
    'IotDeviceCertificateArgs',
    'IotDeviceMessageFiltersArgs',
    'IotDeviceMessageFiltersPublishArgs',
    'IotDeviceMessageFiltersSubscribeArgs',
    'IotRouteDatabaseArgs',
    'IotRouteRestArgs',
    'IotRouteS3Args',
    'K8sClusterAutoUpgradeArgs',
    'K8sClusterAutoscalerConfigArgs',
    'K8sClusterKubeconfigArgs',
    'K8sClusterOpenIdConnectConfigArgs',
    'K8sPoolNodeArgs',
    'K8sPoolUpgradePolicyArgs',
    'LbAclActionArgs',
    'LbAclActionRedirectArgs',
    'LbAclMatchArgs',
    'LbBackendHealthCheckHttpArgs',
    'LbBackendHealthCheckHttpsArgs',
    'LbBackendHealthCheckTcpArgs',
    'LbCertificateCustomCertificateArgs',
    'LbCertificateLetsencryptArgs',
    'LbFrontendAclArgs',
    'LbFrontendAclActionArgs',
    'LbFrontendAclActionRedirectArgs',
    'LbFrontendAclMatchArgs',
    'LbPrivateNetworkArgs',
    'MnqCredentialNatsCredentialsArgs',
    'MnqCredentialSqsSnsCredentialsArgs',
    'MnqCredentialSqsSnsCredentialsPermissionsArgs',
    'MnqQueueNatsArgs',
    'MnqQueueSqsArgs',
    'MnqSqsCredentialsPermissionsArgs',
    'ObjectBucketAclAccessControlPolicyArgs',
    'ObjectBucketAclAccessControlPolicyGrantArgs',
    'ObjectBucketAclAccessControlPolicyGrantGranteeArgs',
    'ObjectBucketAclAccessControlPolicyOwnerArgs',
    'ObjectBucketCorsRuleArgs',
    'ObjectBucketLifecycleRuleArgs',
    'ObjectBucketLifecycleRuleExpirationArgs',
    'ObjectBucketLifecycleRuleTransitionArgs',
    'ObjectBucketLockConfigurationRuleArgs',
    'ObjectBucketLockConfigurationRuleDefaultRetentionArgs',
    'ObjectBucketVersioningArgs',
    'ObjectBucketWebsiteConfigurationErrorDocumentArgs',
    'ObjectBucketWebsiteConfigurationIndexDocumentArgs',
    'RdbAclAclRuleArgs',
    'RdbInstanceLoadBalancerArgs',
    'RdbInstancePrivateNetworkArgs',
    'RdbInstanceReadReplicaArgs',
    'RdbReadReplicaDirectAccessArgs',
    'RdbReadReplicaPrivateNetworkArgs',
    'RedisClusterAclArgs',
    'RedisClusterPrivateNetworkArgs',
    'RedisClusterPublicNetworkArgs',
    'VpcGatewayNetworkIpamConfigArgs',
    'VpcPrivateNetworkIpv4SubnetArgs',
    'VpcPrivateNetworkIpv6SubnetArgs',
    'WebHostingCpanelUrlArgs',
    'WebHostingOptionArgs',
    'GetIpamIpResourceArgs',
]

@pulumi.input_type
class BaremetalServerIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 reverse: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address of the IPv6.
        :param pulumi.Input[str] id: The id of the private network to attach.
        :param pulumi.Input[str] reverse: The reverse of the IPv6.
        :param pulumi.Input[str] version: The type of the IPv6.
        """
        BaremetalServerIpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             reverse: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)
        if reverse is not None:
            _setter("reverse", reverse)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def reverse(self) -> Optional[pulumi.Input[str]]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @reverse.setter
    def reverse(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reverse", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class BaremetalServerIpv4Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 reverse: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address of the IPv6.
        :param pulumi.Input[str] id: The id of the private network to attach.
        :param pulumi.Input[str] reverse: The reverse of the IPv6.
        :param pulumi.Input[str] version: The type of the IPv6.
        """
        BaremetalServerIpv4Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             reverse: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)
        if reverse is not None:
            _setter("reverse", reverse)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def reverse(self) -> Optional[pulumi.Input[str]]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @reverse.setter
    def reverse(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reverse", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class BaremetalServerIpv6Args:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 reverse: Optional[pulumi.Input[str]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address of the IPv6.
        :param pulumi.Input[str] id: The id of the private network to attach.
        :param pulumi.Input[str] reverse: The reverse of the IPv6.
        :param pulumi.Input[str] version: The type of the IPv6.
        """
        BaremetalServerIpv6Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
            reverse=reverse,
            version=version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             reverse: Optional[pulumi.Input[str]] = None,
             version: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)
        if reverse is not None:
            _setter("reverse", reverse)
        if version is not None:
            _setter("version", version)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the IPv6.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def reverse(self) -> Optional[pulumi.Input[str]]:
        """
        The reverse of the IPv6.
        """
        return pulumi.get(self, "reverse")

    @reverse.setter
    def reverse(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reverse", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the IPv6.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


@pulumi.input_type
class BaremetalServerOptionArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 expires_at: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The id of the private network to attach.
        :param pulumi.Input[str] expires_at: The auto expiration date for compatible options
        :param pulumi.Input[str] name: The name of the server.
        """
        BaremetalServerOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            expires_at=expires_at,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             expires_at: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'expiresAt' in kwargs:
            expires_at = kwargs['expiresAt']

        _setter("id", id)
        if expires_at is not None:
            _setter("expires_at", expires_at)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        The auto expiration date for compatible options
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class BaremetalServerPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None,
                 vlan: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: The id of the private network to attach.
        :param pulumi.Input[str] created_at: The date and time of the creation of the private network.
        :param pulumi.Input[str] status: The private network status.
        :param pulumi.Input[str] updated_at: The date and time of the last update of the private network.
        :param pulumi.Input[int] vlan: The VLAN ID associated to the private network.
        """
        BaremetalServerPrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            created_at=created_at,
            status=status,
            updated_at=updated_at,
            vlan=vlan,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             created_at: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             updated_at: Optional[pulumi.Input[str]] = None,
             vlan: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("id", id)
        if created_at is not None:
            _setter("created_at", created_at)
        if status is not None:
            _setter("status", status)
        if updated_at is not None:
            _setter("updated_at", updated_at)
        if vlan is not None:
            _setter("vlan", vlan)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The id of the private network to attach.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time of the creation of the private network.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The private network status.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time of the last update of the private network.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)

    @property
    @pulumi.getter
    def vlan(self) -> Optional[pulumi.Input[int]]:
        """
        The VLAN ID associated to the private network.
        """
        return pulumi.get(self, "vlan")

    @vlan.setter
    def vlan(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "vlan", value)


@pulumi.input_type
class CockpitEndpointArgs:
    def __init__(__self__, *,
                 alertmanager_url: Optional[pulumi.Input[str]] = None,
                 grafana_url: Optional[pulumi.Input[str]] = None,
                 logs_url: Optional[pulumi.Input[str]] = None,
                 metrics_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] alertmanager_url: The alertmanager URL
        :param pulumi.Input[str] grafana_url: The grafana URL
        :param pulumi.Input[str] logs_url: The logs URL
        :param pulumi.Input[str] metrics_url: The metrics URL
        """
        CockpitEndpointArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alertmanager_url=alertmanager_url,
            grafana_url=grafana_url,
            logs_url=logs_url,
            metrics_url=metrics_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alertmanager_url: Optional[pulumi.Input[str]] = None,
             grafana_url: Optional[pulumi.Input[str]] = None,
             logs_url: Optional[pulumi.Input[str]] = None,
             metrics_url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'alertmanagerUrl' in kwargs:
            alertmanager_url = kwargs['alertmanagerUrl']
        if 'grafanaUrl' in kwargs:
            grafana_url = kwargs['grafanaUrl']
        if 'logsUrl' in kwargs:
            logs_url = kwargs['logsUrl']
        if 'metricsUrl' in kwargs:
            metrics_url = kwargs['metricsUrl']

        if alertmanager_url is not None:
            _setter("alertmanager_url", alertmanager_url)
        if grafana_url is not None:
            _setter("grafana_url", grafana_url)
        if logs_url is not None:
            _setter("logs_url", logs_url)
        if metrics_url is not None:
            _setter("metrics_url", metrics_url)

    @property
    @pulumi.getter(name="alertmanagerUrl")
    def alertmanager_url(self) -> Optional[pulumi.Input[str]]:
        """
        The alertmanager URL
        """
        return pulumi.get(self, "alertmanager_url")

    @alertmanager_url.setter
    def alertmanager_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "alertmanager_url", value)

    @property
    @pulumi.getter(name="grafanaUrl")
    def grafana_url(self) -> Optional[pulumi.Input[str]]:
        """
        The grafana URL
        """
        return pulumi.get(self, "grafana_url")

    @grafana_url.setter
    def grafana_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "grafana_url", value)

    @property
    @pulumi.getter(name="logsUrl")
    def logs_url(self) -> Optional[pulumi.Input[str]]:
        """
        The logs URL
        """
        return pulumi.get(self, "logs_url")

    @logs_url.setter
    def logs_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logs_url", value)

    @property
    @pulumi.getter(name="metricsUrl")
    def metrics_url(self) -> Optional[pulumi.Input[str]]:
        """
        The metrics URL
        """
        return pulumi.get(self, "metrics_url")

    @metrics_url.setter
    def metrics_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metrics_url", value)


@pulumi.input_type
class CockpitTokenScopesArgs:
    def __init__(__self__, *,
                 query_logs: Optional[pulumi.Input[bool]] = None,
                 query_metrics: Optional[pulumi.Input[bool]] = None,
                 setup_alerts: Optional[pulumi.Input[bool]] = None,
                 setup_logs_rules: Optional[pulumi.Input[bool]] = None,
                 setup_metrics_rules: Optional[pulumi.Input[bool]] = None,
                 write_logs: Optional[pulumi.Input[bool]] = None,
                 write_metrics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] query_logs: Query logs
        :param pulumi.Input[bool] query_metrics: Query metrics
        :param pulumi.Input[bool] setup_alerts: Setup alerts
        :param pulumi.Input[bool] setup_logs_rules: Setup logs rules
        :param pulumi.Input[bool] setup_metrics_rules: Setup metrics rules
        :param pulumi.Input[bool] write_logs: Write logs
        :param pulumi.Input[bool] write_metrics: Write metrics
        """
        CockpitTokenScopesArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_logs=query_logs,
            query_metrics=query_metrics,
            setup_alerts=setup_alerts,
            setup_logs_rules=setup_logs_rules,
            setup_metrics_rules=setup_metrics_rules,
            write_logs=write_logs,
            write_metrics=write_metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_logs: Optional[pulumi.Input[bool]] = None,
             query_metrics: Optional[pulumi.Input[bool]] = None,
             setup_alerts: Optional[pulumi.Input[bool]] = None,
             setup_logs_rules: Optional[pulumi.Input[bool]] = None,
             setup_metrics_rules: Optional[pulumi.Input[bool]] = None,
             write_logs: Optional[pulumi.Input[bool]] = None,
             write_metrics: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'queryLogs' in kwargs:
            query_logs = kwargs['queryLogs']
        if 'queryMetrics' in kwargs:
            query_metrics = kwargs['queryMetrics']
        if 'setupAlerts' in kwargs:
            setup_alerts = kwargs['setupAlerts']
        if 'setupLogsRules' in kwargs:
            setup_logs_rules = kwargs['setupLogsRules']
        if 'setupMetricsRules' in kwargs:
            setup_metrics_rules = kwargs['setupMetricsRules']
        if 'writeLogs' in kwargs:
            write_logs = kwargs['writeLogs']
        if 'writeMetrics' in kwargs:
            write_metrics = kwargs['writeMetrics']

        if query_logs is not None:
            _setter("query_logs", query_logs)
        if query_metrics is not None:
            _setter("query_metrics", query_metrics)
        if setup_alerts is not None:
            _setter("setup_alerts", setup_alerts)
        if setup_logs_rules is not None:
            _setter("setup_logs_rules", setup_logs_rules)
        if setup_metrics_rules is not None:
            _setter("setup_metrics_rules", setup_metrics_rules)
        if write_logs is not None:
            _setter("write_logs", write_logs)
        if write_metrics is not None:
            _setter("write_metrics", write_metrics)

    @property
    @pulumi.getter(name="queryLogs")
    def query_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Query logs
        """
        return pulumi.get(self, "query_logs")

    @query_logs.setter
    def query_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "query_logs", value)

    @property
    @pulumi.getter(name="queryMetrics")
    def query_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        Query metrics
        """
        return pulumi.get(self, "query_metrics")

    @query_metrics.setter
    def query_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "query_metrics", value)

    @property
    @pulumi.getter(name="setupAlerts")
    def setup_alerts(self) -> Optional[pulumi.Input[bool]]:
        """
        Setup alerts
        """
        return pulumi.get(self, "setup_alerts")

    @setup_alerts.setter
    def setup_alerts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "setup_alerts", value)

    @property
    @pulumi.getter(name="setupLogsRules")
    def setup_logs_rules(self) -> Optional[pulumi.Input[bool]]:
        """
        Setup logs rules
        """
        return pulumi.get(self, "setup_logs_rules")

    @setup_logs_rules.setter
    def setup_logs_rules(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "setup_logs_rules", value)

    @property
    @pulumi.getter(name="setupMetricsRules")
    def setup_metrics_rules(self) -> Optional[pulumi.Input[bool]]:
        """
        Setup metrics rules
        """
        return pulumi.get(self, "setup_metrics_rules")

    @setup_metrics_rules.setter
    def setup_metrics_rules(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "setup_metrics_rules", value)

    @property
    @pulumi.getter(name="writeLogs")
    def write_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Write logs
        """
        return pulumi.get(self, "write_logs")

    @write_logs.setter
    def write_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_logs", value)

    @property
    @pulumi.getter(name="writeMetrics")
    def write_metrics(self) -> Optional[pulumi.Input[bool]]:
        """
        Write metrics
        """
        return pulumi.get(self, "write_metrics")

    @write_metrics.setter
    def write_metrics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "write_metrics", value)


@pulumi.input_type
class ContainerTriggerNatsArgs:
    def __init__(__self__, *,
                 subject: pulumi.Input[str],
                 account_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subject: The subject to listen to
        :param pulumi.Input[str] account_id: ID of the mnq nats account.
        :param pulumi.Input[str] project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param pulumi.Input[str] region: `region`). The region in which the namespace should be created.
        """
        ContainerTriggerNatsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject=subject,
            account_id=account_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject: pulumi.Input[str],
             account_id: Optional[pulumi.Input[str]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("subject", subject)
        if account_id is not None:
            _setter("account_id", account_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[str]:
        """
        The subject to listen to
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the mnq nats account.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class ContainerTriggerSqsArgs:
    def __init__(__self__, *,
                 queue: pulumi.Input[str],
                 namespace_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] queue: Name of the queue
        :param pulumi.Input[str] namespace_id: ID of the mnq namespace. Deprecated.
        :param pulumi.Input[str] project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param pulumi.Input[str] region: `region`). The region in which the namespace should be created.
        """
        ContainerTriggerSqsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue=queue,
            namespace_id=namespace_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue: pulumi.Input[str],
             namespace_id: Optional[pulumi.Input[str]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("queue", queue)
        if namespace_id is not None:
            _setter("namespace_id", namespace_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def queue(self) -> pulumi.Input[str]:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the mnq namespace. Deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class DocumentDBReadReplicaDirectAccessArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint of the read replica.
        :param pulumi.Input[str] hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param pulumi.Input[str] ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param pulumi.Input[str] name: Name of the endpoint.
        :param pulumi.Input[int] port: TCP port of the endpoint.
        """
        DocumentDBReadReplicaDirectAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class DocumentDBReadReplicaPrivateNetworkArgs:
    def __init__(__self__, *,
                 private_network_id: pulumi.Input[str],
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 service_ip: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_network_id: UUID of the private network to be connected to the read replica.
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint of the read replica.
        :param pulumi.Input[str] hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param pulumi.Input[str] ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param pulumi.Input[str] name: Name of the endpoint.
        :param pulumi.Input[int] port: TCP port of the endpoint.
        :param pulumi.Input[str] service_ip: The IP network address within the private subnet. This must be an IPv4 address with a
               CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
               service if not set.
        """
        DocumentDBReadReplicaPrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_network_id=private_network_id,
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
            service_ip=service_ip,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_network_id: pulumi.Input[str],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             service_ip: Optional[pulumi.Input[str]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIp' in kwargs:
            service_ip = kwargs['serviceIp']

        _setter("private_network_id", private_network_id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)
        if service_ip is not None:
            _setter("service_ip", service_ip)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[str]:
        """
        UUID of the private network to be connected to the read replica.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_network_id", value)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP network address within the private subnet. This must be an IPv4 address with a
        CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
        service if not set.
        """
        return pulumi.get(self, "service_ip")

    @service_ip.setter
    def service_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_ip", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class DomainRecordGeoIpArgs:
    def __init__(__self__, *,
                 matches: pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]] matches: The list of matches. *(Can be more than 1)*
        """
        DomainRecordGeoIpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matches=matches,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matches: pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("matches", matches)

    @property
    @pulumi.getter
    def matches(self) -> pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]]:
        """
        The list of matches. *(Can be more than 1)*
        """
        return pulumi.get(self, "matches")

    @matches.setter
    def matches(self, value: pulumi.Input[Sequence[pulumi.Input['DomainRecordGeoIpMatchArgs']]]):
        pulumi.set(self, "matches", value)


@pulumi.input_type
class DomainRecordGeoIpMatchArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[str],
                 continents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 countries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] data: The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] continents: List of continents (eg: `EU` for Europe, `NA` for North America, `AS` for Asia...). [List of all continents code](https://api.scaleway.com/domain-private/v2beta1/continents)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] countries: List of countries (eg: `FR` for France, `US` for the United States, `GB` for Great Britain...). [List of all countries code](https://api.scaleway.com/domain-private/v2beta1/countries)
        """
        DomainRecordGeoIpMatchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            continents=continents,
            countries=countries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: pulumi.Input[str],
             continents: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             countries: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("data", data)
        if continents is not None:
            _setter("continents", continents)
        if countries is not None:
            _setter("countries", countries)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input[str]:
        """
        The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[str]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def continents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of continents (eg: `EU` for Europe, `NA` for North America, `AS` for Asia...). [List of all continents code](https://api.scaleway.com/domain-private/v2beta1/continents)
        """
        return pulumi.get(self, "continents")

    @continents.setter
    def continents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "continents", value)

    @property
    @pulumi.getter
    def countries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of countries (eg: `FR` for France, `US` for the United States, `GB` for Great Britain...). [List of all countries code](https://api.scaleway.com/domain-private/v2beta1/countries)
        """
        return pulumi.get(self, "countries")

    @countries.setter
    def countries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "countries", value)


@pulumi.input_type
class DomainRecordHttpServiceArgs:
    def __init__(__self__, *,
                 ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 must_contain: pulumi.Input[str],
                 strategy: pulumi.Input[str],
                 url: pulumi.Input[str],
                 user_agent: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: List of IPs to check
        :param pulumi.Input[str] must_contain: Text to search
        :param pulumi.Input[str] strategy: Strategy to return an IP from the IPs list. Can be `random`, `hashed` or `all`
        :param pulumi.Input[str] url: URL to match the `must_contain` text to validate an IP
        :param pulumi.Input[str] user_agent: User-agent used when checking the URL
        """
        DomainRecordHttpServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ips=ips,
            must_contain=must_contain,
            strategy=strategy,
            url=url,
            user_agent=user_agent,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ips: pulumi.Input[Sequence[pulumi.Input[str]]],
             must_contain: pulumi.Input[str],
             strategy: pulumi.Input[str],
             url: pulumi.Input[str],
             user_agent: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mustContain' in kwargs:
            must_contain = kwargs['mustContain']
        if 'userAgent' in kwargs:
            user_agent = kwargs['userAgent']

        _setter("ips", ips)
        _setter("must_contain", must_contain)
        _setter("strategy", strategy)
        _setter("url", url)
        if user_agent is not None:
            _setter("user_agent", user_agent)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of IPs to check
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter(name="mustContain")
    def must_contain(self) -> pulumi.Input[str]:
        """
        Text to search
        """
        return pulumi.get(self, "must_contain")

    @must_contain.setter
    def must_contain(self, value: pulumi.Input[str]):
        pulumi.set(self, "must_contain", value)

    @property
    @pulumi.getter
    def strategy(self) -> pulumi.Input[str]:
        """
        Strategy to return an IP from the IPs list. Can be `random`, `hashed` or `all`
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL to match the `must_contain` text to validate an IP
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[str]]:
        """
        User-agent used when checking the URL
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_agent", value)


@pulumi.input_type
class DomainRecordViewArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[str],
                 subnet: pulumi.Input[str]):
        """
        :param pulumi.Input[str] data: The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        :param pulumi.Input[str] subnet: The subnet of the view
        """
        DomainRecordViewArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data=data,
            subnet=subnet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data: pulumi.Input[str],
             subnet: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("data", data)
        _setter("subnet", subnet)

    @property
    @pulumi.getter
    def data(self) -> pulumi.Input[str]:
        """
        The content of the record (an IPv4 for an `A`, a string for a `TXT`...).
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[str]):
        pulumi.set(self, "data", value)

    @property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[str]:
        """
        The subnet of the view
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet", value)


@pulumi.input_type
class DomainRecordWeightedArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 weight: pulumi.Input[int]):
        """
        :param pulumi.Input[str] ip: The weighted IP
        :param pulumi.Input[int] weight: The weight of the IP as an integer UInt32.
        """
        DomainRecordWeightedArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            weight=weight,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: pulumi.Input[str],
             weight: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        _setter("weight", weight)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The weighted IP
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def weight(self) -> pulumi.Input[int]:
        """
        The weight of the IP as an integer UInt32.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[int]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class FunctionTriggerNatsArgs:
    def __init__(__self__, *,
                 subject: pulumi.Input[str],
                 account_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] subject: The subject to listen to
        :param pulumi.Input[str] account_id: ID of the mnq nats account.
        :param pulumi.Input[str] project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param pulumi.Input[str] region: `region`). The region in which the namespace should be created.
        """
        FunctionTriggerNatsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subject=subject,
            account_id=account_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subject: pulumi.Input[str],
             account_id: Optional[pulumi.Input[str]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("subject", subject)
        if account_id is not None:
            _setter("account_id", account_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def subject(self) -> pulumi.Input[str]:
        """
        The subject to listen to
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the mnq nats account.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class FunctionTriggerSqsArgs:
    def __init__(__self__, *,
                 queue: pulumi.Input[str],
                 namespace_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] queue: Name of the queue
        :param pulumi.Input[str] namespace_id: ID of the mnq namespace. Deprecated.
        :param pulumi.Input[str] project_id: ID of the project that contain the mnq nats account, defaults to provider's project
        :param pulumi.Input[str] region: `region`). The region in which the namespace should be created.
        """
        FunctionTriggerSqsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queue=queue,
            namespace_id=namespace_id,
            project_id=project_id,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queue: pulumi.Input[str],
             namespace_id: Optional[pulumi.Input[str]] = None,
             project_id: Optional[pulumi.Input[str]] = None,
             region: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'namespaceId' in kwargs:
            namespace_id = kwargs['namespaceId']
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("queue", queue)
        if namespace_id is not None:
            _setter("namespace_id", namespace_id)
        if project_id is not None:
            _setter("project_id", project_id)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def queue(self) -> pulumi.Input[str]:
        """
        Name of the queue
        """
        return pulumi.get(self, "queue")

    @queue.setter
    def queue(self, value: pulumi.Input[str]):
        pulumi.set(self, "queue", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the mnq namespace. Deprecated.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the project that contain the mnq nats account, defaults to provider's project
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        `region`). The region in which the namespace should be created.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)


@pulumi.input_type
class IamPolicyRuleArgs:
    def __init__(__self__, *,
                 permission_set_names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 organization_id: Optional[pulumi.Input[str]] = None,
                 project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permission_set_names: Names of permission sets bound to the rule.
               
               **_TIP:_**  You can use the Scaleway CLI to list the permissions details. e.g:
        :param pulumi.Input[str] organization_id: ID of organization scoped to the rule.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] project_ids: List of project IDs scoped to the rule.
               
               > **Important** One of `organization_id` or `project_ids`  must be set per rule.
        """
        IamPolicyRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permission_set_names=permission_set_names,
            organization_id=organization_id,
            project_ids=project_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permission_set_names: pulumi.Input[Sequence[pulumi.Input[str]]],
             organization_id: Optional[pulumi.Input[str]] = None,
             project_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'permissionSetNames' in kwargs:
            permission_set_names = kwargs['permissionSetNames']
        if 'organizationId' in kwargs:
            organization_id = kwargs['organizationId']
        if 'projectIds' in kwargs:
            project_ids = kwargs['projectIds']

        _setter("permission_set_names", permission_set_names)
        if organization_id is not None:
            _setter("organization_id", organization_id)
        if project_ids is not None:
            _setter("project_ids", project_ids)

    @property
    @pulumi.getter(name="permissionSetNames")
    def permission_set_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Names of permission sets bound to the rule.

        **_TIP:_**  You can use the Scaleway CLI to list the permissions details. e.g:
        """
        return pulumi.get(self, "permission_set_names")

    @permission_set_names.setter
    def permission_set_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permission_set_names", value)

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of organization scoped to the rule.
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization_id", value)

    @property
    @pulumi.getter(name="projectIds")
    def project_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of project IDs scoped to the rule.

        > **Important** One of `organization_id` or `project_ids`  must be set per rule.
        """
        return pulumi.get(self, "project_ids")

    @project_ids.setter
    def project_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "project_ids", value)


@pulumi.input_type
class InstanceImageAdditionalVolumeArgs:
    def __init__(__self__, *,
                 creation_date: Optional[pulumi.Input[str]] = None,
                 export_uri: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 modification_date: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 organization: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 server: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 size: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] creation_date: Date of the volume creation.
        :param pulumi.Input[str] export_uri: The export URI of the volume.
        :param pulumi.Input[str] id: ID of the server containing the volume.
        :param pulumi.Input[str] modification_date: Date of volume latest update.
        :param pulumi.Input[str] name: The name of the image. If not provided it will be randomly generated.
        :param pulumi.Input[str] organization: The organization ID the volume is associated with.
        :param pulumi.Input[str] project: ID of the project the volume is associated with
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] server: Description of the server containing the volume (in case the image is a backup from a server).
        :param pulumi.Input[int] size: The size of the volume.
        :param pulumi.Input[str] state: State of the volume.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tags to apply to the image.
        :param pulumi.Input[str] volume_type: The type of volume, possible values are `l_ssd` and `b_ssd`.
        :param pulumi.Input[str] zone: The zone in which the image should be created.
        """
        InstanceImageAdditionalVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            creation_date=creation_date,
            export_uri=export_uri,
            id=id,
            modification_date=modification_date,
            name=name,
            organization=organization,
            project=project,
            server=server,
            size=size,
            state=state,
            tags=tags,
            volume_type=volume_type,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             creation_date: Optional[pulumi.Input[str]] = None,
             export_uri: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             modification_date: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             organization: Optional[pulumi.Input[str]] = None,
             project: Optional[pulumi.Input[str]] = None,
             server: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             size: Optional[pulumi.Input[int]] = None,
             state: Optional[pulumi.Input[str]] = None,
             tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'creationDate' in kwargs:
            creation_date = kwargs['creationDate']
        if 'exportUri' in kwargs:
            export_uri = kwargs['exportUri']
        if 'modificationDate' in kwargs:
            modification_date = kwargs['modificationDate']
        if 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if creation_date is not None:
            _setter("creation_date", creation_date)
        if export_uri is not None:
            _setter("export_uri", export_uri)
        if id is not None:
            _setter("id", id)
        if modification_date is not None:
            _setter("modification_date", modification_date)
        if name is not None:
            _setter("name", name)
        if organization is not None:
            _setter("organization", organization)
        if project is not None:
            _setter("project", project)
        if server is not None:
            _setter("server", server)
        if size is not None:
            _setter("size", size)
        if state is not None:
            _setter("state", state)
        if tags is not None:
            _setter("tags", tags)
        if volume_type is not None:
            _setter("volume_type", volume_type)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="creationDate")
    def creation_date(self) -> Optional[pulumi.Input[str]]:
        """
        Date of the volume creation.
        """
        return pulumi.get(self, "creation_date")

    @creation_date.setter
    def creation_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "creation_date", value)

    @property
    @pulumi.getter(name="exportUri")
    def export_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The export URI of the volume.
        """
        return pulumi.get(self, "export_uri")

    @export_uri.setter
    def export_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "export_uri", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the server containing the volume.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="modificationDate")
    def modification_date(self) -> Optional[pulumi.Input[str]]:
        """
        Date of volume latest update.
        """
        return pulumi.get(self, "modification_date")

    @modification_date.setter
    def modification_date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "modification_date", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the image. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def organization(self) -> Optional[pulumi.Input[str]]:
        """
        The organization ID the volume is associated with.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the project the volume is associated with
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Description of the server containing the volume (in case the image is a backup from a server).
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def size(self) -> Optional[pulumi.Input[int]]:
        """
        The size of the volume.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of the volume.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of tags to apply to the image.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of volume, possible values are `l_ssd` and `b_ssd`.
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        The zone in which the image should be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class InstanceSecurityGroupInboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 ip: Optional[pulumi.Input[str]] = None,
                 ip_range: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param pulumi.Input[str] ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[str] ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[int] port: The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        :param pulumi.Input[str] protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupInboundRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             ip: Optional[pulumi.Input[str]] = None,
             ip_range: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             port_range: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_range", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class InstanceSecurityGroupOutboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 ip: Optional[pulumi.Input[str]] = None,
                 ip_range: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param pulumi.Input[str] ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[str] ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[int] port: The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        :param pulumi.Input[str] protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupOutboundRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             ip: Optional[pulumi.Input[str]] = None,
             ip_range: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             port_range: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_range", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port this rule applies to. If no `port` nor `port_range` are specified, the rule will apply to all port. Only one of `port` and `port_range` should be specified.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class InstanceSecurityGroupRulesInboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 ip: Optional[pulumi.Input[str]] = None,
                 ip_range: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param pulumi.Input[str] ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[str] ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[int] port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param pulumi.Input[str] protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupRulesInboundRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             ip: Optional[pulumi.Input[str]] = None,
             ip_range: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             port_range: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_range", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class InstanceSecurityGroupRulesOutboundRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 ip: Optional[pulumi.Input[str]] = None,
                 ip_range: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 port_range: Optional[pulumi.Input[str]] = None,
                 protocol: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action to take when rule match. Possible values are: `accept` or `drop`.
        :param pulumi.Input[str] ip: The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[str] ip_range: The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        :param pulumi.Input[int] port: The port this rule apply to. If no port is specified, rule will apply to all port.
        :param pulumi.Input[str] protocol: The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        InstanceSecurityGroupRulesOutboundRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            ip=ip,
            ip_range=ip_range,
            port=port,
            port_range=port_range,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             ip: Optional[pulumi.Input[str]] = None,
             ip_range: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             port_range: Optional[pulumi.Input[str]] = None,
             protocol: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipRange' in kwargs:
            ip_range = kwargs['ipRange']
        if 'portRange' in kwargs:
            port_range = kwargs['portRange']

        _setter("action", action)
        if ip is not None:
            warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
            pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")
        if ip is not None:
            _setter("ip", ip)
        if ip_range is not None:
            _setter("ip_range", ip_range)
        if port is not None:
            _setter("port", port)
        if port_range is not None:
            _setter("port_range", port_range)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action to take when rule match. Possible values are: `accept` or `drop`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The ip this rule apply to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        warnings.warn("""Ip address is deprecated. Please use ip_range instead""", DeprecationWarning)
        pulumi.log.warn("""ip is deprecated: Ip address is deprecated. Please use ip_range instead""")

        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ip range (e.g `192.168.1.0/24`) this rule applies to. If no `ip` nor `ip_range` are specified, rule will apply to all ip. Only one of `ip` and `ip_range` should be specified.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_range", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port this rule apply to. If no port is specified, rule will apply to all port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol this rule apply to. Possible values are: `TCP`, `UDP`, `ICMP` or `ANY`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)


@pulumi.input_type
class InstanceServerPrivateNetworkArgs:
    def __init__(__self__, *,
                 pn_id: pulumi.Input[str],
                 mac_address: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] zone: `zone`) The zone in which the server should be created.
        """
        InstanceServerPrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pn_id=pn_id,
            mac_address=mac_address,
            status=status,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pn_id: pulumi.Input[str],
             mac_address: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pnId' in kwargs:
            pn_id = kwargs['pnId']
        if 'macAddress' in kwargs:
            mac_address = kwargs['macAddress']

        _setter("pn_id", pn_id)
        if mac_address is not None:
            _setter("mac_address", mac_address)
        if status is not None:
            _setter("status", status)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pn_id")

    @pn_id.setter
    def pn_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pn_id", value)

    @property
    @pulumi.getter(name="macAddress")
    def mac_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mac_address")

    @mac_address.setter
    def mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mac_address", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        `zone`) The zone in which the server should be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class InstanceServerPublicIpArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The address of the IP
        :param pulumi.Input[str] id: The ID of the IP
        """
        InstanceServerPublicIpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if address is not None:
            _setter("address", address)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The address of the IP
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the IP
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class InstanceServerRootVolumeArgs:
    def __init__(__self__, *,
                 boot: Optional[pulumi.Input[bool]] = None,
                 delete_on_termination: Optional[pulumi.Input[bool]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 size_in_gb: Optional[pulumi.Input[int]] = None,
                 volume_id: Optional[pulumi.Input[str]] = None,
                 volume_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] delete_on_termination: Forces deletion of the root volume on instance termination.
               
               > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
        :param pulumi.Input[str] name: The name of the server.
        :param pulumi.Input[int] size_in_gb: Size of the root volume in gigabytes.
               To find the right size use [this endpoint](https://api.scaleway.com/instance/v1/zones/fr-par-1/products/servers) and
               check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
               Updates to this field will recreate a new resource.
        :param pulumi.Input[str] volume_id: The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        :param pulumi.Input[str] volume_type: Volume type of root volume, can be `b_ssd` or `l_ssd`, default value depends on server type
        """
        InstanceServerRootVolumeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            boot=boot,
            delete_on_termination=delete_on_termination,
            name=name,
            size_in_gb=size_in_gb,
            volume_id=volume_id,
            volume_type=volume_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             boot: Optional[pulumi.Input[bool]] = None,
             delete_on_termination: Optional[pulumi.Input[bool]] = None,
             name: Optional[pulumi.Input[str]] = None,
             size_in_gb: Optional[pulumi.Input[int]] = None,
             volume_id: Optional[pulumi.Input[str]] = None,
             volume_type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'deleteOnTermination' in kwargs:
            delete_on_termination = kwargs['deleteOnTermination']
        if 'sizeInGb' in kwargs:
            size_in_gb = kwargs['sizeInGb']
        if 'volumeId' in kwargs:
            volume_id = kwargs['volumeId']
        if 'volumeType' in kwargs:
            volume_type = kwargs['volumeType']

        if boot is not None:
            _setter("boot", boot)
        if delete_on_termination is not None:
            _setter("delete_on_termination", delete_on_termination)
        if name is not None:
            _setter("name", name)
        if size_in_gb is not None:
            _setter("size_in_gb", size_in_gb)
        if volume_id is not None:
            _setter("volume_id", volume_id)
        if volume_type is not None:
            _setter("volume_type", volume_type)

    @property
    @pulumi.getter
    def boot(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "boot")

    @boot.setter
    def boot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boot", value)

    @property
    @pulumi.getter(name="deleteOnTermination")
    def delete_on_termination(self) -> Optional[pulumi.Input[bool]]:
        """
        Forces deletion of the root volume on instance termination.

        > **Important:** Updates to `root_volume.size_in_gb` will be ignored after the creation of the server.
        """
        return pulumi.get(self, "delete_on_termination")

    @delete_on_termination.setter
    def delete_on_termination(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_on_termination", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the server.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sizeInGb")
    def size_in_gb(self) -> Optional[pulumi.Input[int]]:
        """
        Size of the root volume in gigabytes.
        To find the right size use [this endpoint](https://api.scaleway.com/instance/v1/zones/fr-par-1/products/servers) and
        check the `volumes_constraint.{min|max}_size` (in bytes) for your `commercial_type`.
        Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "size_in_gb")

    @size_in_gb.setter
    def size_in_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "size_in_gb", value)

    @property
    @pulumi.getter(name="volumeId")
    def volume_id(self) -> Optional[pulumi.Input[str]]:
        """
        The volume ID of the root volume of the server, allows you to create server with an existing volume. If empty, will be computed to a created volume ID.
        """
        return pulumi.get(self, "volume_id")

    @volume_id.setter
    def volume_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_id", value)

    @property
    @pulumi.getter(name="volumeType")
    def volume_type(self) -> Optional[pulumi.Input[str]]:
        """
        Volume type of root volume, can be `b_ssd` or `l_ssd`, default value depends on server type
        """
        return pulumi.get(self, "volume_type")

    @volume_type.setter
    def volume_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "volume_type", value)


@pulumi.input_type
class InstanceSnapshotImportArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] bucket: Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        :param pulumi.Input[str] key: Key of the object to import
               
               > **Note:** The type `unified` could be instantiated on both `l_ssd` and `b_ssd` volumes.
        """
        InstanceSnapshotImportArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: pulumi.Input[str],
             key: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("bucket", bucket)
        _setter("key", key)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Bucket name containing [qcow2](https://en.wikipedia.org/wiki/Qcow) to import
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key of the object to import

        > **Note:** The type `unified` could be instantiated on both `l_ssd` and `b_ssd` volumes.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class IotDeviceCertificateArgs:
    def __init__(__self__, *,
                 crt: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The private key of the device, in case it is generated by Scaleway.
        """
        IotDeviceCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            crt=crt,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             crt: Optional[pulumi.Input[str]] = None,
             key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if crt is not None:
            _setter("crt", crt)
        if key is not None:
            _setter("key", key)

    @property
    @pulumi.getter
    def crt(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "crt")

    @crt.setter
    def crt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "crt", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The private key of the device, in case it is generated by Scaleway.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class IotDeviceMessageFiltersArgs:
    def __init__(__self__, *,
                 publish: Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']] = None,
                 subscribe: Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']] = None):
        """
        :param pulumi.Input['IotDeviceMessageFiltersPublishArgs'] publish: Rules used to restrict topics the device can publish to.
        :param pulumi.Input['IotDeviceMessageFiltersSubscribeArgs'] subscribe: Rules used to restrict topics the device can subscribe to.
        """
        IotDeviceMessageFiltersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            publish=publish,
            subscribe=subscribe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             publish: Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']] = None,
             subscribe: Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if publish is not None:
            _setter("publish", publish)
        if subscribe is not None:
            _setter("subscribe", subscribe)

    @property
    @pulumi.getter
    def publish(self) -> Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']]:
        """
        Rules used to restrict topics the device can publish to.
        """
        return pulumi.get(self, "publish")

    @publish.setter
    def publish(self, value: Optional[pulumi.Input['IotDeviceMessageFiltersPublishArgs']]):
        pulumi.set(self, "publish", value)

    @property
    @pulumi.getter
    def subscribe(self) -> Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']]:
        """
        Rules used to restrict topics the device can subscribe to.
        """
        return pulumi.get(self, "subscribe")

    @subscribe.setter
    def subscribe(self, value: Optional[pulumi.Input['IotDeviceMessageFiltersSubscribeArgs']]):
        pulumi.set(self, "subscribe", value)


@pulumi.input_type
class IotDeviceMessageFiltersPublishArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[str]] = None,
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] policy: Same as publish rules.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics: Same as publish rules.
               
               - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
               
               > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        IotDeviceMessageFiltersPublishArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            topics=topics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[pulumi.Input[str]] = None,
             topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if policy is not None:
            _setter("policy", policy)
        if topics is not None:
            _setter("topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Same as publish rules.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topics", value)


@pulumi.input_type
class IotDeviceMessageFiltersSubscribeArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[str]] = None,
                 topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] policy: Same as publish rules.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] topics: Same as publish rules.
               
               - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.
               
               > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        IotDeviceMessageFiltersSubscribeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
            topics=topics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[pulumi.Input[str]] = None,
             topics: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if policy is not None:
            _setter("policy", policy)
        if topics is not None:
            _setter("topics", topics)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Same as publish rules.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)

    @property
    @pulumi.getter
    def topics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Same as publish rules.

        - `certificate.crt` - (Optional) The certificate of the device, either generated by Scaleway or provided.

        > **Important:** Updates to `certificate.crt` will disconnect connected devices and the previous certificate will be deleted and won't be recoverable.
        """
        return pulumi.get(self, "topics")

    @topics.setter
    def topics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "topics", value)


@pulumi.input_type
class IotRouteDatabaseArgs:
    def __init__(__self__, *,
                 dbname: pulumi.Input[str],
                 host: pulumi.Input[str],
                 password: pulumi.Input[str],
                 port: pulumi.Input[int],
                 query: pulumi.Input[str],
                 username: pulumi.Input[str]):
        IotRouteDatabaseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dbname=dbname,
            host=host,
            password=password,
            port=port,
            query=query,
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dbname: pulumi.Input[str],
             host: pulumi.Input[str],
             password: pulumi.Input[str],
             port: pulumi.Input[int],
             query: pulumi.Input[str],
             username: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("dbname", dbname)
        _setter("host", host)
        _setter("password", password)
        _setter("port", port)
        _setter("query", query)
        _setter("username", username)

    @property
    @pulumi.getter
    def dbname(self) -> pulumi.Input[str]:
        return pulumi.get(self, "dbname")

    @dbname.setter
    def dbname(self, value: pulumi.Input[str]):
        pulumi.set(self, "dbname", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class IotRouteRestArgs:
    def __init__(__self__, *,
                 headers: pulumi.Input[Mapping[str, pulumi.Input[str]]],
                 uri: pulumi.Input[str],
                 verb: pulumi.Input[str]):
        IotRouteRestArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            headers=headers,
            uri=uri,
            verb=verb,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             headers: pulumi.Input[Mapping[str, pulumi.Input[str]]],
             uri: pulumi.Input[str],
             verb: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("headers", headers)
        _setter("uri", uri)
        _setter("verb", verb)

    @property
    @pulumi.getter
    def headers(self) -> pulumi.Input[Mapping[str, pulumi.Input[str]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: pulumi.Input[Mapping[str, pulumi.Input[str]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def verb(self) -> pulumi.Input[str]:
        return pulumi.get(self, "verb")

    @verb.setter
    def verb(self, value: pulumi.Input[str]):
        pulumi.set(self, "verb", value)


@pulumi.input_type
class IotRouteS3Args:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 bucket_region: pulumi.Input[str],
                 strategy: pulumi.Input[str],
                 object_prefix: Optional[pulumi.Input[str]] = None):
        IotRouteS3Args._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket_name=bucket_name,
            bucket_region=bucket_region,
            strategy=strategy,
            object_prefix=object_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket_name: pulumi.Input[str],
             bucket_region: pulumi.Input[str],
             strategy: pulumi.Input[str],
             object_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bucketName' in kwargs:
            bucket_name = kwargs['bucketName']
        if 'bucketRegion' in kwargs:
            bucket_region = kwargs['bucketRegion']
        if 'objectPrefix' in kwargs:
            object_prefix = kwargs['objectPrefix']

        _setter("bucket_name", bucket_name)
        _setter("bucket_region", bucket_region)
        _setter("strategy", strategy)
        if object_prefix is not None:
            _setter("object_prefix", object_prefix)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="bucketRegion")
    def bucket_region(self) -> pulumi.Input[str]:
        return pulumi.get(self, "bucket_region")

    @bucket_region.setter
    def bucket_region(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_region", value)

    @property
    @pulumi.getter
    def strategy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: pulumi.Input[str]):
        pulumi.set(self, "strategy", value)

    @property
    @pulumi.getter(name="objectPrefix")
    def object_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "object_prefix")

    @object_prefix.setter
    def object_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_prefix", value)


@pulumi.input_type
class K8sClusterAutoUpgradeArgs:
    def __init__(__self__, *,
                 enable: pulumi.Input[bool],
                 maintenance_window_day: pulumi.Input[str],
                 maintenance_window_start_hour: pulumi.Input[int]):
        """
        :param pulumi.Input[bool] enable: Set to `true` to enable Kubernetes patch version auto upgrades.
               > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        :param pulumi.Input[str] maintenance_window_day: The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        :param pulumi.Input[int] maintenance_window_start_hour: The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        K8sClusterAutoUpgradeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable=enable,
            maintenance_window_day=maintenance_window_day,
            maintenance_window_start_hour=maintenance_window_start_hour,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable: pulumi.Input[bool],
             maintenance_window_day: pulumi.Input[str],
             maintenance_window_start_hour: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maintenanceWindowDay' in kwargs:
            maintenance_window_day = kwargs['maintenanceWindowDay']
        if 'maintenanceWindowStartHour' in kwargs:
            maintenance_window_start_hour = kwargs['maintenanceWindowStartHour']

        _setter("enable", enable)
        _setter("maintenance_window_day", maintenance_window_day)
        _setter("maintenance_window_start_hour", maintenance_window_start_hour)

    @property
    @pulumi.getter
    def enable(self) -> pulumi.Input[bool]:
        """
        Set to `true` to enable Kubernetes patch version auto upgrades.
        > **Important:** When enabling auto upgrades, the `version` field take a minor version like x.y (ie 1.18).
        """
        return pulumi.get(self, "enable")

    @enable.setter
    def enable(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable", value)

    @property
    @pulumi.getter(name="maintenanceWindowDay")
    def maintenance_window_day(self) -> pulumi.Input[str]:
        """
        The day of the auto upgrade maintenance window (`monday` to `sunday`, or `any`).
        """
        return pulumi.get(self, "maintenance_window_day")

    @maintenance_window_day.setter
    def maintenance_window_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "maintenance_window_day", value)

    @property
    @pulumi.getter(name="maintenanceWindowStartHour")
    def maintenance_window_start_hour(self) -> pulumi.Input[int]:
        """
        The start hour (UTC) of the 2-hour auto upgrade maintenance window (0 to 23).
        """
        return pulumi.get(self, "maintenance_window_start_hour")

    @maintenance_window_start_hour.setter
    def maintenance_window_start_hour(self, value: pulumi.Input[int]):
        pulumi.set(self, "maintenance_window_start_hour", value)


@pulumi.input_type
class K8sClusterAutoscalerConfigArgs:
    def __init__(__self__, *,
                 balance_similar_node_groups: Optional[pulumi.Input[bool]] = None,
                 disable_scale_down: Optional[pulumi.Input[bool]] = None,
                 estimator: Optional[pulumi.Input[str]] = None,
                 expander: Optional[pulumi.Input[str]] = None,
                 expendable_pods_priority_cutoff: Optional[pulumi.Input[int]] = None,
                 ignore_daemonsets_utilization: Optional[pulumi.Input[bool]] = None,
                 max_graceful_termination_sec: Optional[pulumi.Input[int]] = None,
                 scale_down_delay_after_add: Optional[pulumi.Input[str]] = None,
                 scale_down_unneeded_time: Optional[pulumi.Input[str]] = None,
                 scale_down_utilization_threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[bool] balance_similar_node_groups: Detect similar node groups and balance the number of nodes between them.
        :param pulumi.Input[bool] disable_scale_down: Disables the scale down feature of the autoscaler.
        :param pulumi.Input[str] estimator: Type of resource estimator to be used in scale up.
        :param pulumi.Input[str] expander: Type of node group expander to be used in scale up.
        :param pulumi.Input[int] expendable_pods_priority_cutoff: Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        :param pulumi.Input[bool] ignore_daemonsets_utilization: Ignore DaemonSet pods when calculating resource utilization for scaling down.
        :param pulumi.Input[int] max_graceful_termination_sec: Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        :param pulumi.Input[str] scale_down_delay_after_add: How long after scale up that scale down evaluation resumes.
        :param pulumi.Input[str] scale_down_unneeded_time: How long a node should be unneeded before it is eligible for scale down.
        :param pulumi.Input[float] scale_down_utilization_threshold: Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        K8sClusterAutoscalerConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            balance_similar_node_groups=balance_similar_node_groups,
            disable_scale_down=disable_scale_down,
            estimator=estimator,
            expander=expander,
            expendable_pods_priority_cutoff=expendable_pods_priority_cutoff,
            ignore_daemonsets_utilization=ignore_daemonsets_utilization,
            max_graceful_termination_sec=max_graceful_termination_sec,
            scale_down_delay_after_add=scale_down_delay_after_add,
            scale_down_unneeded_time=scale_down_unneeded_time,
            scale_down_utilization_threshold=scale_down_utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             balance_similar_node_groups: Optional[pulumi.Input[bool]] = None,
             disable_scale_down: Optional[pulumi.Input[bool]] = None,
             estimator: Optional[pulumi.Input[str]] = None,
             expander: Optional[pulumi.Input[str]] = None,
             expendable_pods_priority_cutoff: Optional[pulumi.Input[int]] = None,
             ignore_daemonsets_utilization: Optional[pulumi.Input[bool]] = None,
             max_graceful_termination_sec: Optional[pulumi.Input[int]] = None,
             scale_down_delay_after_add: Optional[pulumi.Input[str]] = None,
             scale_down_unneeded_time: Optional[pulumi.Input[str]] = None,
             scale_down_utilization_threshold: Optional[pulumi.Input[float]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'balanceSimilarNodeGroups' in kwargs:
            balance_similar_node_groups = kwargs['balanceSimilarNodeGroups']
        if 'disableScaleDown' in kwargs:
            disable_scale_down = kwargs['disableScaleDown']
        if 'expendablePodsPriorityCutoff' in kwargs:
            expendable_pods_priority_cutoff = kwargs['expendablePodsPriorityCutoff']
        if 'ignoreDaemonsetsUtilization' in kwargs:
            ignore_daemonsets_utilization = kwargs['ignoreDaemonsetsUtilization']
        if 'maxGracefulTerminationSec' in kwargs:
            max_graceful_termination_sec = kwargs['maxGracefulTerminationSec']
        if 'scaleDownDelayAfterAdd' in kwargs:
            scale_down_delay_after_add = kwargs['scaleDownDelayAfterAdd']
        if 'scaleDownUnneededTime' in kwargs:
            scale_down_unneeded_time = kwargs['scaleDownUnneededTime']
        if 'scaleDownUtilizationThreshold' in kwargs:
            scale_down_utilization_threshold = kwargs['scaleDownUtilizationThreshold']

        if balance_similar_node_groups is not None:
            _setter("balance_similar_node_groups", balance_similar_node_groups)
        if disable_scale_down is not None:
            _setter("disable_scale_down", disable_scale_down)
        if estimator is not None:
            _setter("estimator", estimator)
        if expander is not None:
            _setter("expander", expander)
        if expendable_pods_priority_cutoff is not None:
            _setter("expendable_pods_priority_cutoff", expendable_pods_priority_cutoff)
        if ignore_daemonsets_utilization is not None:
            _setter("ignore_daemonsets_utilization", ignore_daemonsets_utilization)
        if max_graceful_termination_sec is not None:
            _setter("max_graceful_termination_sec", max_graceful_termination_sec)
        if scale_down_delay_after_add is not None:
            _setter("scale_down_delay_after_add", scale_down_delay_after_add)
        if scale_down_unneeded_time is not None:
            _setter("scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            _setter("scale_down_utilization_threshold", scale_down_utilization_threshold)

    @property
    @pulumi.getter(name="balanceSimilarNodeGroups")
    def balance_similar_node_groups(self) -> Optional[pulumi.Input[bool]]:
        """
        Detect similar node groups and balance the number of nodes between them.
        """
        return pulumi.get(self, "balance_similar_node_groups")

    @balance_similar_node_groups.setter
    def balance_similar_node_groups(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "balance_similar_node_groups", value)

    @property
    @pulumi.getter(name="disableScaleDown")
    def disable_scale_down(self) -> Optional[pulumi.Input[bool]]:
        """
        Disables the scale down feature of the autoscaler.
        """
        return pulumi.get(self, "disable_scale_down")

    @disable_scale_down.setter
    def disable_scale_down(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_scale_down", value)

    @property
    @pulumi.getter
    def estimator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of resource estimator to be used in scale up.
        """
        return pulumi.get(self, "estimator")

    @estimator.setter
    def estimator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "estimator", value)

    @property
    @pulumi.getter
    def expander(self) -> Optional[pulumi.Input[str]]:
        """
        Type of node group expander to be used in scale up.
        """
        return pulumi.get(self, "expander")

    @expander.setter
    def expander(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expander", value)

    @property
    @pulumi.getter(name="expendablePodsPriorityCutoff")
    def expendable_pods_priority_cutoff(self) -> Optional[pulumi.Input[int]]:
        """
        Pods with priority below cutoff will be expendable. They can be killed without any consideration during scale down and they don't cause scale up. Pods with null priority (PodPriority disabled) are non expendable.
        """
        return pulumi.get(self, "expendable_pods_priority_cutoff")

    @expendable_pods_priority_cutoff.setter
    def expendable_pods_priority_cutoff(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expendable_pods_priority_cutoff", value)

    @property
    @pulumi.getter(name="ignoreDaemonsetsUtilization")
    def ignore_daemonsets_utilization(self) -> Optional[pulumi.Input[bool]]:
        """
        Ignore DaemonSet pods when calculating resource utilization for scaling down.
        """
        return pulumi.get(self, "ignore_daemonsets_utilization")

    @ignore_daemonsets_utilization.setter
    def ignore_daemonsets_utilization(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_daemonsets_utilization", value)

    @property
    @pulumi.getter(name="maxGracefulTerminationSec")
    def max_graceful_termination_sec(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of seconds the cluster autoscaler waits for pod termination when trying to scale down a node
        """
        return pulumi.get(self, "max_graceful_termination_sec")

    @max_graceful_termination_sec.setter
    def max_graceful_termination_sec(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_graceful_termination_sec", value)

    @property
    @pulumi.getter(name="scaleDownDelayAfterAdd")
    def scale_down_delay_after_add(self) -> Optional[pulumi.Input[str]]:
        """
        How long after scale up that scale down evaluation resumes.
        """
        return pulumi.get(self, "scale_down_delay_after_add")

    @scale_down_delay_after_add.setter
    def scale_down_delay_after_add(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_delay_after_add", value)

    @property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[pulumi.Input[str]]:
        """
        How long a node should be unneeded before it is eligible for scale down.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @scale_down_unneeded_time.setter
    def scale_down_unneeded_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scale_down_unneeded_time", value)

    @property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Node utilization level, defined as sum of requested resources divided by capacity, below which a node can be considered for scale down
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @scale_down_utilization_threshold.setter
    def scale_down_utilization_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "scale_down_utilization_threshold", value)


@pulumi.input_type
class K8sClusterKubeconfigArgs:
    def __init__(__self__, *,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 config_file: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_ca_certificate: The CA certificate of the Kubernetes API server.
        :param pulumi.Input[str] config_file: The raw kubeconfig file.
        :param pulumi.Input[str] host: The URL of the Kubernetes API server.
        :param pulumi.Input[str] token: The token to connect to the Kubernetes API server.
        """
        K8sClusterKubeconfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cluster_ca_certificate=cluster_ca_certificate,
            config_file=config_file,
            host=host,
            token=token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
             config_file: Optional[pulumi.Input[str]] = None,
             host: Optional[pulumi.Input[str]] = None,
             token: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clusterCaCertificate' in kwargs:
            cluster_ca_certificate = kwargs['clusterCaCertificate']
        if 'configFile' in kwargs:
            config_file = kwargs['configFile']

        if cluster_ca_certificate is not None:
            _setter("cluster_ca_certificate", cluster_ca_certificate)
        if config_file is not None:
            _setter("config_file", config_file)
        if host is not None:
            _setter("host", host)
        if token is not None:
            _setter("token", token)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The CA certificate of the Kubernetes API server.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter(name="configFile")
    def config_file(self) -> Optional[pulumi.Input[str]]:
        """
        The raw kubeconfig file.
        """
        return pulumi.get(self, "config_file")

    @config_file.setter
    def config_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "config_file", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Kubernetes API server.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The token to connect to the Kubernetes API server.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class K8sClusterOpenIdConnectConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[str],
                 issuer_url: pulumi.Input[str],
                 groups_claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 groups_prefix: Optional[pulumi.Input[str]] = None,
                 required_claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 username_claim: Optional[pulumi.Input[str]] = None,
                 username_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_id: A client id that all tokens must be issued for
        :param pulumi.Input[str] issuer_url: URL of the provider which allows the API server to discover public signing keys
        :param pulumi.Input[Sequence[pulumi.Input[str]]] groups_claims: JWT claim to use as the user's group
        :param pulumi.Input[str] groups_prefix: Prefix prepended to group claims
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required_claims: Multiple key=value pairs that describes a required claim in the ID Token
        :param pulumi.Input[str] username_claim: JWT claim to use as the user name
        :param pulumi.Input[str] username_prefix: Prefix prepended to username
        """
        K8sClusterOpenIdConnectConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            issuer_url=issuer_url,
            groups_claims=groups_claims,
            groups_prefix=groups_prefix,
            required_claims=required_claims,
            username_claim=username_claim,
            username_prefix=username_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: pulumi.Input[str],
             issuer_url: pulumi.Input[str],
             groups_claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             groups_prefix: Optional[pulumi.Input[str]] = None,
             required_claims: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             username_claim: Optional[pulumi.Input[str]] = None,
             username_prefix: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']
        if 'issuerUrl' in kwargs:
            issuer_url = kwargs['issuerUrl']
        if 'groupsClaims' in kwargs:
            groups_claims = kwargs['groupsClaims']
        if 'groupsPrefix' in kwargs:
            groups_prefix = kwargs['groupsPrefix']
        if 'requiredClaims' in kwargs:
            required_claims = kwargs['requiredClaims']
        if 'usernameClaim' in kwargs:
            username_claim = kwargs['usernameClaim']
        if 'usernamePrefix' in kwargs:
            username_prefix = kwargs['usernamePrefix']

        _setter("client_id", client_id)
        _setter("issuer_url", issuer_url)
        if groups_claims is not None:
            _setter("groups_claims", groups_claims)
        if groups_prefix is not None:
            _setter("groups_prefix", groups_prefix)
        if required_claims is not None:
            _setter("required_claims", required_claims)
        if username_claim is not None:
            _setter("username_claim", username_claim)
        if username_prefix is not None:
            _setter("username_prefix", username_prefix)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[str]:
        """
        A client id that all tokens must be issued for
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> pulumi.Input[str]:
        """
        URL of the provider which allows the API server to discover public signing keys
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="groupsClaims")
    def groups_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        JWT claim to use as the user's group
        """
        return pulumi.get(self, "groups_claims")

    @groups_claims.setter
    def groups_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "groups_claims", value)

    @property
    @pulumi.getter(name="groupsPrefix")
    def groups_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix prepended to group claims
        """
        return pulumi.get(self, "groups_prefix")

    @groups_prefix.setter
    def groups_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "groups_prefix", value)

    @property
    @pulumi.getter(name="requiredClaims")
    def required_claims(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Multiple key=value pairs that describes a required claim in the ID Token
        """
        return pulumi.get(self, "required_claims")

    @required_claims.setter
    def required_claims(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "required_claims", value)

    @property
    @pulumi.getter(name="usernameClaim")
    def username_claim(self) -> Optional[pulumi.Input[str]]:
        """
        JWT claim to use as the user name
        """
        return pulumi.get(self, "username_claim")

    @username_claim.setter
    def username_claim(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_claim", value)

    @property
    @pulumi.getter(name="usernamePrefix")
    def username_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix prepended to username
        """
        return pulumi.get(self, "username_prefix")

    @username_prefix.setter
    def username_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username_prefix", value)


@pulumi.input_type
class K8sPoolNodeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 public_ip: Optional[pulumi.Input[str]] = None,
                 public_ip_v6: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name for the pool.
               > **Important:** Updates to this field will recreate a new resource.
        :param pulumi.Input[str] public_ip: The public IPv4.
        :param pulumi.Input[str] public_ip_v6: The public IPv6.
        :param pulumi.Input[str] status: The status of the node.
        """
        K8sPoolNodeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            public_ip=public_ip,
            public_ip_v6=public_ip_v6,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             public_ip: Optional[pulumi.Input[str]] = None,
             public_ip_v6: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'publicIp' in kwargs:
            public_ip = kwargs['publicIp']
        if 'publicIpV6' in kwargs:
            public_ip_v6 = kwargs['publicIpV6']

        if name is not None:
            _setter("name", name)
        if public_ip is not None:
            _setter("public_ip", public_ip)
        if public_ip_v6 is not None:
            _setter("public_ip_v6", public_ip_v6)
        if status is not None:
            _setter("status", status)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name for the pool.
        > **Important:** Updates to this field will recreate a new resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="publicIp")
    def public_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The public IPv4.
        """
        return pulumi.get(self, "public_ip")

    @public_ip.setter
    def public_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip", value)

    @property
    @pulumi.getter(name="publicIpV6")
    def public_ip_v6(self) -> Optional[pulumi.Input[str]]:
        """
        The public IPv6.
        """
        return pulumi.get(self, "public_ip_v6")

    @public_ip_v6.setter
    def public_ip_v6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_ip_v6", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class K8sPoolUpgradePolicyArgs:
    def __init__(__self__, *,
                 max_surge: Optional[pulumi.Input[int]] = None,
                 max_unavailable: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_surge: The maximum number of nodes to be created during the upgrade
        :param pulumi.Input[int] max_unavailable: The maximum number of nodes that can be not ready at the same time
        """
        K8sPoolUpgradePolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_surge=max_surge,
            max_unavailable=max_unavailable,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_surge: Optional[pulumi.Input[int]] = None,
             max_unavailable: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSurge' in kwargs:
            max_surge = kwargs['maxSurge']
        if 'maxUnavailable' in kwargs:
            max_unavailable = kwargs['maxUnavailable']

        if max_surge is not None:
            _setter("max_surge", max_surge)
        if max_unavailable is not None:
            _setter("max_unavailable", max_unavailable)

    @property
    @pulumi.getter(name="maxSurge")
    def max_surge(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of nodes to be created during the upgrade
        """
        return pulumi.get(self, "max_surge")

    @max_surge.setter
    def max_surge(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_surge", value)

    @property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of nodes that can be not ready at the same time
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_unavailable", value)


@pulumi.input_type
class LbAclActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LbAclActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        :param pulumi.Input[Sequence[pulumi.Input['LbAclActionRedirectArgs']]] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        LbAclActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            redirects=redirects,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LbAclActionRedirectArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        if redirects is not None:
            _setter("redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LbAclActionRedirectArgs']]]]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LbAclActionRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


@pulumi.input_type
class LbAclActionRedirectArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param pulumi.Input[str] target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        """
        LbAclActionRedirectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[pulumi.Input[int]] = None,
             target: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if target is not None:
            _setter("target", target)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class LbAclMatchArgs:
    def __init__(__self__, *,
                 http_filter: Optional[pulumi.Input[str]] = None,
                 http_filter_option: Optional[pulumi.Input[str]] = None,
                 http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 invert: Optional[pulumi.Input[bool]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        :param pulumi.Input[bool] invert: If set to `true`, the condition will be of type "unless".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        LbAclMatchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_filter=http_filter,
            http_filter_option=http_filter_option,
            http_filter_values=http_filter_values,
            invert=invert,
            ip_subnets=ip_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_filter: Optional[pulumi.Input[str]] = None,
             http_filter_option: Optional[pulumi.Input[str]] = None,
             http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             invert: Optional[pulumi.Input[bool]] = None,
             ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpFilter' in kwargs:
            http_filter = kwargs['httpFilter']
        if 'httpFilterOption' in kwargs:
            http_filter_option = kwargs['httpFilterOption']
        if 'httpFilterValues' in kwargs:
            http_filter_values = kwargs['httpFilterValues']
        if 'ipSubnets' in kwargs:
            ip_subnets = kwargs['ipSubnets']

        if http_filter is not None:
            _setter("http_filter", http_filter)
        if http_filter_option is not None:
            _setter("http_filter_option", http_filter_option)
        if http_filter_values is not None:
            _setter("http_filter_values", http_filter_values)
        if invert is not None:
            _setter("invert", invert)
        if ip_subnets is not None:
            _setter("ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @http_filter.setter
    def http_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter", value)

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_filter_option")

    @http_filter_option.setter
    def http_filter_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter_option", value)

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @http_filter_values.setter
    def http_filter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_filter_values", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_subnets", value)


@pulumi.input_type
class LbBackendHealthCheckHttpArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 code: Optional[pulumi.Input[int]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: The HTTPS endpoint URL to call for HC requests.
        :param pulumi.Input[int] code: The expected HTTP status code.
        :param pulumi.Input[str] host_header: The HTTP host header to use for HC requests.
        :param pulumi.Input[str] method: The HTTP method to use for HC requests.
        """
        LbBackendHealthCheckHttpArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            code=code,
            host_header=host_header,
            method=method,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: pulumi.Input[str],
             code: Optional[pulumi.Input[int]] = None,
             host_header: Optional[pulumi.Input[str]] = None,
             method: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostHeader' in kwargs:
            host_header = kwargs['hostHeader']

        _setter("uri", uri)
        if code is not None:
            _setter("code", code)
        if host_header is not None:
            _setter("host_header", host_header)
        if method is not None:
            _setter("method", method)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)


@pulumi.input_type
class LbBackendHealthCheckHttpsArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 code: Optional[pulumi.Input[int]] = None,
                 host_header: Optional[pulumi.Input[str]] = None,
                 method: Optional[pulumi.Input[str]] = None,
                 sni: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] uri: The HTTPS endpoint URL to call for HC requests.
        :param pulumi.Input[int] code: The expected HTTP status code.
        :param pulumi.Input[str] host_header: The HTTP host header to use for HC requests.
        :param pulumi.Input[str] method: The HTTP method to use for HC requests.
        :param pulumi.Input[str] sni: The SNI to use for HC requests over SSL.
        """
        LbBackendHealthCheckHttpsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            code=code,
            host_header=host_header,
            method=method,
            sni=sni,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: pulumi.Input[str],
             code: Optional[pulumi.Input[int]] = None,
             host_header: Optional[pulumi.Input[str]] = None,
             method: Optional[pulumi.Input[str]] = None,
             sni: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'hostHeader' in kwargs:
            host_header = kwargs['hostHeader']

        _setter("uri", uri)
        if code is not None:
            _setter("code", code)
        if host_header is not None:
            _setter("host_header", host_header)
        if method is not None:
            _setter("method", method)
        if sni is not None:
            _setter("sni", sni)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The HTTPS endpoint URL to call for HC requests.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The expected HTTP status code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter(name="hostHeader")
    def host_header(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP host header to use for HC requests.
        """
        return pulumi.get(self, "host_header")

    @host_header.setter
    def host_header(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_header", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP method to use for HC requests.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        The SNI to use for HC requests over SSL.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)


@pulumi.input_type
class LbBackendHealthCheckTcpArgs:
    def __init__(__self__):
        pass
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        pass



@pulumi.input_type
class LbCertificateCustomCertificateArgs:
    def __init__(__self__, *,
                 certificate_chain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] certificate_chain: Full PEM-formatted certificate chain.
               
               > **Important:** Updates to `custom_certificate` will recreate the load-balancer certificate.
        """
        LbCertificateCustomCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_chain=certificate_chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_chain: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateChain' in kwargs:
            certificate_chain = kwargs['certificateChain']

        _setter("certificate_chain", certificate_chain)

    @property
    @pulumi.getter(name="certificateChain")
    def certificate_chain(self) -> pulumi.Input[str]:
        """
        Full PEM-formatted certificate chain.

        > **Important:** Updates to `custom_certificate` will recreate the load-balancer certificate.
        """
        return pulumi.get(self, "certificate_chain")

    @certificate_chain.setter
    def certificate_chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "certificate_chain", value)


@pulumi.input_type
class LbCertificateLetsencryptArgs:
    def __init__(__self__, *,
                 common_name: pulumi.Input[str],
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] common_name: Main domain of the certificate. A new certificate will be created if this field is changed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] subject_alternative_names: Array of alternative domain names.  A new certificate will be created if this field is changed.
               
               > **Important:** Updates to `letsencrypt` will recreate the load-balancer certificate.
        """
        LbCertificateLetsencryptArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            common_name=common_name,
            subject_alternative_names=subject_alternative_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             common_name: pulumi.Input[str],
             subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'commonName' in kwargs:
            common_name = kwargs['commonName']
        if 'subjectAlternativeNames' in kwargs:
            subject_alternative_names = kwargs['subjectAlternativeNames']

        _setter("common_name", common_name)
        if subject_alternative_names is not None:
            _setter("subject_alternative_names", subject_alternative_names)

    @property
    @pulumi.getter(name="commonName")
    def common_name(self) -> pulumi.Input[str]:
        """
        Main domain of the certificate. A new certificate will be created if this field is changed.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "common_name", value)

    @property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Array of alternative domain names.  A new certificate will be created if this field is changed.

        > **Important:** Updates to `letsencrypt` will recreate the load-balancer certificate.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alternative_names", value)


@pulumi.input_type
class LbFrontendAclArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['LbFrontendAclActionArgs'],
                 match: pulumi.Input['LbFrontendAclMatchArgs'],
                 created_at: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['LbFrontendAclActionArgs'] action: Action to undertake when an ACL filter matches.
        :param pulumi.Input['LbFrontendAclMatchArgs'] match: The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        :param pulumi.Input[str] name: The ACL name. If not provided it will be randomly generated.
        """
        LbFrontendAclArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match=match,
            created_at=created_at,
            description=description,
            name=name,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input['LbFrontendAclActionArgs'],
             match: pulumi.Input['LbFrontendAclMatchArgs'],
             created_at: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             updated_at: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        _setter("action", action)
        _setter("match", match)
        if created_at is not None:
            _setter("created_at", created_at)
        if description is not None:
            _setter("description", description)
        if name is not None:
            _setter("name", name)
        if updated_at is not None:
            _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input['LbFrontendAclActionArgs']:
        """
        Action to undertake when an ACL filter matches.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['LbFrontendAclActionArgs']):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def match(self) -> pulumi.Input['LbFrontendAclMatchArgs']:
        """
        The ACL match rule. At least `ip_subnet` or `http_filter` and `http_filter_value` are required.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: pulumi.Input['LbFrontendAclMatchArgs']):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The ACL name. If not provided it will be randomly generated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.input_type
class LbFrontendAclActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LbFrontendAclActionRedirectArgs']]]] = None):
        """
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        :param pulumi.Input[Sequence[pulumi.Input['LbFrontendAclActionRedirectArgs']]] redirects: Redirect parameters when using an ACL with `redirect` action.
        """
        LbFrontendAclActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            redirects=redirects,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             redirects: Optional[pulumi.Input[Sequence[pulumi.Input['LbFrontendAclActionRedirectArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("type", type)
        if redirects is not None:
            _setter("redirects", redirects)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def redirects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LbFrontendAclActionRedirectArgs']]]]:
        """
        Redirect parameters when using an ACL with `redirect` action.
        """
        return pulumi.get(self, "redirects")

    @redirects.setter
    def redirects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LbFrontendAclActionRedirectArgs']]]]):
        pulumi.set(self, "redirects", value)


@pulumi.input_type
class LbFrontendAclActionRedirectArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        :param pulumi.Input[str] target: An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        :param pulumi.Input[str] type: The redirect type. Possible values are: `location` or `scheme`.
        """
        LbFrontendAclActionRedirectArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            target=target,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[pulumi.Input[int]] = None,
             target: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if code is not None:
            _setter("code", code)
        if target is not None:
            _setter("target", target)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The HTTP redirect code to use. Valid values are `301`, `302`, `303`, `307` and `308`.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        An URL can be used in case of a location redirect (e.g. `https://scaleway.com` will redirect to this same URL). A scheme name (e.g. `https`, `http`, `ftp`, `git`) will replace the request's original scheme.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The redirect type. Possible values are: `location` or `scheme`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class LbFrontendAclMatchArgs:
    def __init__(__self__, *,
                 http_filter: Optional[pulumi.Input[str]] = None,
                 http_filter_option: Optional[pulumi.Input[str]] = None,
                 http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 invert: Optional[pulumi.Input[bool]] = None,
                 ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] http_filter: The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
               It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
               Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] http_filter_values: A list of possible values to match for the given HTTP filter.
               Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        :param pulumi.Input[bool] invert: If set to `true`, the condition will be of type "unless".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ip_subnets: A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        LbFrontendAclMatchArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_filter=http_filter,
            http_filter_option=http_filter_option,
            http_filter_values=http_filter_values,
            invert=invert,
            ip_subnets=ip_subnets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_filter: Optional[pulumi.Input[str]] = None,
             http_filter_option: Optional[pulumi.Input[str]] = None,
             http_filter_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             invert: Optional[pulumi.Input[bool]] = None,
             ip_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpFilter' in kwargs:
            http_filter = kwargs['httpFilter']
        if 'httpFilterOption' in kwargs:
            http_filter_option = kwargs['httpFilterOption']
        if 'httpFilterValues' in kwargs:
            http_filter_values = kwargs['httpFilterValues']
        if 'ipSubnets' in kwargs:
            ip_subnets = kwargs['ipSubnets']

        if http_filter is not None:
            _setter("http_filter", http_filter)
        if http_filter_option is not None:
            _setter("http_filter_option", http_filter_option)
        if http_filter_values is not None:
            _setter("http_filter_values", http_filter_values)
        if invert is not None:
            _setter("invert", invert)
        if ip_subnets is not None:
            _setter("ip_subnets", ip_subnets)

    @property
    @pulumi.getter(name="httpFilter")
    def http_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The HTTP filter to match. This filter is supported only if your backend protocol has an HTTP forward protocol.
        It extracts the request's URL path, which starts at the first slash and ends before the question mark (without the host part).
        Possible values are: `acl_http_filter_none`, `path_begin`, `path_end`, `http_header_match` or `regex`.
        """
        return pulumi.get(self, "http_filter")

    @http_filter.setter
    def http_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter", value)

    @property
    @pulumi.getter(name="httpFilterOption")
    def http_filter_option(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "http_filter_option")

    @http_filter_option.setter
    def http_filter_option(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_filter_option", value)

    @property
    @pulumi.getter(name="httpFilterValues")
    def http_filter_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of possible values to match for the given HTTP filter.
        Keep in mind that in the case of `http_header_match` the HTTP header field name is case-insensitive.
        """
        return pulumi.get(self, "http_filter_values")

    @http_filter_values.setter
    def http_filter_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "http_filter_values", value)

    @property
    @pulumi.getter
    def invert(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to `true`, the condition will be of type "unless".
        """
        return pulumi.get(self, "invert")

    @invert.setter
    def invert(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invert", value)

    @property
    @pulumi.getter(name="ipSubnets")
    def ip_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs or CIDR v4/v6 addresses of the client of the session to match.
        """
        return pulumi.get(self, "ip_subnets")

    @ip_subnets.setter
    def ip_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ip_subnets", value)


@pulumi.input_type
class LbPrivateNetworkArgs:
    def __init__(__self__, *,
                 private_network_id: pulumi.Input[str],
                 dhcp_config: Optional[pulumi.Input[bool]] = None,
                 static_config: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_network_id: (Required) The ID of the Private Network to associate.
        :param pulumi.Input[bool] dhcp_config: (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
        :param pulumi.Input[str] static_config: (Optional) Define a local ip address of your choice for the load balancer instance. See below.
        :param pulumi.Input[str] zone: `zone`) The zone of the load-balancer.
        """
        LbPrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_network_id=private_network_id,
            dhcp_config=dhcp_config,
            static_config=static_config,
            status=status,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_network_id: pulumi.Input[str],
             dhcp_config: Optional[pulumi.Input[bool]] = None,
             static_config: Optional[pulumi.Input[str]] = None,
             status: Optional[pulumi.Input[str]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'dhcpConfig' in kwargs:
            dhcp_config = kwargs['dhcpConfig']
        if 'staticConfig' in kwargs:
            static_config = kwargs['staticConfig']

        _setter("private_network_id", private_network_id)
        if dhcp_config is not None:
            _setter("dhcp_config", dhcp_config)
        if static_config is not None:
            _setter("static_config", static_config)
        if status is not None:
            _setter("status", status)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[str]:
        """
        (Required) The ID of the Private Network to associate.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_network_id", value)

    @property
    @pulumi.getter(name="dhcpConfig")
    def dhcp_config(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional) Set to true if you want to let DHCP assign IP addresses. See below.
        """
        return pulumi.get(self, "dhcp_config")

    @dhcp_config.setter
    def dhcp_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dhcp_config", value)

    @property
    @pulumi.getter(name="staticConfig")
    def static_config(self) -> Optional[pulumi.Input[str]]:
        """
        (Optional) Define a local ip address of your choice for the load balancer instance. See below.
        """
        return pulumi.get(self, "static_config")

    @static_config.setter
    def static_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "static_config", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        `zone`) The zone of the load-balancer.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class MnqCredentialNatsCredentialsArgs:
    def __init__(__self__, *,
                 content: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: Raw content of the NATS credentials file.
        """
        MnqCredentialNatsCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if content is not None:
            _setter("content", content)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Raw content of the NATS credentials file.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)


@pulumi.input_type
class MnqCredentialSqsSnsCredentialsArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input['MnqCredentialSqsSnsCredentialsPermissionsArgs']] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: The ID of the key.
        :param pulumi.Input['MnqCredentialSqsSnsCredentialsPermissionsArgs'] permissions: List of permissions associated to this Credential. Only one of permissions may be set.
        :param pulumi.Input[str] secret_key: The Secret value of the key.
        """
        MnqCredentialSqsSnsCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            permissions=permissions,
            secret_key=secret_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[pulumi.Input[str]] = None,
             permissions: Optional[pulumi.Input['MnqCredentialSqsSnsCredentialsPermissionsArgs']] = None,
             secret_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']

        if access_key is not None:
            _setter("access_key", access_key)
        if permissions is not None:
            _setter("permissions", permissions)
        if secret_key is not None:
            _setter("secret_key", secret_key)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the key.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input['MnqCredentialSqsSnsCredentialsPermissionsArgs']]:
        """
        List of permissions associated to this Credential. Only one of permissions may be set.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input['MnqCredentialSqsSnsCredentialsPermissionsArgs']]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Secret value of the key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


@pulumi.input_type
class MnqCredentialSqsSnsCredentialsPermissionsArgs:
    def __init__(__self__, *,
                 can_manage: Optional[pulumi.Input[bool]] = None,
                 can_publish: Optional[pulumi.Input[bool]] = None,
                 can_receive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] can_manage: . Defines if user can manage the associated resource(s).
        :param pulumi.Input[bool] can_publish: . Defines if user can publish messages to the service.
        :param pulumi.Input[bool] can_receive: . Defines if user can receive messages from the service.
        """
        MnqCredentialSqsSnsCredentialsPermissionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_manage=can_manage,
            can_publish=can_publish,
            can_receive=can_receive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_manage: Optional[pulumi.Input[bool]] = None,
             can_publish: Optional[pulumi.Input[bool]] = None,
             can_receive: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'canManage' in kwargs:
            can_manage = kwargs['canManage']
        if 'canPublish' in kwargs:
            can_publish = kwargs['canPublish']
        if 'canReceive' in kwargs:
            can_receive = kwargs['canReceive']

        if can_manage is not None:
            _setter("can_manage", can_manage)
        if can_publish is not None:
            _setter("can_publish", can_publish)
        if can_receive is not None:
            _setter("can_receive", can_receive)

    @property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defines if user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @can_manage.setter
    def can_manage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_manage", value)

    @property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defines if user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @can_publish.setter
    def can_publish(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_publish", value)

    @property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defines if user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")

    @can_receive.setter
    def can_receive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_receive", value)


@pulumi.input_type
class MnqQueueNatsArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[str],
                 endpoint: Optional[pulumi.Input[str]] = None,
                 retention_policy: Optional[pulumi.Input[str]] = None):
        MnqQueueNatsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            endpoint=endpoint,
            retention_policy=retention_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: pulumi.Input[str],
             endpoint: Optional[pulumi.Input[str]] = None,
             retention_policy: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'retentionPolicy' in kwargs:
            retention_policy = kwargs['retentionPolicy']

        _setter("credentials", credentials)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if retention_policy is not None:
            _setter("retention_policy", retention_policy)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[str]:
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[str]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_policy", value)


@pulumi.input_type
class MnqQueueSqsArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[str],
                 secret_key: pulumi.Input[str],
                 content_based_deduplication: Optional[pulumi.Input[bool]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 fifo_queue: Optional[pulumi.Input[bool]] = None,
                 receive_wait_time_seconds: Optional[pulumi.Input[int]] = None,
                 url: Optional[pulumi.Input[str]] = None,
                 visibility_timeout_seconds: Optional[pulumi.Input[int]] = None):
        MnqQueueSqsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            secret_key=secret_key,
            content_based_deduplication=content_based_deduplication,
            endpoint=endpoint,
            fifo_queue=fifo_queue,
            receive_wait_time_seconds=receive_wait_time_seconds,
            url=url,
            visibility_timeout_seconds=visibility_timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: pulumi.Input[str],
             secret_key: pulumi.Input[str],
             content_based_deduplication: Optional[pulumi.Input[bool]] = None,
             endpoint: Optional[pulumi.Input[str]] = None,
             fifo_queue: Optional[pulumi.Input[bool]] = None,
             receive_wait_time_seconds: Optional[pulumi.Input[int]] = None,
             url: Optional[pulumi.Input[str]] = None,
             visibility_timeout_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'contentBasedDeduplication' in kwargs:
            content_based_deduplication = kwargs['contentBasedDeduplication']
        if 'fifoQueue' in kwargs:
            fifo_queue = kwargs['fifoQueue']
        if 'receiveWaitTimeSeconds' in kwargs:
            receive_wait_time_seconds = kwargs['receiveWaitTimeSeconds']
        if 'visibilityTimeoutSeconds' in kwargs:
            visibility_timeout_seconds = kwargs['visibilityTimeoutSeconds']

        _setter("access_key", access_key)
        _setter("secret_key", secret_key)
        if content_based_deduplication is not None:
            _setter("content_based_deduplication", content_based_deduplication)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if fifo_queue is not None:
            _setter("fifo_queue", fifo_queue)
        if receive_wait_time_seconds is not None:
            _setter("receive_wait_time_seconds", receive_wait_time_seconds)
        if url is not None:
            _setter("url", url)
        if visibility_timeout_seconds is not None:
            _setter("visibility_timeout_seconds", visibility_timeout_seconds)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="contentBasedDeduplication")
    def content_based_deduplication(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "content_based_deduplication")

    @content_based_deduplication.setter
    def content_based_deduplication(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "content_based_deduplication", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="fifoQueue")
    def fifo_queue(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "fifo_queue")

    @fifo_queue.setter
    def fifo_queue(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fifo_queue", value)

    @property
    @pulumi.getter(name="receiveWaitTimeSeconds")
    def receive_wait_time_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "receive_wait_time_seconds")

    @receive_wait_time_seconds.setter
    def receive_wait_time_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "receive_wait_time_seconds", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="visibilityTimeoutSeconds")
    def visibility_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "visibility_timeout_seconds")

    @visibility_timeout_seconds.setter
    def visibility_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "visibility_timeout_seconds", value)


@pulumi.input_type
class MnqSqsCredentialsPermissionsArgs:
    def __init__(__self__, *,
                 can_manage: Optional[pulumi.Input[bool]] = None,
                 can_publish: Optional[pulumi.Input[bool]] = None,
                 can_receive: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] can_manage: . Defines if user can manage the associated resource(s).
        :param pulumi.Input[bool] can_publish: . Defines if user can publish messages to the service.
        :param pulumi.Input[bool] can_receive: . Defines if user can receive messages from the service.
        """
        MnqSqsCredentialsPermissionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            can_manage=can_manage,
            can_publish=can_publish,
            can_receive=can_receive,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             can_manage: Optional[pulumi.Input[bool]] = None,
             can_publish: Optional[pulumi.Input[bool]] = None,
             can_receive: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'canManage' in kwargs:
            can_manage = kwargs['canManage']
        if 'canPublish' in kwargs:
            can_publish = kwargs['canPublish']
        if 'canReceive' in kwargs:
            can_receive = kwargs['canReceive']

        if can_manage is not None:
            _setter("can_manage", can_manage)
        if can_publish is not None:
            _setter("can_publish", can_publish)
        if can_receive is not None:
            _setter("can_receive", can_receive)

    @property
    @pulumi.getter(name="canManage")
    def can_manage(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defines if user can manage the associated resource(s).
        """
        return pulumi.get(self, "can_manage")

    @can_manage.setter
    def can_manage(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_manage", value)

    @property
    @pulumi.getter(name="canPublish")
    def can_publish(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defines if user can publish messages to the service.
        """
        return pulumi.get(self, "can_publish")

    @can_publish.setter
    def can_publish(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_publish", value)

    @property
    @pulumi.getter(name="canReceive")
    def can_receive(self) -> Optional[pulumi.Input[bool]]:
        """
        . Defines if user can receive messages from the service.
        """
        return pulumi.get(self, "can_receive")

    @can_receive.setter
    def can_receive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "can_receive", value)


@pulumi.input_type
class ObjectBucketAclAccessControlPolicyArgs:
    def __init__(__self__, *,
                 owner: pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs'],
                 grants: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]] = None):
        ObjectBucketAclAccessControlPolicyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            owner=owner,
            grants=grants,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             owner: pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs'],
             grants: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("owner", owner)
        if grants is not None:
            _setter("grants", grants)

    @property
    @pulumi.getter
    def owner(self) -> pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs']:
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: pulumi.Input['ObjectBucketAclAccessControlPolicyOwnerArgs']):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter
    def grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]]:
        return pulumi.get(self, "grants")

    @grants.setter
    def grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantArgs']]]]):
        pulumi.set(self, "grants", value)


@pulumi.input_type
class ObjectBucketAclAccessControlPolicyGrantArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 grantee: Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']] = None):
        ObjectBucketAclAccessControlPolicyGrantArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permission=permission,
            grantee=grantee,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permission: pulumi.Input[str],
             grantee: Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("permission", permission)
        if grantee is not None:
            _setter("grantee", grantee)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter
    def grantee(self) -> Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']]:
        return pulumi.get(self, "grantee")

    @grantee.setter
    def grantee(self, value: Optional[pulumi.Input['ObjectBucketAclAccessControlPolicyGrantGranteeArgs']]):
        pulumi.set(self, "grantee", value)


@pulumi.input_type
class ObjectBucketAclAccessControlPolicyGrantGranteeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The `region`,`bucket` and `acl` separated by (`/`).
        """
        ObjectBucketAclAccessControlPolicyGrantGranteeArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']

        _setter("id", id)
        _setter("type", type)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The `region`,`bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class ObjectBucketAclAccessControlPolicyOwnerArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 display_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The `region`,`bucket` and `acl` separated by (`/`).
        """
        ObjectBucketAclAccessControlPolicyOwnerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            display_name=display_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             display_name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'displayName' in kwargs:
            display_name = kwargs['displayName']

        _setter("id", id)
        if display_name is not None:
            _setter("display_name", display_name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The `region`,`bucket` and `acl` separated by (`/`).
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)


@pulumi.input_type
class ObjectBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Specifies which origins are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Specifies which headers are allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Specifies expose header in the response.
        :param pulumi.Input[int] max_age_seconds: Specifies time in seconds that browser can cache the response for a preflight request.
        """
        ObjectBucketCorsRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allowed_methods=allowed_methods,
            allowed_origins=allowed_origins,
            allowed_headers=allowed_headers,
            expose_headers=expose_headers,
            max_age_seconds=max_age_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
             allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
             allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             max_age_seconds: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowedMethods' in kwargs:
            allowed_methods = kwargs['allowedMethods']
        if 'allowedOrigins' in kwargs:
            allowed_origins = kwargs['allowedOrigins']
        if 'allowedHeaders' in kwargs:
            allowed_headers = kwargs['allowedHeaders']
        if 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if 'maxAgeSeconds' in kwargs:
            max_age_seconds = kwargs['maxAgeSeconds']

        _setter("allowed_methods", allowed_methods)
        _setter("allowed_origins", allowed_origins)
        if allowed_headers is not None:
            _setter("allowed_headers", allowed_headers)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age_seconds is not None:
            _setter("max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies which methods are allowed. Can be `GET`, `PUT`, `POST`, `DELETE` or `HEAD`.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Specifies which origins are allowed.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies which headers are allowed.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Specifies expose header in the response.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


@pulumi.input_type
class ObjectBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[int]] = None,
                 expiration: Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 transitions: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]] = None):
        """
        :param pulumi.Input[bool] enabled: The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway S3 doesn't perform any of the actions defined in the rule.
        :param pulumi.Input[int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.
               
               * > **Important:** It's not recommended using `prefix` for `AbortIncompleteMultipartUpload` as any incomplete multipart upload will be billed
        :param pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs'] expiration: Specifies a period in the object's expire (documented below).
        :param pulumi.Input[str] id: Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        :param pulumi.Input[str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] tags: Specifies object tags key and value.
        :param pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]] transitions: Specifies a period in the object's transitions (documented below).
               
               At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition` must be specified.
        """
        ObjectBucketLifecycleRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            abort_incomplete_multipart_upload_days=abort_incomplete_multipart_upload_days,
            expiration=expiration,
            id=id,
            prefix=prefix,
            tags=tags,
            transitions=transitions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             abort_incomplete_multipart_upload_days: Optional[pulumi.Input[int]] = None,
             expiration: Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']] = None,
             id: Optional[pulumi.Input[str]] = None,
             prefix: Optional[pulumi.Input[str]] = None,
             tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             transitions: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'abortIncompleteMultipartUploadDays' in kwargs:
            abort_incomplete_multipart_upload_days = kwargs['abortIncompleteMultipartUploadDays']

        _setter("enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            _setter("abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            _setter("expiration", expiration)
        if id is not None:
            _setter("id", id)
        if prefix is not None:
            _setter("prefix", prefix)
        if tags is not None:
            _setter("tags", tags)
        if transitions is not None:
            _setter("transitions", transitions)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        The element value can be either Enabled or Disabled. If a rule is disabled, Scaleway S3 doesn't perform any of the actions defined in the rule.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after initiating a multipart upload when the multipart upload must be completed.

        * > **Important:** It's not recommended using `prefix` for `AbortIncompleteMultipartUpload` as any incomplete multipart upload will be billed
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a period in the object's expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['ObjectBucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the rule. Must be less than or equal to 255 characters in length.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Specifies object tags key and value.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def transitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]]:
        """
        Specifies a period in the object's transitions (documented below).

        At least one of `abort_incomplete_multipart_upload_days`, `expiration`, `transition` must be specified.
        """
        return pulumi.get(self, "transitions")

    @transitions.setter
    def transitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ObjectBucketLifecycleRuleTransitionArgs']]]]):
        pulumi.set(self, "transitions", value)


@pulumi.input_type
class ObjectBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[int]):
        """
        :param pulumi.Input[int] days: Specifies the number of days after object creation when the specific rule action takes effect.
               
               > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        """
        ObjectBucketLifecycleRuleExpirationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days=days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days: pulumi.Input[int],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("days", days)

    @property
    @pulumi.getter
    def days(self) -> pulumi.Input[int]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.

        > **Important:**  If versioning is enabled, this rule only deletes the current version of an object.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[int]):
        pulumi.set(self, "days", value)


@pulumi.input_type
class ObjectBucketLifecycleRuleTransitionArgs:
    def __init__(__self__, *,
                 storage_class: pulumi.Input[str],
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] storage_class: Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.
               
               > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        :param pulumi.Input[int] days: Specifies the number of days after object creation when the specific rule action takes effect.
        """
        ObjectBucketLifecycleRuleTransitionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            storage_class=storage_class,
            days=days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             storage_class: pulumi.Input[str],
             days: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'storageClass' in kwargs:
            storage_class = kwargs['storageClass']

        _setter("storage_class", storage_class)
        if days is not None:
            _setter("days", days)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        Specifies the Scaleway [storage class](https://www.scaleway.com/en/docs/storage/object/concepts/#storage-class) `STANDARD`, `GLACIER`, `ONEZONE_IA`  to which you want the object to transition.

        > **Important:**  `ONEZONE_IA` is only available in `fr-par` region. The storage class `GLACIER` is not available in `pl-waw` region.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after object creation when the specific rule action takes effect.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


@pulumi.input_type
class ObjectBucketLockConfigurationRuleArgs:
    def __init__(__self__, *,
                 default_retention: pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs']):
        ObjectBucketLockConfigurationRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            default_retention=default_retention,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             default_retention: pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs'],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'defaultRetention' in kwargs:
            default_retention = kwargs['defaultRetention']

        _setter("default_retention", default_retention)

    @property
    @pulumi.getter(name="defaultRetention")
    def default_retention(self) -> pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs']:
        return pulumi.get(self, "default_retention")

    @default_retention.setter
    def default_retention(self, value: pulumi.Input['ObjectBucketLockConfigurationRuleDefaultRetentionArgs']):
        pulumi.set(self, "default_retention", value)


@pulumi.input_type
class ObjectBucketLockConfigurationRuleDefaultRetentionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[str],
                 days: Optional[pulumi.Input[int]] = None,
                 years: Optional[pulumi.Input[int]] = None):
        ObjectBucketLockConfigurationRuleDefaultRetentionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            mode=mode,
            days=days,
            years=years,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             mode: pulumi.Input[str],
             days: Optional[pulumi.Input[int]] = None,
             years: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("mode", mode)
        if days is not None:
            _setter("days", days)
        if years is not None:
            _setter("years", years)

    @property
    @pulumi.getter
    def mode(self) -> pulumi.Input[str]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[str]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def years(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "years")

    @years.setter
    def years(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "years", value)


@pulumi.input_type
class ObjectBucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        ObjectBucketVersioningArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ObjectBucketWebsiteConfigurationErrorDocumentArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        ObjectBucketWebsiteConfigurationErrorDocumentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


@pulumi.input_type
class ObjectBucketWebsiteConfigurationIndexDocumentArgs:
    def __init__(__self__, *,
                 suffix: pulumi.Input[str]):
        ObjectBucketWebsiteConfigurationIndexDocumentArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            suffix=suffix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             suffix: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("suffix", suffix)

    @property
    @pulumi.getter
    def suffix(self) -> pulumi.Input[str]:
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: pulumi.Input[str]):
        pulumi.set(self, "suffix", value)


@pulumi.input_type
class RdbAclAclRuleArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param pulumi.Input[str] description: A text describing this rule. Default description: `IP allowed`
        """
        RdbAclAclRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The ip range to whitelist in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A text describing this rule. Default description: `IP allowed`
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


@pulumi.input_type
class RdbInstanceLoadBalancerArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint.
        :param pulumi.Input[str] hostname: Hostname of the endpoint.
        :param pulumi.Input[str] ip: IPv4 address on the network.
        :param pulumi.Input[str] name: The name of the Database Instance.
        :param pulumi.Input[int] port: Port in the Private Network.
        """
        RdbInstanceLoadBalancerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class RdbInstancePrivateNetworkArgs:
    def __init__(__self__, *,
                 pn_id: pulumi.Input[str],
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 ip_net: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint.
        :param pulumi.Input[str] hostname: Hostname of the endpoint.
        :param pulumi.Input[str] ip: IPv4 address on the network.
        :param pulumi.Input[str] name: The name of the Database Instance.
        :param pulumi.Input[int] port: Port in the Private Network.
        """
        RdbInstancePrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pn_id=pn_id,
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            ip_net=ip_net,
            name=name,
            port=port,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pn_id: pulumi.Input[str],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             ip_net: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pnId' in kwargs:
            pn_id = kwargs['pnId']
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'ipNet' in kwargs:
            ip_net = kwargs['ipNet']

        _setter("pn_id", pn_id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if ip_net is not None:
            _setter("ip_net", ip_net)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="pnId")
    def pn_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pn_id")

    @pn_id.setter
    def pn_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pn_id", value)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the endpoint.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter(name="ipNet")
    def ip_net(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ip_net")

    @ip_net.setter
    def ip_net(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip_net", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class RdbInstanceReadReplicaArgs:
    def __init__(__self__, *,
                 ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] ip: IPv4 address on the network.
        :param pulumi.Input[str] name: The name of the Database Instance.
        :param pulumi.Input[int] port: Port in the Private Network.
        """
        RdbInstanceReadReplicaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address on the network.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the Database Instance.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port in the Private Network.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class RdbReadReplicaDirectAccessArgs:
    def __init__(__self__, *,
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint of the read replica.
        :param pulumi.Input[str] hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param pulumi.Input[str] ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param pulumi.Input[str] name: Name of the endpoint.
        :param pulumi.Input[int] port: TCP port of the endpoint.
        """
        RdbReadReplicaDirectAccessArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']

        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class RdbReadReplicaPrivateNetworkArgs:
    def __init__(__self__, *,
                 private_network_id: pulumi.Input[str],
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 service_ip: Optional[pulumi.Input[str]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] private_network_id: UUID of the private network to be connected to the read replica.
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint of the read replica.
        :param pulumi.Input[str] hostname: Hostname of the endpoint. Only one of ip and hostname may be set.
        :param pulumi.Input[str] ip: IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        :param pulumi.Input[str] name: Name of the endpoint.
        :param pulumi.Input[int] port: TCP port of the endpoint.
        :param pulumi.Input[str] service_ip: The IP network address within the private subnet. This must be an IPv4 address with a
               CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
               service if not set.
        """
        RdbReadReplicaPrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_network_id=private_network_id,
            endpoint_id=endpoint_id,
            hostname=hostname,
            ip=ip,
            name=name,
            port=port,
            service_ip=service_ip,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_network_id: pulumi.Input[str],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             hostname: Optional[pulumi.Input[str]] = None,
             ip: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             port: Optional[pulumi.Input[int]] = None,
             service_ip: Optional[pulumi.Input[str]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIp' in kwargs:
            service_ip = kwargs['serviceIp']

        _setter("private_network_id", private_network_id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if port is not None:
            _setter("port", port)
        if service_ip is not None:
            _setter("service_ip", service_ip)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[str]:
        """
        UUID of the private network to be connected to the read replica.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_network_id", value)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint of the read replica.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the endpoint. Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 address of the endpoint (IP address). Only one of ip and hostname may be set.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the endpoint.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="serviceIp")
    def service_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP network address within the private subnet. This must be an IPv4 address with a
        CIDR notation. The IP network address within the private subnet is determined by the IP Address Management (IPAM)
        service if not set.
        """
        return pulumi.get(self, "service_ip")

    @service_ip.setter
    def service_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_ip", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class RedisClusterAclArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: The ip range to whitelist
               in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        :param pulumi.Input[str] description: A text describing this rule. Default description: `Allow IP`
               
               > The `acl` conflict with `private_network`. Only one should be specified.
        :param pulumi.Input[str] id: The UUID of the private network resource.
        """
        RedisClusterAclArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            description=description,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: pulumi.Input[str],
             description: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("ip", ip)
        if description is not None:
            _setter("description", description)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        The ip range to whitelist
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation)
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A text describing this rule. Default description: `Allow IP`

        > The `acl` conflict with `private_network`. Only one should be specified.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the private network resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class RedisClusterPrivateNetworkArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 endpoint_id: Optional[pulumi.Input[str]] = None,
                 service_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The UUID of the private network resource.
        :param pulumi.Input[str] endpoint_id: The ID of the endpoint.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_ips: Endpoint IPv4 addresses
               in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at
               least one IP per node or The IP network address within the private subnet is determined by the IP Address Management (IPAM)
               service if not set.
               
               > The `private_network` conflict with `acl`. Only one should be specified.
        :param pulumi.Input[str] zone: `zone`) The zone in which the
               Redis Cluster should be created.
        """
        RedisClusterPrivateNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            endpoint_id=endpoint_id,
            service_ips=service_ips,
            zone=zone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             endpoint_id: Optional[pulumi.Input[str]] = None,
             service_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             zone: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointId' in kwargs:
            endpoint_id = kwargs['endpointId']
        if 'serviceIps' in kwargs:
            service_ips = kwargs['serviceIps']

        _setter("id", id)
        if endpoint_id is not None:
            _setter("endpoint_id", endpoint_id)
        if service_ips is not None:
            _setter("service_ips", service_ips)
        if zone is not None:
            _setter("zone", zone)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The UUID of the private network resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="endpointId")
    def endpoint_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the endpoint.
        """
        return pulumi.get(self, "endpoint_id")

    @endpoint_id.setter
    def endpoint_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_id", value)

    @property
    @pulumi.getter(name="serviceIps")
    def service_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Endpoint IPv4 addresses
        in [CIDR notation](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing#CIDR_notation). You must provide at
        least one IP per node or The IP network address within the private subnet is determined by the IP Address Management (IPAM)
        service if not set.

        > The `private_network` conflict with `acl`. Only one should be specified.
        """
        return pulumi.get(self, "service_ips")

    @service_ips.setter
    def service_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "service_ips", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        `zone`) The zone in which the
        Redis Cluster should be created.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


@pulumi.input_type
class RedisClusterPublicNetworkArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] id: The UUID of the private network resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ips: Lis of IPv4 address of the endpoint (IP address).
        :param pulumi.Input[int] port: TCP port of the endpoint.
        """
        RedisClusterPublicNetworkArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            ips=ips,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             port: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if ips is not None:
            _setter("ips", ips)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The UUID of the private network resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Lis of IPv4 address of the endpoint (IP address).
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        TCP port of the endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class VpcGatewayNetworkIpamConfigArgs:
    def __init__(__self__, *,
                 push_default_route: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] push_default_route: Defines whether the default route is enabled on that Gateway Network. Only one of `dhcp_id`, `static_address` and `ipam_config` should be specified.
        """
        VpcGatewayNetworkIpamConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            push_default_route=push_default_route,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             push_default_route: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'pushDefaultRoute' in kwargs:
            push_default_route = kwargs['pushDefaultRoute']

        if push_default_route is not None:
            _setter("push_default_route", push_default_route)

    @property
    @pulumi.getter(name="pushDefaultRoute")
    def push_default_route(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether the default route is enabled on that Gateway Network. Only one of `dhcp_id`, `static_address` and `ipam_config` should be specified.
        """
        return pulumi.get(self, "push_default_route")

    @push_default_route.setter
    def push_default_route(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "push_default_route", value)


@pulumi.input_type
class VpcPrivateNetworkIpv4SubnetArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 subnet: Optional[pulumi.Input[str]] = None,
                 subnet_mask: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        :param pulumi.Input[str] created_at: The date and time of the creation of the subnet.
        :param pulumi.Input[str] id: The subnet ID.
        :param pulumi.Input[int] prefix_length: The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        :param pulumi.Input[str] subnet: The subnet CIDR.
        :param pulumi.Input[str] subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param pulumi.Input[str] updated_at: The date and time of the last update of the subnet.
        """
        VpcPrivateNetworkIpv4SubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            created_at=created_at,
            id=id,
            prefix_length=prefix_length,
            subnet=subnet,
            subnet_mask=subnet_mask,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             created_at: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             prefix_length: Optional[pulumi.Input[int]] = None,
             subnet: Optional[pulumi.Input[str]] = None,
             subnet_mask: Optional[pulumi.Input[str]] = None,
             updated_at: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'prefixLength' in kwargs:
            prefix_length = kwargs['prefixLength']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        if address is not None:
            _setter("address", address)
        if created_at is not None:
            _setter("created_at", created_at)
        if id is not None:
            _setter("id", id)
        if prefix_length is not None:
            _setter("prefix_length", prefix_length)
        if subnet is not None:
            _setter("subnet", subnet)
        if subnet_mask is not None:
            _setter("subnet_mask", subnet_mask)
        if updated_at is not None:
            _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_mask", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.input_type
class VpcPrivateNetworkIpv6SubnetArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 created_at: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 prefix_length: Optional[pulumi.Input[int]] = None,
                 subnet: Optional[pulumi.Input[str]] = None,
                 subnet_mask: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        :param pulumi.Input[str] created_at: The date and time of the creation of the subnet.
        :param pulumi.Input[str] id: The subnet ID.
        :param pulumi.Input[int] prefix_length: The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        :param pulumi.Input[str] subnet: The subnet CIDR.
        :param pulumi.Input[str] subnet_mask: The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        :param pulumi.Input[str] updated_at: The date and time of the last update of the subnet.
        """
        VpcPrivateNetworkIpv6SubnetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            created_at=created_at,
            id=id,
            prefix_length=prefix_length,
            subnet=subnet,
            subnet_mask=subnet_mask,
            updated_at=updated_at,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[pulumi.Input[str]] = None,
             created_at: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             prefix_length: Optional[pulumi.Input[int]] = None,
             subnet: Optional[pulumi.Input[str]] = None,
             subnet_mask: Optional[pulumi.Input[str]] = None,
             updated_at: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createdAt' in kwargs:
            created_at = kwargs['createdAt']
        if 'prefixLength' in kwargs:
            prefix_length = kwargs['prefixLength']
        if 'subnetMask' in kwargs:
            subnet_mask = kwargs['subnetMask']
        if 'updatedAt' in kwargs:
            updated_at = kwargs['updatedAt']

        if address is not None:
            _setter("address", address)
        if created_at is not None:
            _setter("created_at", created_at)
        if id is not None:
            _setter("id", id)
        if prefix_length is not None:
            _setter("prefix_length", prefix_length)
        if subnet is not None:
            _setter("subnet", subnet)
        if subnet_mask is not None:
            _setter("subnet_mask", subnet_mask)
        if updated_at is not None:
            _setter("updated_at", updated_at)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The network address of the subnet in dotted decimal notation, e.g., '192.168.0.0' for a '192.168.0.0/24' subnet.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time of the creation of the subnet.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="prefixLength")
    def prefix_length(self) -> Optional[pulumi.Input[int]]:
        """
        The length of the network prefix, e.g., 24 for a 255.255.255.0 mask.
        """
        return pulumi.get(self, "prefix_length")

    @prefix_length.setter
    def prefix_length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "prefix_length", value)

    @property
    @pulumi.getter
    def subnet(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet CIDR.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter(name="subnetMask")
    def subnet_mask(self) -> Optional[pulumi.Input[str]]:
        """
        The subnet mask expressed in dotted decimal notation, e.g., '255.255.255.0' for a /24 subnet
        """
        return pulumi.get(self, "subnet_mask")

    @subnet_mask.setter
    def subnet_mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subnet_mask", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time of the last update of the subnet.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.input_type
class WebHostingCpanelUrlArgs:
    def __init__(__self__, *,
                 dashboard: Optional[pulumi.Input[str]] = None,
                 webmail: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dashboard: The URL of the Dashboard.
        :param pulumi.Input[str] webmail: The URL of the Webmail interface.
        """
        WebHostingCpanelUrlArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dashboard=dashboard,
            webmail=webmail,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dashboard: Optional[pulumi.Input[str]] = None,
             webmail: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if dashboard is not None:
            _setter("dashboard", dashboard)
        if webmail is not None:
            _setter("webmail", webmail)

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Dashboard.
        """
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dashboard", value)

    @property
    @pulumi.getter
    def webmail(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the Webmail interface.
        """
        return pulumi.get(self, "webmail")

    @webmail.setter
    def webmail(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "webmail", value)


@pulumi.input_type
class WebHostingOptionArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The option ID.
        :param pulumi.Input[str] name: The option name.
        """
        WebHostingOptionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The option ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The option name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class GetIpamIpResourceArgs:
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: The ID of the resource that the IP is bound to.
        :param str type: The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1alpha1#pkg-constants) with type list.
        """
        GetIpamIpResourceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the resource that the IP is bound to.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of the resource to get the IP from. [Documentation](https://pkg.go.dev/github.com/scaleway/scaleway-sdk-go@master/api/ipam/v1alpha1#pkg-constants) with type list.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[str]):
        pulumi.set(self, "type", value)


