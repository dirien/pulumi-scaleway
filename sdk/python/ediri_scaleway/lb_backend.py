# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs
from ._inputs import *

__all__ = ['LbBackendArgs', 'LbBackend']

@pulumi.input_type
class LbBackendArgs:
    def __init__(__self__, *,
                 forward_port: pulumi.Input[int],
                 forward_protocol: pulumi.Input[str],
                 lb_id: pulumi.Input[str],
                 failover_host: Optional[pulumi.Input[str]] = None,
                 forward_port_algorithm: Optional[pulumi.Input[str]] = None,
                 health_check_delay: Optional[pulumi.Input[str]] = None,
                 health_check_http: Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']] = None,
                 health_check_https: Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']] = None,
                 health_check_max_retries: Optional[pulumi.Input[int]] = None,
                 health_check_port: Optional[pulumi.Input[int]] = None,
                 health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
                 health_check_tcp: Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']] = None,
                 health_check_timeout: Optional[pulumi.Input[str]] = None,
                 health_check_transient_delay: Optional[pulumi.Input[str]] = None,
                 ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_marked_down_action: Optional[pulumi.Input[str]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None,
                 redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
                 send_proxy_v2: Optional[pulumi.Input[bool]] = None,
                 server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_bridging: Optional[pulumi.Input[bool]] = None,
                 sticky_sessions: Optional[pulumi.Input[str]] = None,
                 sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
                 timeout_connect: Optional[pulumi.Input[str]] = None,
                 timeout_queue: Optional[pulumi.Input[str]] = None,
                 timeout_server: Optional[pulumi.Input[str]] = None,
                 timeout_tunnel: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a LbBackend resource.
        :param pulumi.Input[int] forward_port: User sessions will be forwarded to this port of backend servers.
        :param pulumi.Input[str] forward_protocol: Backend protocol. Possible values are: `tcp` or `http`.
        :param pulumi.Input[str] lb_id: The load-balancer ID this backend is attached to.
               > **Important:** Updates to `lb_id` will recreate the backend.
        :param pulumi.Input[str] failover_host: Scaleway S3 bucket website to be served in case all backend servers are down.
               > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
               e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        :param pulumi.Input[str] forward_port_algorithm: Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        :param pulumi.Input[str] health_check_delay: Interval between two HC requests.
        :param pulumi.Input['LbBackendHealthCheckHttpArgs'] health_check_http: This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input['LbBackendHealthCheckHttpsArgs'] health_check_https: This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[int] health_check_max_retries: Number of allowed failed HC requests before the backend server is marked down.
        :param pulumi.Input[int] health_check_port: Port the HC requests will be send to.
        :param pulumi.Input[bool] health_check_send_proxy: Defines whether proxy protocol should be activated for the health check.
        :param pulumi.Input['LbBackendHealthCheckTcpArgs'] health_check_tcp: This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[str] health_check_timeout: Timeout before we consider a HC request failed.
        :param pulumi.Input[str] health_check_transient_delay: The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        :param pulumi.Input[bool] ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        :param pulumi.Input[int] max_connections: Maximum number of connections allowed per backend server.
        :param pulumi.Input[int] max_retries: Number of retries when a backend server connection failed.
        :param pulumi.Input[str] name: The name of the load-balancer backend.
        :param pulumi.Input[str] on_marked_down_action: Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        :param pulumi.Input[str] proxy_protocol: Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        :param pulumi.Input[int] redispatch_attempt_count: Whether to use another backend server on each attempt.
        :param pulumi.Input[bool] send_proxy_v2: DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_ips: List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        :param pulumi.Input[bool] ssl_bridging: Enables SSL between load balancer and backend servers.
        :param pulumi.Input[str] sticky_sessions: The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        :param pulumi.Input[str] sticky_sessions_cookie_name: Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        :param pulumi.Input[str] timeout_connect: Maximum initial server connection establishment time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_server: Maximum server connection inactivity time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_tunnel: Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        LbBackendArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forward_port=forward_port,
            forward_protocol=forward_protocol,
            lb_id=lb_id,
            failover_host=failover_host,
            forward_port_algorithm=forward_port_algorithm,
            health_check_delay=health_check_delay,
            health_check_http=health_check_http,
            health_check_https=health_check_https,
            health_check_max_retries=health_check_max_retries,
            health_check_port=health_check_port,
            health_check_send_proxy=health_check_send_proxy,
            health_check_tcp=health_check_tcp,
            health_check_timeout=health_check_timeout,
            health_check_transient_delay=health_check_transient_delay,
            ignore_ssl_server_verify=ignore_ssl_server_verify,
            max_connections=max_connections,
            max_retries=max_retries,
            name=name,
            on_marked_down_action=on_marked_down_action,
            proxy_protocol=proxy_protocol,
            redispatch_attempt_count=redispatch_attempt_count,
            send_proxy_v2=send_proxy_v2,
            server_ips=server_ips,
            ssl_bridging=ssl_bridging,
            sticky_sessions=sticky_sessions,
            sticky_sessions_cookie_name=sticky_sessions_cookie_name,
            timeout_connect=timeout_connect,
            timeout_queue=timeout_queue,
            timeout_server=timeout_server,
            timeout_tunnel=timeout_tunnel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forward_port: pulumi.Input[int],
             forward_protocol: pulumi.Input[str],
             lb_id: pulumi.Input[str],
             failover_host: Optional[pulumi.Input[str]] = None,
             forward_port_algorithm: Optional[pulumi.Input[str]] = None,
             health_check_delay: Optional[pulumi.Input[str]] = None,
             health_check_http: Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']] = None,
             health_check_https: Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']] = None,
             health_check_max_retries: Optional[pulumi.Input[int]] = None,
             health_check_port: Optional[pulumi.Input[int]] = None,
             health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
             health_check_tcp: Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']] = None,
             health_check_timeout: Optional[pulumi.Input[str]] = None,
             health_check_transient_delay: Optional[pulumi.Input[str]] = None,
             ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
             max_connections: Optional[pulumi.Input[int]] = None,
             max_retries: Optional[pulumi.Input[int]] = None,
             name: Optional[pulumi.Input[str]] = None,
             on_marked_down_action: Optional[pulumi.Input[str]] = None,
             proxy_protocol: Optional[pulumi.Input[str]] = None,
             redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
             send_proxy_v2: Optional[pulumi.Input[bool]] = None,
             server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ssl_bridging: Optional[pulumi.Input[bool]] = None,
             sticky_sessions: Optional[pulumi.Input[str]] = None,
             sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
             timeout_connect: Optional[pulumi.Input[str]] = None,
             timeout_queue: Optional[pulumi.Input[str]] = None,
             timeout_server: Optional[pulumi.Input[str]] = None,
             timeout_tunnel: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'forwardPort' in kwargs:
            forward_port = kwargs['forwardPort']
        if 'forwardProtocol' in kwargs:
            forward_protocol = kwargs['forwardProtocol']
        if 'lbId' in kwargs:
            lb_id = kwargs['lbId']
        if 'failoverHost' in kwargs:
            failover_host = kwargs['failoverHost']
        if 'forwardPortAlgorithm' in kwargs:
            forward_port_algorithm = kwargs['forwardPortAlgorithm']
        if 'healthCheckDelay' in kwargs:
            health_check_delay = kwargs['healthCheckDelay']
        if 'healthCheckHttp' in kwargs:
            health_check_http = kwargs['healthCheckHttp']
        if 'healthCheckHttps' in kwargs:
            health_check_https = kwargs['healthCheckHttps']
        if 'healthCheckMaxRetries' in kwargs:
            health_check_max_retries = kwargs['healthCheckMaxRetries']
        if 'healthCheckPort' in kwargs:
            health_check_port = kwargs['healthCheckPort']
        if 'healthCheckSendProxy' in kwargs:
            health_check_send_proxy = kwargs['healthCheckSendProxy']
        if 'healthCheckTcp' in kwargs:
            health_check_tcp = kwargs['healthCheckTcp']
        if 'healthCheckTimeout' in kwargs:
            health_check_timeout = kwargs['healthCheckTimeout']
        if 'healthCheckTransientDelay' in kwargs:
            health_check_transient_delay = kwargs['healthCheckTransientDelay']
        if 'ignoreSslServerVerify' in kwargs:
            ignore_ssl_server_verify = kwargs['ignoreSslServerVerify']
        if 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if 'onMarkedDownAction' in kwargs:
            on_marked_down_action = kwargs['onMarkedDownAction']
        if 'proxyProtocol' in kwargs:
            proxy_protocol = kwargs['proxyProtocol']
        if 'redispatchAttemptCount' in kwargs:
            redispatch_attempt_count = kwargs['redispatchAttemptCount']
        if 'sendProxyV2' in kwargs:
            send_proxy_v2 = kwargs['sendProxyV2']
        if 'serverIps' in kwargs:
            server_ips = kwargs['serverIps']
        if 'sslBridging' in kwargs:
            ssl_bridging = kwargs['sslBridging']
        if 'stickySessions' in kwargs:
            sticky_sessions = kwargs['stickySessions']
        if 'stickySessionsCookieName' in kwargs:
            sticky_sessions_cookie_name = kwargs['stickySessionsCookieName']
        if 'timeoutConnect' in kwargs:
            timeout_connect = kwargs['timeoutConnect']
        if 'timeoutQueue' in kwargs:
            timeout_queue = kwargs['timeoutQueue']
        if 'timeoutServer' in kwargs:
            timeout_server = kwargs['timeoutServer']
        if 'timeoutTunnel' in kwargs:
            timeout_tunnel = kwargs['timeoutTunnel']

        _setter("forward_port", forward_port)
        _setter("forward_protocol", forward_protocol)
        _setter("lb_id", lb_id)
        if failover_host is not None:
            _setter("failover_host", failover_host)
        if forward_port_algorithm is not None:
            _setter("forward_port_algorithm", forward_port_algorithm)
        if health_check_delay is not None:
            _setter("health_check_delay", health_check_delay)
        if health_check_http is not None:
            _setter("health_check_http", health_check_http)
        if health_check_https is not None:
            _setter("health_check_https", health_check_https)
        if health_check_max_retries is not None:
            _setter("health_check_max_retries", health_check_max_retries)
        if health_check_port is not None:
            _setter("health_check_port", health_check_port)
        if health_check_send_proxy is not None:
            _setter("health_check_send_proxy", health_check_send_proxy)
        if health_check_tcp is not None:
            _setter("health_check_tcp", health_check_tcp)
        if health_check_timeout is not None:
            _setter("health_check_timeout", health_check_timeout)
        if health_check_transient_delay is not None:
            _setter("health_check_transient_delay", health_check_transient_delay)
        if ignore_ssl_server_verify is not None:
            _setter("ignore_ssl_server_verify", ignore_ssl_server_verify)
        if max_connections is not None:
            _setter("max_connections", max_connections)
        if max_retries is not None:
            _setter("max_retries", max_retries)
        if name is not None:
            _setter("name", name)
        if on_marked_down_action is not None:
            _setter("on_marked_down_action", on_marked_down_action)
        if proxy_protocol is not None:
            _setter("proxy_protocol", proxy_protocol)
        if redispatch_attempt_count is not None:
            _setter("redispatch_attempt_count", redispatch_attempt_count)
        if send_proxy_v2 is not None:
            warnings.warn("""Please use proxy_protocol instead""", DeprecationWarning)
            pulumi.log.warn("""send_proxy_v2 is deprecated: Please use proxy_protocol instead""")
        if send_proxy_v2 is not None:
            _setter("send_proxy_v2", send_proxy_v2)
        if server_ips is not None:
            _setter("server_ips", server_ips)
        if ssl_bridging is not None:
            _setter("ssl_bridging", ssl_bridging)
        if sticky_sessions is not None:
            _setter("sticky_sessions", sticky_sessions)
        if sticky_sessions_cookie_name is not None:
            _setter("sticky_sessions_cookie_name", sticky_sessions_cookie_name)
        if timeout_connect is not None:
            _setter("timeout_connect", timeout_connect)
        if timeout_queue is not None:
            _setter("timeout_queue", timeout_queue)
        if timeout_server is not None:
            _setter("timeout_server", timeout_server)
        if timeout_tunnel is not None:
            _setter("timeout_tunnel", timeout_tunnel)

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> pulumi.Input[int]:
        """
        User sessions will be forwarded to this port of backend servers.
        """
        return pulumi.get(self, "forward_port")

    @forward_port.setter
    def forward_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "forward_port", value)

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> pulumi.Input[str]:
        """
        Backend protocol. Possible values are: `tcp` or `http`.
        """
        return pulumi.get(self, "forward_protocol")

    @forward_protocol.setter
    def forward_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "forward_protocol", value)

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> pulumi.Input[str]:
        """
        The load-balancer ID this backend is attached to.
        > **Important:** Updates to `lb_id` will recreate the backend.
        """
        return pulumi.get(self, "lb_id")

    @lb_id.setter
    def lb_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "lb_id", value)

    @property
    @pulumi.getter(name="failoverHost")
    def failover_host(self) -> Optional[pulumi.Input[str]]:
        """
        Scaleway S3 bucket website to be served in case all backend servers are down.
        > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
        e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        """
        return pulumi.get(self, "failover_host")

    @failover_host.setter
    def failover_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failover_host", value)

    @property
    @pulumi.getter(name="forwardPortAlgorithm")
    def forward_port_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        """
        return pulumi.get(self, "forward_port_algorithm")

    @forward_port_algorithm.setter
    def forward_port_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_port_algorithm", value)

    @property
    @pulumi.getter(name="healthCheckDelay")
    def health_check_delay(self) -> Optional[pulumi.Input[str]]:
        """
        Interval between two HC requests.
        """
        return pulumi.get(self, "health_check_delay")

    @health_check_delay.setter
    def health_check_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_delay", value)

    @property
    @pulumi.getter(name="healthCheckHttp")
    def health_check_http(self) -> Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']]:
        """
        This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_http")

    @health_check_http.setter
    def health_check_http(self, value: Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']]):
        pulumi.set(self, "health_check_http", value)

    @property
    @pulumi.getter(name="healthCheckHttps")
    def health_check_https(self) -> Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']]:
        """
        This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_https")

    @health_check_https.setter
    def health_check_https(self, value: Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']]):
        pulumi.set(self, "health_check_https", value)

    @property
    @pulumi.getter(name="healthCheckMaxRetries")
    def health_check_max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of allowed failed HC requests before the backend server is marked down.
        """
        return pulumi.get(self, "health_check_max_retries")

    @health_check_max_retries.setter
    def health_check_max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_max_retries", value)

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port the HC requests will be send to.
        """
        return pulumi.get(self, "health_check_port")

    @health_check_port.setter
    def health_check_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_port", value)

    @property
    @pulumi.getter(name="healthCheckSendProxy")
    def health_check_send_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether proxy protocol should be activated for the health check.
        """
        return pulumi.get(self, "health_check_send_proxy")

    @health_check_send_proxy.setter
    def health_check_send_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "health_check_send_proxy", value)

    @property
    @pulumi.getter(name="healthCheckTcp")
    def health_check_tcp(self) -> Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']]:
        """
        This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_tcp")

    @health_check_tcp.setter
    def health_check_tcp(self, value: Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']]):
        pulumi.set(self, "health_check_tcp", value)

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout before we consider a HC request failed.
        """
        return pulumi.get(self, "health_check_timeout")

    @health_check_timeout.setter
    def health_check_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_timeout", value)

    @property
    @pulumi.getter(name="healthCheckTransientDelay")
    def health_check_transient_delay(self) -> Optional[pulumi.Input[str]]:
        """
        The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        """
        return pulumi.get(self, "health_check_transient_delay")

    @health_check_transient_delay.setter
    def health_check_transient_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_transient_delay", value)

    @property
    @pulumi.getter(name="ignoreSslServerVerify")
    def ignore_ssl_server_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        """
        return pulumi.get(self, "ignore_ssl_server_verify")

    @ignore_ssl_server_verify.setter
    def ignore_ssl_server_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_ssl_server_verify", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of connections allowed per backend server.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries when a backend server connection failed.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the load-balancer backend.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="onMarkedDownAction")
    def on_marked_down_action(self) -> Optional[pulumi.Input[str]]:
        """
        Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        """
        return pulumi.get(self, "on_marked_down_action")

    @on_marked_down_action.setter
    def on_marked_down_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_marked_down_action", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)

    @property
    @pulumi.getter(name="redispatchAttemptCount")
    def redispatch_attempt_count(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to use another backend server on each attempt.
        """
        return pulumi.get(self, "redispatch_attempt_count")

    @redispatch_attempt_count.setter
    def redispatch_attempt_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redispatch_attempt_count", value)

    @property
    @pulumi.getter(name="sendProxyV2")
    def send_proxy_v2(self) -> Optional[pulumi.Input[bool]]:
        """
        DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        """
        warnings.warn("""Please use proxy_protocol instead""", DeprecationWarning)
        pulumi.log.warn("""send_proxy_v2 is deprecated: Please use proxy_protocol instead""")

        return pulumi.get(self, "send_proxy_v2")

    @send_proxy_v2.setter
    def send_proxy_v2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_proxy_v2", value)

    @property
    @pulumi.getter(name="serverIps")
    def server_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "server_ips")

    @server_ips.setter
    def server_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "server_ips", value)

    @property
    @pulumi.getter(name="sslBridging")
    def ssl_bridging(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables SSL between load balancer and backend servers.
        """
        return pulumi.get(self, "ssl_bridging")

    @ssl_bridging.setter
    def ssl_bridging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl_bridging", value)

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> Optional[pulumi.Input[str]]:
        """
        The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        """
        return pulumi.get(self, "sticky_sessions")

    @sticky_sessions.setter
    def sticky_sessions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sticky_sessions", value)

    @property
    @pulumi.getter(name="stickySessionsCookieName")
    def sticky_sessions_cookie_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        """
        return pulumi.get(self, "sticky_sessions_cookie_name")

    @sticky_sessions_cookie_name.setter
    def sticky_sessions_cookie_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sticky_sessions_cookie_name", value)

    @property
    @pulumi.getter(name="timeoutConnect")
    def timeout_connect(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum initial server connection establishment time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_connect")

    @timeout_connect.setter
    def timeout_connect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_connect", value)

    @property
    @pulumi.getter(name="timeoutQueue")
    def timeout_queue(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_queue")

    @timeout_queue.setter
    def timeout_queue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_queue", value)

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum server connection inactivity time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_server")

    @timeout_server.setter
    def timeout_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_server", value)

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_tunnel")

    @timeout_tunnel.setter
    def timeout_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_tunnel", value)


@pulumi.input_type
class _LbBackendState:
    def __init__(__self__, *,
                 failover_host: Optional[pulumi.Input[str]] = None,
                 forward_port: Optional[pulumi.Input[int]] = None,
                 forward_port_algorithm: Optional[pulumi.Input[str]] = None,
                 forward_protocol: Optional[pulumi.Input[str]] = None,
                 health_check_delay: Optional[pulumi.Input[str]] = None,
                 health_check_http: Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']] = None,
                 health_check_https: Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']] = None,
                 health_check_max_retries: Optional[pulumi.Input[int]] = None,
                 health_check_port: Optional[pulumi.Input[int]] = None,
                 health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
                 health_check_tcp: Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']] = None,
                 health_check_timeout: Optional[pulumi.Input[str]] = None,
                 health_check_transient_delay: Optional[pulumi.Input[str]] = None,
                 ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
                 lb_id: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_marked_down_action: Optional[pulumi.Input[str]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None,
                 redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
                 send_proxy_v2: Optional[pulumi.Input[bool]] = None,
                 server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_bridging: Optional[pulumi.Input[bool]] = None,
                 sticky_sessions: Optional[pulumi.Input[str]] = None,
                 sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
                 timeout_connect: Optional[pulumi.Input[str]] = None,
                 timeout_queue: Optional[pulumi.Input[str]] = None,
                 timeout_server: Optional[pulumi.Input[str]] = None,
                 timeout_tunnel: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering LbBackend resources.
        :param pulumi.Input[str] failover_host: Scaleway S3 bucket website to be served in case all backend servers are down.
               > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
               e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        :param pulumi.Input[int] forward_port: User sessions will be forwarded to this port of backend servers.
        :param pulumi.Input[str] forward_port_algorithm: Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        :param pulumi.Input[str] forward_protocol: Backend protocol. Possible values are: `tcp` or `http`.
        :param pulumi.Input[str] health_check_delay: Interval between two HC requests.
        :param pulumi.Input['LbBackendHealthCheckHttpArgs'] health_check_http: This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input['LbBackendHealthCheckHttpsArgs'] health_check_https: This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[int] health_check_max_retries: Number of allowed failed HC requests before the backend server is marked down.
        :param pulumi.Input[int] health_check_port: Port the HC requests will be send to.
        :param pulumi.Input[bool] health_check_send_proxy: Defines whether proxy protocol should be activated for the health check.
        :param pulumi.Input['LbBackendHealthCheckTcpArgs'] health_check_tcp: This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[str] health_check_timeout: Timeout before we consider a HC request failed.
        :param pulumi.Input[str] health_check_transient_delay: The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        :param pulumi.Input[bool] ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        :param pulumi.Input[str] lb_id: The load-balancer ID this backend is attached to.
               > **Important:** Updates to `lb_id` will recreate the backend.
        :param pulumi.Input[int] max_connections: Maximum number of connections allowed per backend server.
        :param pulumi.Input[int] max_retries: Number of retries when a backend server connection failed.
        :param pulumi.Input[str] name: The name of the load-balancer backend.
        :param pulumi.Input[str] on_marked_down_action: Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        :param pulumi.Input[str] proxy_protocol: Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        :param pulumi.Input[int] redispatch_attempt_count: Whether to use another backend server on each attempt.
        :param pulumi.Input[bool] send_proxy_v2: DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_ips: List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        :param pulumi.Input[bool] ssl_bridging: Enables SSL between load balancer and backend servers.
        :param pulumi.Input[str] sticky_sessions: The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        :param pulumi.Input[str] sticky_sessions_cookie_name: Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        :param pulumi.Input[str] timeout_connect: Maximum initial server connection establishment time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_server: Maximum server connection inactivity time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_tunnel: Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        _LbBackendState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            failover_host=failover_host,
            forward_port=forward_port,
            forward_port_algorithm=forward_port_algorithm,
            forward_protocol=forward_protocol,
            health_check_delay=health_check_delay,
            health_check_http=health_check_http,
            health_check_https=health_check_https,
            health_check_max_retries=health_check_max_retries,
            health_check_port=health_check_port,
            health_check_send_proxy=health_check_send_proxy,
            health_check_tcp=health_check_tcp,
            health_check_timeout=health_check_timeout,
            health_check_transient_delay=health_check_transient_delay,
            ignore_ssl_server_verify=ignore_ssl_server_verify,
            lb_id=lb_id,
            max_connections=max_connections,
            max_retries=max_retries,
            name=name,
            on_marked_down_action=on_marked_down_action,
            proxy_protocol=proxy_protocol,
            redispatch_attempt_count=redispatch_attempt_count,
            send_proxy_v2=send_proxy_v2,
            server_ips=server_ips,
            ssl_bridging=ssl_bridging,
            sticky_sessions=sticky_sessions,
            sticky_sessions_cookie_name=sticky_sessions_cookie_name,
            timeout_connect=timeout_connect,
            timeout_queue=timeout_queue,
            timeout_server=timeout_server,
            timeout_tunnel=timeout_tunnel,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             failover_host: Optional[pulumi.Input[str]] = None,
             forward_port: Optional[pulumi.Input[int]] = None,
             forward_port_algorithm: Optional[pulumi.Input[str]] = None,
             forward_protocol: Optional[pulumi.Input[str]] = None,
             health_check_delay: Optional[pulumi.Input[str]] = None,
             health_check_http: Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']] = None,
             health_check_https: Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']] = None,
             health_check_max_retries: Optional[pulumi.Input[int]] = None,
             health_check_port: Optional[pulumi.Input[int]] = None,
             health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
             health_check_tcp: Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']] = None,
             health_check_timeout: Optional[pulumi.Input[str]] = None,
             health_check_transient_delay: Optional[pulumi.Input[str]] = None,
             ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
             lb_id: Optional[pulumi.Input[str]] = None,
             max_connections: Optional[pulumi.Input[int]] = None,
             max_retries: Optional[pulumi.Input[int]] = None,
             name: Optional[pulumi.Input[str]] = None,
             on_marked_down_action: Optional[pulumi.Input[str]] = None,
             proxy_protocol: Optional[pulumi.Input[str]] = None,
             redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
             send_proxy_v2: Optional[pulumi.Input[bool]] = None,
             server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             ssl_bridging: Optional[pulumi.Input[bool]] = None,
             sticky_sessions: Optional[pulumi.Input[str]] = None,
             sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
             timeout_connect: Optional[pulumi.Input[str]] = None,
             timeout_queue: Optional[pulumi.Input[str]] = None,
             timeout_server: Optional[pulumi.Input[str]] = None,
             timeout_tunnel: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'failoverHost' in kwargs:
            failover_host = kwargs['failoverHost']
        if 'forwardPort' in kwargs:
            forward_port = kwargs['forwardPort']
        if 'forwardPortAlgorithm' in kwargs:
            forward_port_algorithm = kwargs['forwardPortAlgorithm']
        if 'forwardProtocol' in kwargs:
            forward_protocol = kwargs['forwardProtocol']
        if 'healthCheckDelay' in kwargs:
            health_check_delay = kwargs['healthCheckDelay']
        if 'healthCheckHttp' in kwargs:
            health_check_http = kwargs['healthCheckHttp']
        if 'healthCheckHttps' in kwargs:
            health_check_https = kwargs['healthCheckHttps']
        if 'healthCheckMaxRetries' in kwargs:
            health_check_max_retries = kwargs['healthCheckMaxRetries']
        if 'healthCheckPort' in kwargs:
            health_check_port = kwargs['healthCheckPort']
        if 'healthCheckSendProxy' in kwargs:
            health_check_send_proxy = kwargs['healthCheckSendProxy']
        if 'healthCheckTcp' in kwargs:
            health_check_tcp = kwargs['healthCheckTcp']
        if 'healthCheckTimeout' in kwargs:
            health_check_timeout = kwargs['healthCheckTimeout']
        if 'healthCheckTransientDelay' in kwargs:
            health_check_transient_delay = kwargs['healthCheckTransientDelay']
        if 'ignoreSslServerVerify' in kwargs:
            ignore_ssl_server_verify = kwargs['ignoreSslServerVerify']
        if 'lbId' in kwargs:
            lb_id = kwargs['lbId']
        if 'maxConnections' in kwargs:
            max_connections = kwargs['maxConnections']
        if 'maxRetries' in kwargs:
            max_retries = kwargs['maxRetries']
        if 'onMarkedDownAction' in kwargs:
            on_marked_down_action = kwargs['onMarkedDownAction']
        if 'proxyProtocol' in kwargs:
            proxy_protocol = kwargs['proxyProtocol']
        if 'redispatchAttemptCount' in kwargs:
            redispatch_attempt_count = kwargs['redispatchAttemptCount']
        if 'sendProxyV2' in kwargs:
            send_proxy_v2 = kwargs['sendProxyV2']
        if 'serverIps' in kwargs:
            server_ips = kwargs['serverIps']
        if 'sslBridging' in kwargs:
            ssl_bridging = kwargs['sslBridging']
        if 'stickySessions' in kwargs:
            sticky_sessions = kwargs['stickySessions']
        if 'stickySessionsCookieName' in kwargs:
            sticky_sessions_cookie_name = kwargs['stickySessionsCookieName']
        if 'timeoutConnect' in kwargs:
            timeout_connect = kwargs['timeoutConnect']
        if 'timeoutQueue' in kwargs:
            timeout_queue = kwargs['timeoutQueue']
        if 'timeoutServer' in kwargs:
            timeout_server = kwargs['timeoutServer']
        if 'timeoutTunnel' in kwargs:
            timeout_tunnel = kwargs['timeoutTunnel']

        if failover_host is not None:
            _setter("failover_host", failover_host)
        if forward_port is not None:
            _setter("forward_port", forward_port)
        if forward_port_algorithm is not None:
            _setter("forward_port_algorithm", forward_port_algorithm)
        if forward_protocol is not None:
            _setter("forward_protocol", forward_protocol)
        if health_check_delay is not None:
            _setter("health_check_delay", health_check_delay)
        if health_check_http is not None:
            _setter("health_check_http", health_check_http)
        if health_check_https is not None:
            _setter("health_check_https", health_check_https)
        if health_check_max_retries is not None:
            _setter("health_check_max_retries", health_check_max_retries)
        if health_check_port is not None:
            _setter("health_check_port", health_check_port)
        if health_check_send_proxy is not None:
            _setter("health_check_send_proxy", health_check_send_proxy)
        if health_check_tcp is not None:
            _setter("health_check_tcp", health_check_tcp)
        if health_check_timeout is not None:
            _setter("health_check_timeout", health_check_timeout)
        if health_check_transient_delay is not None:
            _setter("health_check_transient_delay", health_check_transient_delay)
        if ignore_ssl_server_verify is not None:
            _setter("ignore_ssl_server_verify", ignore_ssl_server_verify)
        if lb_id is not None:
            _setter("lb_id", lb_id)
        if max_connections is not None:
            _setter("max_connections", max_connections)
        if max_retries is not None:
            _setter("max_retries", max_retries)
        if name is not None:
            _setter("name", name)
        if on_marked_down_action is not None:
            _setter("on_marked_down_action", on_marked_down_action)
        if proxy_protocol is not None:
            _setter("proxy_protocol", proxy_protocol)
        if redispatch_attempt_count is not None:
            _setter("redispatch_attempt_count", redispatch_attempt_count)
        if send_proxy_v2 is not None:
            warnings.warn("""Please use proxy_protocol instead""", DeprecationWarning)
            pulumi.log.warn("""send_proxy_v2 is deprecated: Please use proxy_protocol instead""")
        if send_proxy_v2 is not None:
            _setter("send_proxy_v2", send_proxy_v2)
        if server_ips is not None:
            _setter("server_ips", server_ips)
        if ssl_bridging is not None:
            _setter("ssl_bridging", ssl_bridging)
        if sticky_sessions is not None:
            _setter("sticky_sessions", sticky_sessions)
        if sticky_sessions_cookie_name is not None:
            _setter("sticky_sessions_cookie_name", sticky_sessions_cookie_name)
        if timeout_connect is not None:
            _setter("timeout_connect", timeout_connect)
        if timeout_queue is not None:
            _setter("timeout_queue", timeout_queue)
        if timeout_server is not None:
            _setter("timeout_server", timeout_server)
        if timeout_tunnel is not None:
            _setter("timeout_tunnel", timeout_tunnel)

    @property
    @pulumi.getter(name="failoverHost")
    def failover_host(self) -> Optional[pulumi.Input[str]]:
        """
        Scaleway S3 bucket website to be served in case all backend servers are down.
        > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
        e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        """
        return pulumi.get(self, "failover_host")

    @failover_host.setter
    def failover_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "failover_host", value)

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> Optional[pulumi.Input[int]]:
        """
        User sessions will be forwarded to this port of backend servers.
        """
        return pulumi.get(self, "forward_port")

    @forward_port.setter
    def forward_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "forward_port", value)

    @property
    @pulumi.getter(name="forwardPortAlgorithm")
    def forward_port_algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        """
        return pulumi.get(self, "forward_port_algorithm")

    @forward_port_algorithm.setter
    def forward_port_algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_port_algorithm", value)

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Backend protocol. Possible values are: `tcp` or `http`.
        """
        return pulumi.get(self, "forward_protocol")

    @forward_protocol.setter
    def forward_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "forward_protocol", value)

    @property
    @pulumi.getter(name="healthCheckDelay")
    def health_check_delay(self) -> Optional[pulumi.Input[str]]:
        """
        Interval between two HC requests.
        """
        return pulumi.get(self, "health_check_delay")

    @health_check_delay.setter
    def health_check_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_delay", value)

    @property
    @pulumi.getter(name="healthCheckHttp")
    def health_check_http(self) -> Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']]:
        """
        This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_http")

    @health_check_http.setter
    def health_check_http(self, value: Optional[pulumi.Input['LbBackendHealthCheckHttpArgs']]):
        pulumi.set(self, "health_check_http", value)

    @property
    @pulumi.getter(name="healthCheckHttps")
    def health_check_https(self) -> Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']]:
        """
        This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_https")

    @health_check_https.setter
    def health_check_https(self, value: Optional[pulumi.Input['LbBackendHealthCheckHttpsArgs']]):
        pulumi.set(self, "health_check_https", value)

    @property
    @pulumi.getter(name="healthCheckMaxRetries")
    def health_check_max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of allowed failed HC requests before the backend server is marked down.
        """
        return pulumi.get(self, "health_check_max_retries")

    @health_check_max_retries.setter
    def health_check_max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_max_retries", value)

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port the HC requests will be send to.
        """
        return pulumi.get(self, "health_check_port")

    @health_check_port.setter
    def health_check_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "health_check_port", value)

    @property
    @pulumi.getter(name="healthCheckSendProxy")
    def health_check_send_proxy(self) -> Optional[pulumi.Input[bool]]:
        """
        Defines whether proxy protocol should be activated for the health check.
        """
        return pulumi.get(self, "health_check_send_proxy")

    @health_check_send_proxy.setter
    def health_check_send_proxy(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "health_check_send_proxy", value)

    @property
    @pulumi.getter(name="healthCheckTcp")
    def health_check_tcp(self) -> Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']]:
        """
        This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_tcp")

    @health_check_tcp.setter
    def health_check_tcp(self, value: Optional[pulumi.Input['LbBackendHealthCheckTcpArgs']]):
        pulumi.set(self, "health_check_tcp", value)

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout before we consider a HC request failed.
        """
        return pulumi.get(self, "health_check_timeout")

    @health_check_timeout.setter
    def health_check_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_timeout", value)

    @property
    @pulumi.getter(name="healthCheckTransientDelay")
    def health_check_transient_delay(self) -> Optional[pulumi.Input[str]]:
        """
        The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        """
        return pulumi.get(self, "health_check_transient_delay")

    @health_check_transient_delay.setter
    def health_check_transient_delay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "health_check_transient_delay", value)

    @property
    @pulumi.getter(name="ignoreSslServerVerify")
    def ignore_ssl_server_verify(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        """
        return pulumi.get(self, "ignore_ssl_server_verify")

    @ignore_ssl_server_verify.setter
    def ignore_ssl_server_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_ssl_server_verify", value)

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> Optional[pulumi.Input[str]]:
        """
        The load-balancer ID this backend is attached to.
        > **Important:** Updates to `lb_id` will recreate the backend.
        """
        return pulumi.get(self, "lb_id")

    @lb_id.setter
    def lb_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lb_id", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of connections allowed per backend server.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries when a backend server connection failed.
        """
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the load-balancer backend.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="onMarkedDownAction")
    def on_marked_down_action(self) -> Optional[pulumi.Input[str]]:
        """
        Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        """
        return pulumi.get(self, "on_marked_down_action")

    @on_marked_down_action.setter
    def on_marked_down_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_marked_down_action", value)

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        """
        return pulumi.get(self, "proxy_protocol")

    @proxy_protocol.setter
    def proxy_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "proxy_protocol", value)

    @property
    @pulumi.getter(name="redispatchAttemptCount")
    def redispatch_attempt_count(self) -> Optional[pulumi.Input[int]]:
        """
        Whether to use another backend server on each attempt.
        """
        return pulumi.get(self, "redispatch_attempt_count")

    @redispatch_attempt_count.setter
    def redispatch_attempt_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redispatch_attempt_count", value)

    @property
    @pulumi.getter(name="sendProxyV2")
    def send_proxy_v2(self) -> Optional[pulumi.Input[bool]]:
        """
        DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        """
        warnings.warn("""Please use proxy_protocol instead""", DeprecationWarning)
        pulumi.log.warn("""send_proxy_v2 is deprecated: Please use proxy_protocol instead""")

        return pulumi.get(self, "send_proxy_v2")

    @send_proxy_v2.setter
    def send_proxy_v2(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "send_proxy_v2", value)

    @property
    @pulumi.getter(name="serverIps")
    def server_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "server_ips")

    @server_ips.setter
    def server_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "server_ips", value)

    @property
    @pulumi.getter(name="sslBridging")
    def ssl_bridging(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables SSL between load balancer and backend servers.
        """
        return pulumi.get(self, "ssl_bridging")

    @ssl_bridging.setter
    def ssl_bridging(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ssl_bridging", value)

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> Optional[pulumi.Input[str]]:
        """
        The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        """
        return pulumi.get(self, "sticky_sessions")

    @sticky_sessions.setter
    def sticky_sessions(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sticky_sessions", value)

    @property
    @pulumi.getter(name="stickySessionsCookieName")
    def sticky_sessions_cookie_name(self) -> Optional[pulumi.Input[str]]:
        """
        Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        """
        return pulumi.get(self, "sticky_sessions_cookie_name")

    @sticky_sessions_cookie_name.setter
    def sticky_sessions_cookie_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sticky_sessions_cookie_name", value)

    @property
    @pulumi.getter(name="timeoutConnect")
    def timeout_connect(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum initial server connection establishment time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_connect")

    @timeout_connect.setter
    def timeout_connect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_connect", value)

    @property
    @pulumi.getter(name="timeoutQueue")
    def timeout_queue(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_queue")

    @timeout_queue.setter
    def timeout_queue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_queue", value)

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum server connection inactivity time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_server")

    @timeout_server.setter
    def timeout_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_server", value)

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_tunnel")

    @timeout_tunnel.setter
    def timeout_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout_tunnel", value)


class LbBackend(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 failover_host: Optional[pulumi.Input[str]] = None,
                 forward_port: Optional[pulumi.Input[int]] = None,
                 forward_port_algorithm: Optional[pulumi.Input[str]] = None,
                 forward_protocol: Optional[pulumi.Input[str]] = None,
                 health_check_delay: Optional[pulumi.Input[str]] = None,
                 health_check_http: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpArgs']]] = None,
                 health_check_https: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpsArgs']]] = None,
                 health_check_max_retries: Optional[pulumi.Input[int]] = None,
                 health_check_port: Optional[pulumi.Input[int]] = None,
                 health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
                 health_check_tcp: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckTcpArgs']]] = None,
                 health_check_timeout: Optional[pulumi.Input[str]] = None,
                 health_check_transient_delay: Optional[pulumi.Input[str]] = None,
                 ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
                 lb_id: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_marked_down_action: Optional[pulumi.Input[str]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None,
                 redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
                 send_proxy_v2: Optional[pulumi.Input[bool]] = None,
                 server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_bridging: Optional[pulumi.Input[bool]] = None,
                 sticky_sessions: Optional[pulumi.Input[str]] = None,
                 sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
                 timeout_connect: Optional[pulumi.Input[str]] = None,
                 timeout_queue: Optional[pulumi.Input[str]] = None,
                 timeout_server: Optional[pulumi.Input[str]] = None,
                 timeout_tunnel: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Creates and manages Scaleway Load-Balancer Backends.
        For more information, see [the documentation](https://www.scaleway.com/en/developers/api/load-balancer/zoned-api/#path-backends).

        ## Examples

        ### Basic

        ```python
        import pulumi
        import ediri_scaleway as scaleway

        backend01 = scaleway.LbBackend("backend01",
            lb_id=scaleway_lb["lb01"]["id"],
            forward_protocol="http",
            forward_port=80)
        ```

        ### With HTTP Health Check

        ```python
        import pulumi
        import ediri_scaleway as scaleway

        backend01 = scaleway.LbBackend("backend01",
            lb_id=scaleway_lb["lb01"]["id"],
            forward_protocol="http",
            forward_port=80,
            health_check_http=scaleway.LbBackendHealthCheckHttpArgs(
                uri="www.test.com/health",
            ))
        ```

        ## Import

        Load-Balancer backend can be imported using the `{zone}/{id}`, e.g. bash

        ```sh
         $ pulumi import scaleway:index/lbBackend:LbBackend backend01 fr-par-1/11111111-1111-1111-1111-111111111111
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] failover_host: Scaleway S3 bucket website to be served in case all backend servers are down.
               > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
               e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        :param pulumi.Input[int] forward_port: User sessions will be forwarded to this port of backend servers.
        :param pulumi.Input[str] forward_port_algorithm: Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        :param pulumi.Input[str] forward_protocol: Backend protocol. Possible values are: `tcp` or `http`.
        :param pulumi.Input[str] health_check_delay: Interval between two HC requests.
        :param pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpArgs']] health_check_http: This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpsArgs']] health_check_https: This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[int] health_check_max_retries: Number of allowed failed HC requests before the backend server is marked down.
        :param pulumi.Input[int] health_check_port: Port the HC requests will be send to.
        :param pulumi.Input[bool] health_check_send_proxy: Defines whether proxy protocol should be activated for the health check.
        :param pulumi.Input[pulumi.InputType['LbBackendHealthCheckTcpArgs']] health_check_tcp: This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[str] health_check_timeout: Timeout before we consider a HC request failed.
        :param pulumi.Input[str] health_check_transient_delay: The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        :param pulumi.Input[bool] ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        :param pulumi.Input[str] lb_id: The load-balancer ID this backend is attached to.
               > **Important:** Updates to `lb_id` will recreate the backend.
        :param pulumi.Input[int] max_connections: Maximum number of connections allowed per backend server.
        :param pulumi.Input[int] max_retries: Number of retries when a backend server connection failed.
        :param pulumi.Input[str] name: The name of the load-balancer backend.
        :param pulumi.Input[str] on_marked_down_action: Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        :param pulumi.Input[str] proxy_protocol: Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        :param pulumi.Input[int] redispatch_attempt_count: Whether to use another backend server on each attempt.
        :param pulumi.Input[bool] send_proxy_v2: DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_ips: List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        :param pulumi.Input[bool] ssl_bridging: Enables SSL between load balancer and backend servers.
        :param pulumi.Input[str] sticky_sessions: The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        :param pulumi.Input[str] sticky_sessions_cookie_name: Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        :param pulumi.Input[str] timeout_connect: Maximum initial server connection establishment time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_server: Maximum server connection inactivity time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_tunnel: Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: LbBackendArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Creates and manages Scaleway Load-Balancer Backends.
        For more information, see [the documentation](https://www.scaleway.com/en/developers/api/load-balancer/zoned-api/#path-backends).

        ## Examples

        ### Basic

        ```python
        import pulumi
        import ediri_scaleway as scaleway

        backend01 = scaleway.LbBackend("backend01",
            lb_id=scaleway_lb["lb01"]["id"],
            forward_protocol="http",
            forward_port=80)
        ```

        ### With HTTP Health Check

        ```python
        import pulumi
        import ediri_scaleway as scaleway

        backend01 = scaleway.LbBackend("backend01",
            lb_id=scaleway_lb["lb01"]["id"],
            forward_protocol="http",
            forward_port=80,
            health_check_http=scaleway.LbBackendHealthCheckHttpArgs(
                uri="www.test.com/health",
            ))
        ```

        ## Import

        Load-Balancer backend can be imported using the `{zone}/{id}`, e.g. bash

        ```sh
         $ pulumi import scaleway:index/lbBackend:LbBackend backend01 fr-par-1/11111111-1111-1111-1111-111111111111
        ```

        :param str resource_name: The name of the resource.
        :param LbBackendArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(LbBackendArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            kwargs = kwargs or {}
            def _setter(key, value):
                kwargs[key] = value
            LbBackendArgs._configure(_setter, **kwargs)
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 failover_host: Optional[pulumi.Input[str]] = None,
                 forward_port: Optional[pulumi.Input[int]] = None,
                 forward_port_algorithm: Optional[pulumi.Input[str]] = None,
                 forward_protocol: Optional[pulumi.Input[str]] = None,
                 health_check_delay: Optional[pulumi.Input[str]] = None,
                 health_check_http: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpArgs']]] = None,
                 health_check_https: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpsArgs']]] = None,
                 health_check_max_retries: Optional[pulumi.Input[int]] = None,
                 health_check_port: Optional[pulumi.Input[int]] = None,
                 health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
                 health_check_tcp: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckTcpArgs']]] = None,
                 health_check_timeout: Optional[pulumi.Input[str]] = None,
                 health_check_transient_delay: Optional[pulumi.Input[str]] = None,
                 ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
                 lb_id: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_marked_down_action: Optional[pulumi.Input[str]] = None,
                 proxy_protocol: Optional[pulumi.Input[str]] = None,
                 redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
                 send_proxy_v2: Optional[pulumi.Input[bool]] = None,
                 server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ssl_bridging: Optional[pulumi.Input[bool]] = None,
                 sticky_sessions: Optional[pulumi.Input[str]] = None,
                 sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
                 timeout_connect: Optional[pulumi.Input[str]] = None,
                 timeout_queue: Optional[pulumi.Input[str]] = None,
                 timeout_server: Optional[pulumi.Input[str]] = None,
                 timeout_tunnel: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = LbBackendArgs.__new__(LbBackendArgs)

            __props__.__dict__["failover_host"] = failover_host
            if forward_port is None and not opts.urn:
                raise TypeError("Missing required property 'forward_port'")
            __props__.__dict__["forward_port"] = forward_port
            __props__.__dict__["forward_port_algorithm"] = forward_port_algorithm
            if forward_protocol is None and not opts.urn:
                raise TypeError("Missing required property 'forward_protocol'")
            __props__.__dict__["forward_protocol"] = forward_protocol
            __props__.__dict__["health_check_delay"] = health_check_delay
            if health_check_http is not None and not isinstance(health_check_http, LbBackendHealthCheckHttpArgs):
                health_check_http = health_check_http or {}
                def _setter(key, value):
                    health_check_http[key] = value
                LbBackendHealthCheckHttpArgs._configure(_setter, **health_check_http)
            __props__.__dict__["health_check_http"] = health_check_http
            if health_check_https is not None and not isinstance(health_check_https, LbBackendHealthCheckHttpsArgs):
                health_check_https = health_check_https or {}
                def _setter(key, value):
                    health_check_https[key] = value
                LbBackendHealthCheckHttpsArgs._configure(_setter, **health_check_https)
            __props__.__dict__["health_check_https"] = health_check_https
            __props__.__dict__["health_check_max_retries"] = health_check_max_retries
            __props__.__dict__["health_check_port"] = health_check_port
            __props__.__dict__["health_check_send_proxy"] = health_check_send_proxy
            if health_check_tcp is not None and not isinstance(health_check_tcp, LbBackendHealthCheckTcpArgs):
                health_check_tcp = health_check_tcp or {}
                def _setter(key, value):
                    health_check_tcp[key] = value
                LbBackendHealthCheckTcpArgs._configure(_setter, **health_check_tcp)
            __props__.__dict__["health_check_tcp"] = health_check_tcp
            __props__.__dict__["health_check_timeout"] = health_check_timeout
            __props__.__dict__["health_check_transient_delay"] = health_check_transient_delay
            __props__.__dict__["ignore_ssl_server_verify"] = ignore_ssl_server_verify
            if lb_id is None and not opts.urn:
                raise TypeError("Missing required property 'lb_id'")
            __props__.__dict__["lb_id"] = lb_id
            __props__.__dict__["max_connections"] = max_connections
            __props__.__dict__["max_retries"] = max_retries
            __props__.__dict__["name"] = name
            __props__.__dict__["on_marked_down_action"] = on_marked_down_action
            __props__.__dict__["proxy_protocol"] = proxy_protocol
            __props__.__dict__["redispatch_attempt_count"] = redispatch_attempt_count
            __props__.__dict__["send_proxy_v2"] = send_proxy_v2
            __props__.__dict__["server_ips"] = server_ips
            __props__.__dict__["ssl_bridging"] = ssl_bridging
            __props__.__dict__["sticky_sessions"] = sticky_sessions
            __props__.__dict__["sticky_sessions_cookie_name"] = sticky_sessions_cookie_name
            __props__.__dict__["timeout_connect"] = timeout_connect
            __props__.__dict__["timeout_queue"] = timeout_queue
            __props__.__dict__["timeout_server"] = timeout_server
            __props__.__dict__["timeout_tunnel"] = timeout_tunnel
        super(LbBackend, __self__).__init__(
            'scaleway:index/lbBackend:LbBackend',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            failover_host: Optional[pulumi.Input[str]] = None,
            forward_port: Optional[pulumi.Input[int]] = None,
            forward_port_algorithm: Optional[pulumi.Input[str]] = None,
            forward_protocol: Optional[pulumi.Input[str]] = None,
            health_check_delay: Optional[pulumi.Input[str]] = None,
            health_check_http: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpArgs']]] = None,
            health_check_https: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpsArgs']]] = None,
            health_check_max_retries: Optional[pulumi.Input[int]] = None,
            health_check_port: Optional[pulumi.Input[int]] = None,
            health_check_send_proxy: Optional[pulumi.Input[bool]] = None,
            health_check_tcp: Optional[pulumi.Input[pulumi.InputType['LbBackendHealthCheckTcpArgs']]] = None,
            health_check_timeout: Optional[pulumi.Input[str]] = None,
            health_check_transient_delay: Optional[pulumi.Input[str]] = None,
            ignore_ssl_server_verify: Optional[pulumi.Input[bool]] = None,
            lb_id: Optional[pulumi.Input[str]] = None,
            max_connections: Optional[pulumi.Input[int]] = None,
            max_retries: Optional[pulumi.Input[int]] = None,
            name: Optional[pulumi.Input[str]] = None,
            on_marked_down_action: Optional[pulumi.Input[str]] = None,
            proxy_protocol: Optional[pulumi.Input[str]] = None,
            redispatch_attempt_count: Optional[pulumi.Input[int]] = None,
            send_proxy_v2: Optional[pulumi.Input[bool]] = None,
            server_ips: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            ssl_bridging: Optional[pulumi.Input[bool]] = None,
            sticky_sessions: Optional[pulumi.Input[str]] = None,
            sticky_sessions_cookie_name: Optional[pulumi.Input[str]] = None,
            timeout_connect: Optional[pulumi.Input[str]] = None,
            timeout_queue: Optional[pulumi.Input[str]] = None,
            timeout_server: Optional[pulumi.Input[str]] = None,
            timeout_tunnel: Optional[pulumi.Input[str]] = None) -> 'LbBackend':
        """
        Get an existing LbBackend resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] failover_host: Scaleway S3 bucket website to be served in case all backend servers are down.
               > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
               e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        :param pulumi.Input[int] forward_port: User sessions will be forwarded to this port of backend servers.
        :param pulumi.Input[str] forward_port_algorithm: Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        :param pulumi.Input[str] forward_protocol: Backend protocol. Possible values are: `tcp` or `http`.
        :param pulumi.Input[str] health_check_delay: Interval between two HC requests.
        :param pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpArgs']] health_check_http: This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[pulumi.InputType['LbBackendHealthCheckHttpsArgs']] health_check_https: This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[int] health_check_max_retries: Number of allowed failed HC requests before the backend server is marked down.
        :param pulumi.Input[int] health_check_port: Port the HC requests will be send to.
        :param pulumi.Input[bool] health_check_send_proxy: Defines whether proxy protocol should be activated for the health check.
        :param pulumi.Input[pulumi.InputType['LbBackendHealthCheckTcpArgs']] health_check_tcp: This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        :param pulumi.Input[str] health_check_timeout: Timeout before we consider a HC request failed.
        :param pulumi.Input[str] health_check_transient_delay: The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        :param pulumi.Input[bool] ignore_ssl_server_verify: Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        :param pulumi.Input[str] lb_id: The load-balancer ID this backend is attached to.
               > **Important:** Updates to `lb_id` will recreate the backend.
        :param pulumi.Input[int] max_connections: Maximum number of connections allowed per backend server.
        :param pulumi.Input[int] max_retries: Number of retries when a backend server connection failed.
        :param pulumi.Input[str] name: The name of the load-balancer backend.
        :param pulumi.Input[str] on_marked_down_action: Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        :param pulumi.Input[str] proxy_protocol: Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        :param pulumi.Input[int] redispatch_attempt_count: Whether to use another backend server on each attempt.
        :param pulumi.Input[bool] send_proxy_v2: DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] server_ips: List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        :param pulumi.Input[bool] ssl_bridging: Enables SSL between load balancer and backend servers.
        :param pulumi.Input[str] sticky_sessions: The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        :param pulumi.Input[str] sticky_sessions_cookie_name: Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        :param pulumi.Input[str] timeout_connect: Maximum initial server connection establishment time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_queue: Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_server: Maximum server connection inactivity time. (e.g.: `1s`)
        :param pulumi.Input[str] timeout_tunnel: Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _LbBackendState.__new__(_LbBackendState)

        __props__.__dict__["failover_host"] = failover_host
        __props__.__dict__["forward_port"] = forward_port
        __props__.__dict__["forward_port_algorithm"] = forward_port_algorithm
        __props__.__dict__["forward_protocol"] = forward_protocol
        __props__.__dict__["health_check_delay"] = health_check_delay
        __props__.__dict__["health_check_http"] = health_check_http
        __props__.__dict__["health_check_https"] = health_check_https
        __props__.__dict__["health_check_max_retries"] = health_check_max_retries
        __props__.__dict__["health_check_port"] = health_check_port
        __props__.__dict__["health_check_send_proxy"] = health_check_send_proxy
        __props__.__dict__["health_check_tcp"] = health_check_tcp
        __props__.__dict__["health_check_timeout"] = health_check_timeout
        __props__.__dict__["health_check_transient_delay"] = health_check_transient_delay
        __props__.__dict__["ignore_ssl_server_verify"] = ignore_ssl_server_verify
        __props__.__dict__["lb_id"] = lb_id
        __props__.__dict__["max_connections"] = max_connections
        __props__.__dict__["max_retries"] = max_retries
        __props__.__dict__["name"] = name
        __props__.__dict__["on_marked_down_action"] = on_marked_down_action
        __props__.__dict__["proxy_protocol"] = proxy_protocol
        __props__.__dict__["redispatch_attempt_count"] = redispatch_attempt_count
        __props__.__dict__["send_proxy_v2"] = send_proxy_v2
        __props__.__dict__["server_ips"] = server_ips
        __props__.__dict__["ssl_bridging"] = ssl_bridging
        __props__.__dict__["sticky_sessions"] = sticky_sessions
        __props__.__dict__["sticky_sessions_cookie_name"] = sticky_sessions_cookie_name
        __props__.__dict__["timeout_connect"] = timeout_connect
        __props__.__dict__["timeout_queue"] = timeout_queue
        __props__.__dict__["timeout_server"] = timeout_server
        __props__.__dict__["timeout_tunnel"] = timeout_tunnel
        return LbBackend(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter(name="failoverHost")
    def failover_host(self) -> pulumi.Output[Optional[str]]:
        """
        Scaleway S3 bucket website to be served in case all backend servers are down.
        > **Note:** Only the host part of the Scaleway S3 bucket website is expected:
        e.g. 'failover-website.s3-website.fr-par.scw.cloud' if your bucket website URL is 'https://failover-website.s3-website.fr-par.scw.cloud/'.
        """
        return pulumi.get(self, "failover_host")

    @property
    @pulumi.getter(name="forwardPort")
    def forward_port(self) -> pulumi.Output[int]:
        """
        User sessions will be forwarded to this port of backend servers.
        """
        return pulumi.get(self, "forward_port")

    @property
    @pulumi.getter(name="forwardPortAlgorithm")
    def forward_port_algorithm(self) -> pulumi.Output[Optional[str]]:
        """
        Load balancing algorithm. Possible values are: `roundrobin`, `leastconn` and `first`.
        """
        return pulumi.get(self, "forward_port_algorithm")

    @property
    @pulumi.getter(name="forwardProtocol")
    def forward_protocol(self) -> pulumi.Output[str]:
        """
        Backend protocol. Possible values are: `tcp` or `http`.
        """
        return pulumi.get(self, "forward_protocol")

    @property
    @pulumi.getter(name="healthCheckDelay")
    def health_check_delay(self) -> pulumi.Output[Optional[str]]:
        """
        Interval between two HC requests.
        """
        return pulumi.get(self, "health_check_delay")

    @property
    @pulumi.getter(name="healthCheckHttp")
    def health_check_http(self) -> pulumi.Output[Optional['outputs.LbBackendHealthCheckHttp']]:
        """
        This block enable HTTP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_http")

    @property
    @pulumi.getter(name="healthCheckHttps")
    def health_check_https(self) -> pulumi.Output[Optional['outputs.LbBackendHealthCheckHttps']]:
        """
        This block enable HTTPS health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_https")

    @property
    @pulumi.getter(name="healthCheckMaxRetries")
    def health_check_max_retries(self) -> pulumi.Output[Optional[int]]:
        """
        Number of allowed failed HC requests before the backend server is marked down.
        """
        return pulumi.get(self, "health_check_max_retries")

    @property
    @pulumi.getter(name="healthCheckPort")
    def health_check_port(self) -> pulumi.Output[int]:
        """
        Port the HC requests will be send to.
        """
        return pulumi.get(self, "health_check_port")

    @property
    @pulumi.getter(name="healthCheckSendProxy")
    def health_check_send_proxy(self) -> pulumi.Output[Optional[bool]]:
        """
        Defines whether proxy protocol should be activated for the health check.
        """
        return pulumi.get(self, "health_check_send_proxy")

    @property
    @pulumi.getter(name="healthCheckTcp")
    def health_check_tcp(self) -> pulumi.Output['outputs.LbBackendHealthCheckTcp']:
        """
        This block enable TCP health check. Only one of `health_check_tcp`, `health_check_http` and `health_check_https` should be specified.
        """
        return pulumi.get(self, "health_check_tcp")

    @property
    @pulumi.getter(name="healthCheckTimeout")
    def health_check_timeout(self) -> pulumi.Output[Optional[str]]:
        """
        Timeout before we consider a HC request failed.
        """
        return pulumi.get(self, "health_check_timeout")

    @property
    @pulumi.getter(name="healthCheckTransientDelay")
    def health_check_transient_delay(self) -> pulumi.Output[Optional[str]]:
        """
        The time to wait between two consecutive health checks when a backend server is in a transient state (going UP or DOWN).
        """
        return pulumi.get(self, "health_check_transient_delay")

    @property
    @pulumi.getter(name="ignoreSslServerVerify")
    def ignore_ssl_server_verify(self) -> pulumi.Output[Optional[bool]]:
        """
        Specifies whether the Load Balancer should check the backend serverâ€™s certificate before initiating a connection.
        """
        return pulumi.get(self, "ignore_ssl_server_verify")

    @property
    @pulumi.getter(name="lbId")
    def lb_id(self) -> pulumi.Output[str]:
        """
        The load-balancer ID this backend is attached to.
        > **Important:** Updates to `lb_id` will recreate the backend.
        """
        return pulumi.get(self, "lb_id")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> pulumi.Output[Optional[int]]:
        """
        Maximum number of connections allowed per backend server.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> pulumi.Output[Optional[int]]:
        """
        Number of retries when a backend server connection failed.
        """
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of the load-balancer backend.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="onMarkedDownAction")
    def on_marked_down_action(self) -> pulumi.Output[Optional[str]]:
        """
        Modify what occurs when a backend server is marked down. Possible values are: `none` and `shutdown_sessions`.
        """
        return pulumi.get(self, "on_marked_down_action")

    @property
    @pulumi.getter(name="proxyProtocol")
    def proxy_protocol(self) -> pulumi.Output[Optional[str]]:
        """
        Choose the type of PROXY protocol to enable (`none`, `v1`, `v2`, `v2_ssl`, `v2_ssl_cn`)
        """
        return pulumi.get(self, "proxy_protocol")

    @property
    @pulumi.getter(name="redispatchAttemptCount")
    def redispatch_attempt_count(self) -> pulumi.Output[Optional[int]]:
        """
        Whether to use another backend server on each attempt.
        """
        return pulumi.get(self, "redispatch_attempt_count")

    @property
    @pulumi.getter(name="sendProxyV2")
    def send_proxy_v2(self) -> pulumi.Output[bool]:
        """
        DEPRECATED please use `proxy_protocol` instead - (Default: `false`) Enables PROXY protocol version 2.
        """
        warnings.warn("""Please use proxy_protocol instead""", DeprecationWarning)
        pulumi.log.warn("""send_proxy_v2 is deprecated: Please use proxy_protocol instead""")

        return pulumi.get(self, "send_proxy_v2")

    @property
    @pulumi.getter(name="serverIps")
    def server_ips(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        List of backend server IP addresses. Addresses can be either IPv4 or IPv6.
        """
        return pulumi.get(self, "server_ips")

    @property
    @pulumi.getter(name="sslBridging")
    def ssl_bridging(self) -> pulumi.Output[Optional[bool]]:
        """
        Enables SSL between load balancer and backend servers.
        """
        return pulumi.get(self, "ssl_bridging")

    @property
    @pulumi.getter(name="stickySessions")
    def sticky_sessions(self) -> pulumi.Output[Optional[str]]:
        """
        The type of sticky sessions. The only current possible values are: `none`, `cookie` and `table`.
        """
        return pulumi.get(self, "sticky_sessions")

    @property
    @pulumi.getter(name="stickySessionsCookieName")
    def sticky_sessions_cookie_name(self) -> pulumi.Output[Optional[str]]:
        """
        Cookie name for sticky sessions. Only applicable when sticky_sessions is set to `cookie`.
        """
        return pulumi.get(self, "sticky_sessions_cookie_name")

    @property
    @pulumi.getter(name="timeoutConnect")
    def timeout_connect(self) -> pulumi.Output[Optional[str]]:
        """
        Maximum initial server connection establishment time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_connect")

    @property
    @pulumi.getter(name="timeoutQueue")
    def timeout_queue(self) -> pulumi.Output[Optional[str]]:
        """
        Maximum time for a request to be left pending in queue when `max_connections` is reached. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_queue")

    @property
    @pulumi.getter(name="timeoutServer")
    def timeout_server(self) -> pulumi.Output[Optional[str]]:
        """
        Maximum server connection inactivity time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_server")

    @property
    @pulumi.getter(name="timeoutTunnel")
    def timeout_tunnel(self) -> pulumi.Output[Optional[str]]:
        """
        Maximum tunnel inactivity time. (e.g.: `1s`)
        """
        return pulumi.get(self, "timeout_tunnel")

