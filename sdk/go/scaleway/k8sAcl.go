// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package scaleway

import (
	"context"
	"reflect"

	"errors"
	"github.com/dirien/pulumi-scaleway/sdk/v2/go/scaleway/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/dirien/pulumi-scaleway/sdk/v2/go/scaleway"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			aclBasicVpcPrivateNetwork, err := scaleway.NewVpcPrivateNetwork(ctx, "aclBasicVpcPrivateNetwork", nil)
//			if err != nil {
//				return err
//			}
//			aclBasicK8sCluster, err := scaleway.NewK8sCluster(ctx, "aclBasicK8sCluster", &scaleway.K8sClusterArgs{
//				Version:                   pulumi.String("1.32.2"),
//				Cni:                       pulumi.String("cilium"),
//				DeleteAdditionalResources: pulumi.Bool(true),
//				PrivateNetworkId:          aclBasicVpcPrivateNetwork.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = scaleway.NewK8sAcl(ctx, "aclBasicK8sAcl", &scaleway.K8sAclArgs{
//				ClusterId: aclBasicK8sCluster.ID(),
//				AclRules: scaleway.K8sAclAclRuleArray{
//					&scaleway.K8sAclAclRuleArgs{
//						Ip:          pulumi.String("1.2.3.4/32"),
//						Description: pulumi.String("Allow 1.2.3.4"),
//					},
//					&scaleway.K8sAclAclRuleArgs{
//						ScalewayRanges: pulumi.Bool(true),
//						Description:    pulumi.String("Allow all Scaleway ranges"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Full-isolation
//
// ```go
// package main
//
// import (
//
//	"github.com/dirien/pulumi-scaleway/sdk/v2/go/scaleway"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			aclBasicVpcPrivateNetwork, err := scaleway.NewVpcPrivateNetwork(ctx, "aclBasicVpcPrivateNetwork", nil)
//			if err != nil {
//				return err
//			}
//			aclBasicK8sCluster, err := scaleway.NewK8sCluster(ctx, "aclBasicK8sCluster", &scaleway.K8sClusterArgs{
//				Version:                   pulumi.String("1.32.2"),
//				Cni:                       pulumi.String("cilium"),
//				DeleteAdditionalResources: pulumi.Bool(true),
//				PrivateNetworkId:          aclBasicVpcPrivateNetwork.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = scaleway.NewK8sAcl(ctx, "aclBasicK8sAcl", &scaleway.K8sAclArgs{
//				ClusterId:   aclBasicK8sCluster.ID(),
//				NoIpAllowed: pulumi.Bool(true),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Kubernetes ACLs can be imported using the `{region}/{cluster-id}`, e.g.
//
// bash
//
// ```sh
// $ pulumi import scaleway:index/k8sAcl:K8sAcl acl01 fr-par/11111111-1111-1111-1111-111111111111
// ```
type K8sAcl struct {
	pulumi.CustomResourceState

	// A list of ACLs (structure is described below)
	//
	// > **Important:** This block cannot be defined if the `noIpAllowed` field is set to true.
	AclRules K8sAclAclRuleArrayOutput `pulumi:"aclRules"`
	// UUID of the cluster. The ID of the cluster is also the ID of the ACL resource, as there can only be one per cluster.
	//
	// > **Important:** Updates to `clusterId` will recreate the ACL.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// If set to true, no IP will be allowed and the cluster will be in full-isolation.
	//
	// > **Important:** This field cannot be set to true if the `aclRules` block is defined.
	NoIpAllowed pulumi.BoolPtrOutput `pulumi:"noIpAllowed"`
	// `region`) The region in which the ACL rule should be created.
	Region pulumi.StringOutput `pulumi:"region"`
}

// NewK8sAcl registers a new resource with the given unique name, arguments, and options.
func NewK8sAcl(ctx *pulumi.Context,
	name string, args *K8sAclArgs, opts ...pulumi.ResourceOption) (*K8sAcl, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource K8sAcl
	err := ctx.RegisterResource("scaleway:index/k8sAcl:K8sAcl", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetK8sAcl gets an existing K8sAcl resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetK8sAcl(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *K8sAclState, opts ...pulumi.ResourceOption) (*K8sAcl, error) {
	var resource K8sAcl
	err := ctx.ReadResource("scaleway:index/k8sAcl:K8sAcl", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering K8sAcl resources.
type k8sAclState struct {
	// A list of ACLs (structure is described below)
	//
	// > **Important:** This block cannot be defined if the `noIpAllowed` field is set to true.
	AclRules []K8sAclAclRule `pulumi:"aclRules"`
	// UUID of the cluster. The ID of the cluster is also the ID of the ACL resource, as there can only be one per cluster.
	//
	// > **Important:** Updates to `clusterId` will recreate the ACL.
	ClusterId *string `pulumi:"clusterId"`
	// If set to true, no IP will be allowed and the cluster will be in full-isolation.
	//
	// > **Important:** This field cannot be set to true if the `aclRules` block is defined.
	NoIpAllowed *bool `pulumi:"noIpAllowed"`
	// `region`) The region in which the ACL rule should be created.
	Region *string `pulumi:"region"`
}

type K8sAclState struct {
	// A list of ACLs (structure is described below)
	//
	// > **Important:** This block cannot be defined if the `noIpAllowed` field is set to true.
	AclRules K8sAclAclRuleArrayInput
	// UUID of the cluster. The ID of the cluster is also the ID of the ACL resource, as there can only be one per cluster.
	//
	// > **Important:** Updates to `clusterId` will recreate the ACL.
	ClusterId pulumi.StringPtrInput
	// If set to true, no IP will be allowed and the cluster will be in full-isolation.
	//
	// > **Important:** This field cannot be set to true if the `aclRules` block is defined.
	NoIpAllowed pulumi.BoolPtrInput
	// `region`) The region in which the ACL rule should be created.
	Region pulumi.StringPtrInput
}

func (K8sAclState) ElementType() reflect.Type {
	return reflect.TypeOf((*k8sAclState)(nil)).Elem()
}

type k8sAclArgs struct {
	// A list of ACLs (structure is described below)
	//
	// > **Important:** This block cannot be defined if the `noIpAllowed` field is set to true.
	AclRules []K8sAclAclRule `pulumi:"aclRules"`
	// UUID of the cluster. The ID of the cluster is also the ID of the ACL resource, as there can only be one per cluster.
	//
	// > **Important:** Updates to `clusterId` will recreate the ACL.
	ClusterId string `pulumi:"clusterId"`
	// If set to true, no IP will be allowed and the cluster will be in full-isolation.
	//
	// > **Important:** This field cannot be set to true if the `aclRules` block is defined.
	NoIpAllowed *bool `pulumi:"noIpAllowed"`
	// `region`) The region in which the ACL rule should be created.
	Region *string `pulumi:"region"`
}

// The set of arguments for constructing a K8sAcl resource.
type K8sAclArgs struct {
	// A list of ACLs (structure is described below)
	//
	// > **Important:** This block cannot be defined if the `noIpAllowed` field is set to true.
	AclRules K8sAclAclRuleArrayInput
	// UUID of the cluster. The ID of the cluster is also the ID of the ACL resource, as there can only be one per cluster.
	//
	// > **Important:** Updates to `clusterId` will recreate the ACL.
	ClusterId pulumi.StringInput
	// If set to true, no IP will be allowed and the cluster will be in full-isolation.
	//
	// > **Important:** This field cannot be set to true if the `aclRules` block is defined.
	NoIpAllowed pulumi.BoolPtrInput
	// `region`) The region in which the ACL rule should be created.
	Region pulumi.StringPtrInput
}

func (K8sAclArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*k8sAclArgs)(nil)).Elem()
}

type K8sAclInput interface {
	pulumi.Input

	ToK8sAclOutput() K8sAclOutput
	ToK8sAclOutputWithContext(ctx context.Context) K8sAclOutput
}

func (*K8sAcl) ElementType() reflect.Type {
	return reflect.TypeOf((**K8sAcl)(nil)).Elem()
}

func (i *K8sAcl) ToK8sAclOutput() K8sAclOutput {
	return i.ToK8sAclOutputWithContext(context.Background())
}

func (i *K8sAcl) ToK8sAclOutputWithContext(ctx context.Context) K8sAclOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sAclOutput)
}

// K8sAclArrayInput is an input type that accepts K8sAclArray and K8sAclArrayOutput values.
// You can construct a concrete instance of `K8sAclArrayInput` via:
//
//	K8sAclArray{ K8sAclArgs{...} }
type K8sAclArrayInput interface {
	pulumi.Input

	ToK8sAclArrayOutput() K8sAclArrayOutput
	ToK8sAclArrayOutputWithContext(context.Context) K8sAclArrayOutput
}

type K8sAclArray []K8sAclInput

func (K8sAclArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8sAcl)(nil)).Elem()
}

func (i K8sAclArray) ToK8sAclArrayOutput() K8sAclArrayOutput {
	return i.ToK8sAclArrayOutputWithContext(context.Background())
}

func (i K8sAclArray) ToK8sAclArrayOutputWithContext(ctx context.Context) K8sAclArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sAclArrayOutput)
}

// K8sAclMapInput is an input type that accepts K8sAclMap and K8sAclMapOutput values.
// You can construct a concrete instance of `K8sAclMapInput` via:
//
//	K8sAclMap{ "key": K8sAclArgs{...} }
type K8sAclMapInput interface {
	pulumi.Input

	ToK8sAclMapOutput() K8sAclMapOutput
	ToK8sAclMapOutputWithContext(context.Context) K8sAclMapOutput
}

type K8sAclMap map[string]K8sAclInput

func (K8sAclMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8sAcl)(nil)).Elem()
}

func (i K8sAclMap) ToK8sAclMapOutput() K8sAclMapOutput {
	return i.ToK8sAclMapOutputWithContext(context.Background())
}

func (i K8sAclMap) ToK8sAclMapOutputWithContext(ctx context.Context) K8sAclMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(K8sAclMapOutput)
}

type K8sAclOutput struct{ *pulumi.OutputState }

func (K8sAclOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**K8sAcl)(nil)).Elem()
}

func (o K8sAclOutput) ToK8sAclOutput() K8sAclOutput {
	return o
}

func (o K8sAclOutput) ToK8sAclOutputWithContext(ctx context.Context) K8sAclOutput {
	return o
}

// A list of ACLs (structure is described below)
//
// > **Important:** This block cannot be defined if the `noIpAllowed` field is set to true.
func (o K8sAclOutput) AclRules() K8sAclAclRuleArrayOutput {
	return o.ApplyT(func(v *K8sAcl) K8sAclAclRuleArrayOutput { return v.AclRules }).(K8sAclAclRuleArrayOutput)
}

// UUID of the cluster. The ID of the cluster is also the ID of the ACL resource, as there can only be one per cluster.
//
// > **Important:** Updates to `clusterId` will recreate the ACL.
func (o K8sAclOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *K8sAcl) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// If set to true, no IP will be allowed and the cluster will be in full-isolation.
//
// > **Important:** This field cannot be set to true if the `aclRules` block is defined.
func (o K8sAclOutput) NoIpAllowed() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *K8sAcl) pulumi.BoolPtrOutput { return v.NoIpAllowed }).(pulumi.BoolPtrOutput)
}

// `region`) The region in which the ACL rule should be created.
func (o K8sAclOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *K8sAcl) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

type K8sAclArrayOutput struct{ *pulumi.OutputState }

func (K8sAclArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*K8sAcl)(nil)).Elem()
}

func (o K8sAclArrayOutput) ToK8sAclArrayOutput() K8sAclArrayOutput {
	return o
}

func (o K8sAclArrayOutput) ToK8sAclArrayOutputWithContext(ctx context.Context) K8sAclArrayOutput {
	return o
}

func (o K8sAclArrayOutput) Index(i pulumi.IntInput) K8sAclOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *K8sAcl {
		return vs[0].([]*K8sAcl)[vs[1].(int)]
	}).(K8sAclOutput)
}

type K8sAclMapOutput struct{ *pulumi.OutputState }

func (K8sAclMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*K8sAcl)(nil)).Elem()
}

func (o K8sAclMapOutput) ToK8sAclMapOutput() K8sAclMapOutput {
	return o
}

func (o K8sAclMapOutput) ToK8sAclMapOutputWithContext(ctx context.Context) K8sAclMapOutput {
	return o
}

func (o K8sAclMapOutput) MapIndex(k pulumi.StringInput) K8sAclOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *K8sAcl {
		return vs[0].(map[string]*K8sAcl)[vs[1].(string)]
	}).(K8sAclOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*K8sAclInput)(nil)).Elem(), &K8sAcl{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sAclArrayInput)(nil)).Elem(), K8sAclArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*K8sAclMapInput)(nil)).Elem(), K8sAclMap{})
	pulumi.RegisterOutputType(K8sAclOutput{})
	pulumi.RegisterOutputType(K8sAclArrayOutput{})
	pulumi.RegisterOutputType(K8sAclMapOutput{})
}
