// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package scaleway

import (
	"context"
	"reflect"

	"errors"
	"github.com/dirien/pulumi-scaleway/sdk/v2/go/scaleway/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates and manages Scaleway VPC ACLs.
//
// ## Example Usage
//
// ### Basic
//
// ```go
// package main
//
// import (
//
//	"github.com/dirien/pulumi-scaleway/sdk/v2/go/scaleway"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			vpc01, err := scaleway.NewVpc(ctx, "vpc01", nil)
//			if err != nil {
//				return err
//			}
//			_, err = scaleway.NewVpcAcl(ctx, "acl01", &scaleway.VpcAclArgs{
//				VpcId:  vpc01.ID(),
//				IsIpv6: pulumi.Bool(false),
//				Rules: scaleway.VpcAclRuleArray{
//					&scaleway.VpcAclRuleArgs{
//						Protocol:    pulumi.String("TCP"),
//						SrcPortLow:  pulumi.Int(0),
//						SrcPortHigh: pulumi.Int(0),
//						DstPortLow:  pulumi.Int(80),
//						DstPortHigh: pulumi.Int(80),
//						Source:      pulumi.String("0.0.0.0/0"),
//						Destination: pulumi.String("0.0.0.0/0"),
//						Description: pulumi.String("Allow HTTP traffic from any source"),
//						Action:      pulumi.String("accept"),
//					},
//				},
//				DefaultPolicy: pulumi.String("drop"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ACLs can be imported using `{region}/{id}`, e.g.
//
// bash
//
// ```sh
// $ pulumi import scaleway:index/vpcAcl:VpcAcl main fr-par/11111111-1111-1111-1111-111111111111
// ```
type VpcAcl struct {
	pulumi.CustomResourceState

	// The action to take for packets which do not match any rules.
	DefaultPolicy pulumi.StringOutput `pulumi:"defaultPolicy"`
	// Defines whether this set of ACL rules is for IPv6 (false = IPv4). Each Network ACL can have rules for only one IP type.
	IsIpv6 pulumi.BoolPtrOutput `pulumi:"isIpv6"`
	// `region`) The region of the ACL.
	Region pulumi.StringOutput `pulumi:"region"`
	// The list of Network ACL rules.
	Rules VpcAclRuleArrayOutput `pulumi:"rules"`
	// The VPC ID the ACL belongs to.
	VpcId pulumi.StringOutput `pulumi:"vpcId"`
}

// NewVpcAcl registers a new resource with the given unique name, arguments, and options.
func NewVpcAcl(ctx *pulumi.Context,
	name string, args *VpcAclArgs, opts ...pulumi.ResourceOption) (*VpcAcl, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DefaultPolicy == nil {
		return nil, errors.New("invalid value for required argument 'DefaultPolicy'")
	}
	if args.Rules == nil {
		return nil, errors.New("invalid value for required argument 'Rules'")
	}
	if args.VpcId == nil {
		return nil, errors.New("invalid value for required argument 'VpcId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource VpcAcl
	err := ctx.RegisterResource("scaleway:index/vpcAcl:VpcAcl", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetVpcAcl gets an existing VpcAcl resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVpcAcl(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *VpcAclState, opts ...pulumi.ResourceOption) (*VpcAcl, error) {
	var resource VpcAcl
	err := ctx.ReadResource("scaleway:index/vpcAcl:VpcAcl", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering VpcAcl resources.
type vpcAclState struct {
	// The action to take for packets which do not match any rules.
	DefaultPolicy *string `pulumi:"defaultPolicy"`
	// Defines whether this set of ACL rules is for IPv6 (false = IPv4). Each Network ACL can have rules for only one IP type.
	IsIpv6 *bool `pulumi:"isIpv6"`
	// `region`) The region of the ACL.
	Region *string `pulumi:"region"`
	// The list of Network ACL rules.
	Rules []VpcAclRule `pulumi:"rules"`
	// The VPC ID the ACL belongs to.
	VpcId *string `pulumi:"vpcId"`
}

type VpcAclState struct {
	// The action to take for packets which do not match any rules.
	DefaultPolicy pulumi.StringPtrInput
	// Defines whether this set of ACL rules is for IPv6 (false = IPv4). Each Network ACL can have rules for only one IP type.
	IsIpv6 pulumi.BoolPtrInput
	// `region`) The region of the ACL.
	Region pulumi.StringPtrInput
	// The list of Network ACL rules.
	Rules VpcAclRuleArrayInput
	// The VPC ID the ACL belongs to.
	VpcId pulumi.StringPtrInput
}

func (VpcAclState) ElementType() reflect.Type {
	return reflect.TypeOf((*vpcAclState)(nil)).Elem()
}

type vpcAclArgs struct {
	// The action to take for packets which do not match any rules.
	DefaultPolicy string `pulumi:"defaultPolicy"`
	// Defines whether this set of ACL rules is for IPv6 (false = IPv4). Each Network ACL can have rules for only one IP type.
	IsIpv6 *bool `pulumi:"isIpv6"`
	// `region`) The region of the ACL.
	Region *string `pulumi:"region"`
	// The list of Network ACL rules.
	Rules []VpcAclRule `pulumi:"rules"`
	// The VPC ID the ACL belongs to.
	VpcId string `pulumi:"vpcId"`
}

// The set of arguments for constructing a VpcAcl resource.
type VpcAclArgs struct {
	// The action to take for packets which do not match any rules.
	DefaultPolicy pulumi.StringInput
	// Defines whether this set of ACL rules is for IPv6 (false = IPv4). Each Network ACL can have rules for only one IP type.
	IsIpv6 pulumi.BoolPtrInput
	// `region`) The region of the ACL.
	Region pulumi.StringPtrInput
	// The list of Network ACL rules.
	Rules VpcAclRuleArrayInput
	// The VPC ID the ACL belongs to.
	VpcId pulumi.StringInput
}

func (VpcAclArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*vpcAclArgs)(nil)).Elem()
}

type VpcAclInput interface {
	pulumi.Input

	ToVpcAclOutput() VpcAclOutput
	ToVpcAclOutputWithContext(ctx context.Context) VpcAclOutput
}

func (*VpcAcl) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcAcl)(nil)).Elem()
}

func (i *VpcAcl) ToVpcAclOutput() VpcAclOutput {
	return i.ToVpcAclOutputWithContext(context.Background())
}

func (i *VpcAcl) ToVpcAclOutputWithContext(ctx context.Context) VpcAclOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAclOutput)
}

// VpcAclArrayInput is an input type that accepts VpcAclArray and VpcAclArrayOutput values.
// You can construct a concrete instance of `VpcAclArrayInput` via:
//
//	VpcAclArray{ VpcAclArgs{...} }
type VpcAclArrayInput interface {
	pulumi.Input

	ToVpcAclArrayOutput() VpcAclArrayOutput
	ToVpcAclArrayOutputWithContext(context.Context) VpcAclArrayOutput
}

type VpcAclArray []VpcAclInput

func (VpcAclArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VpcAcl)(nil)).Elem()
}

func (i VpcAclArray) ToVpcAclArrayOutput() VpcAclArrayOutput {
	return i.ToVpcAclArrayOutputWithContext(context.Background())
}

func (i VpcAclArray) ToVpcAclArrayOutputWithContext(ctx context.Context) VpcAclArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAclArrayOutput)
}

// VpcAclMapInput is an input type that accepts VpcAclMap and VpcAclMapOutput values.
// You can construct a concrete instance of `VpcAclMapInput` via:
//
//	VpcAclMap{ "key": VpcAclArgs{...} }
type VpcAclMapInput interface {
	pulumi.Input

	ToVpcAclMapOutput() VpcAclMapOutput
	ToVpcAclMapOutputWithContext(context.Context) VpcAclMapOutput
}

type VpcAclMap map[string]VpcAclInput

func (VpcAclMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VpcAcl)(nil)).Elem()
}

func (i VpcAclMap) ToVpcAclMapOutput() VpcAclMapOutput {
	return i.ToVpcAclMapOutputWithContext(context.Background())
}

func (i VpcAclMap) ToVpcAclMapOutputWithContext(ctx context.Context) VpcAclMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(VpcAclMapOutput)
}

type VpcAclOutput struct{ *pulumi.OutputState }

func (VpcAclOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**VpcAcl)(nil)).Elem()
}

func (o VpcAclOutput) ToVpcAclOutput() VpcAclOutput {
	return o
}

func (o VpcAclOutput) ToVpcAclOutputWithContext(ctx context.Context) VpcAclOutput {
	return o
}

// The action to take for packets which do not match any rules.
func (o VpcAclOutput) DefaultPolicy() pulumi.StringOutput {
	return o.ApplyT(func(v *VpcAcl) pulumi.StringOutput { return v.DefaultPolicy }).(pulumi.StringOutput)
}

// Defines whether this set of ACL rules is for IPv6 (false = IPv4). Each Network ACL can have rules for only one IP type.
func (o VpcAclOutput) IsIpv6() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *VpcAcl) pulumi.BoolPtrOutput { return v.IsIpv6 }).(pulumi.BoolPtrOutput)
}

// `region`) The region of the ACL.
func (o VpcAclOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *VpcAcl) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The list of Network ACL rules.
func (o VpcAclOutput) Rules() VpcAclRuleArrayOutput {
	return o.ApplyT(func(v *VpcAcl) VpcAclRuleArrayOutput { return v.Rules }).(VpcAclRuleArrayOutput)
}

// The VPC ID the ACL belongs to.
func (o VpcAclOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v *VpcAcl) pulumi.StringOutput { return v.VpcId }).(pulumi.StringOutput)
}

type VpcAclArrayOutput struct{ *pulumi.OutputState }

func (VpcAclArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*VpcAcl)(nil)).Elem()
}

func (o VpcAclArrayOutput) ToVpcAclArrayOutput() VpcAclArrayOutput {
	return o
}

func (o VpcAclArrayOutput) ToVpcAclArrayOutputWithContext(ctx context.Context) VpcAclArrayOutput {
	return o
}

func (o VpcAclArrayOutput) Index(i pulumi.IntInput) VpcAclOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *VpcAcl {
		return vs[0].([]*VpcAcl)[vs[1].(int)]
	}).(VpcAclOutput)
}

type VpcAclMapOutput struct{ *pulumi.OutputState }

func (VpcAclMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*VpcAcl)(nil)).Elem()
}

func (o VpcAclMapOutput) ToVpcAclMapOutput() VpcAclMapOutput {
	return o
}

func (o VpcAclMapOutput) ToVpcAclMapOutputWithContext(ctx context.Context) VpcAclMapOutput {
	return o
}

func (o VpcAclMapOutput) MapIndex(k pulumi.StringInput) VpcAclOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *VpcAcl {
		return vs[0].(map[string]*VpcAcl)[vs[1].(string)]
	}).(VpcAclOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*VpcAclInput)(nil)).Elem(), &VpcAcl{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcAclArrayInput)(nil)).Elem(), VpcAclArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*VpcAclMapInput)(nil)).Elem(), VpcAclMap{})
	pulumi.RegisterOutputType(VpcAclOutput{})
	pulumi.RegisterOutputType(VpcAclArrayOutput{})
	pulumi.RegisterOutputType(VpcAclMapOutput{})
}
